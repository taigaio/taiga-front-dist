
/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: app.coffee
 */

(function() {
  var configure, i18nInit, init, module, modules, pluginsModules, pluginsWithModule, taiga;

  this.taiga = taiga = {};

  taiga.emojis = window.emojis;

  this.taigaContribPlugins = this.taigaContribPlugins || window.taigaContribPlugins || [];

  taiga.generateHash = function(components) {
    if (components == null) {
      components = [];
    }
    components = _.map(components, function(x) {
      return JSON.stringify(x);
    });
    return hex_sha1(components.join(":"));
  };

  taiga.generateUniqueSessionIdentifier = function() {
    var date, randomNumber;
    date = (new Date()).getTime();
    randomNumber = Math.floor(Math.random() * 0x9000000);
    return taiga.generateHash([date, randomNumber]);
  };

  taiga.sessionId = taiga.generateUniqueSessionIdentifier();

  configure = function($routeProvider, $locationProvider, $httpProvider, $provide, $tgEventsProvider, $compileProvider, $translateProvider, $translatePartialLoaderProvider, $animateProvider) {
    var authHttpIntercept, blockingIntercept, decorators, defaultHeaders, loaderIntercept, originalWhen, preferedLangCode, userInfo, versionCheckHttpIntercept;
    $animateProvider.classNameFilter(/^(?:(?!ng-animate-disabled).)*$/);
    originalWhen = $routeProvider.when;
    $routeProvider.when = function(path, route) {
      route.resolve || (route.resolve = {});
      angular.extend(route.resolve, {
        languageLoad: [
          "$q", "$translate", function($q, $translate) {
            var deferred;
            deferred = $q.defer();
            $translate().then(function() {
              return deferred.resolve();
            });
            return deferred.promise;
          }
        ],
        projectLoaded: [
          "$q", "tgProjectService", "$route", function($q, projectService, $route) {
            var deferred, ref;
            deferred = $q.defer();
            projectService.setSection((ref = $route.current.$$route) != null ? ref.section : void 0);
            if ($route.current.params.pslug) {
              projectService.setProjectBySlug($route.current.params.pslug).then(deferred.resolve);
            } else {
              projectService.cleanProject();
              deferred.resolve();
            }
            return deferred.promise;
          }
        ]
      });
      return originalWhen.call($routeProvider, path, route);
    };
    $routeProvider.when("/", {
      templateUrl: "home/home.html",
      controller: "Home",
      controllerAs: "vm",
      loader: true,
      title: "HOME.PAGE_TITLE",
      loader: true,
      description: "HOME.PAGE_DESCRIPTION",
      joyride: "dashboard"
    });
    $routeProvider.when("/discover", {
      templateUrl: "discover/discover-home/discover-home.html",
      controller: "DiscoverHome",
      controllerAs: "vm",
      title: "PROJECT.NAVIGATION.DISCOVER",
      loader: true
    });
    $routeProvider.when("/discover/search", {
      templateUrl: "discover/discover-search/discover-search.html",
      title: "PROJECT.NAVIGATION.DISCOVER",
      loader: true,
      controller: "DiscoverSearch",
      controllerAs: "vm",
      reloadOnSearch: false
    });
    $routeProvider.when("/projects/", {
      templateUrl: "projects/listing/projects-listing.html",
      access: {
        requiresLogin: true
      },
      title: "PROJECTS.PAGE_TITLE",
      description: "PROJECTS.PAGE_DESCRIPTION",
      loader: true,
      controller: "ProjectsListing",
      controllerAs: "vm"
    });
    $routeProvider.when("/project/new", {
      title: "PROJECT.CREATE.TITLE",
      templateUrl: "projects/create/create-project.html",
      loader: true,
      controller: "CreateProjectCtrl",
      controllerAs: "vm"
    });
    $routeProvider.when("/project/new/scrum", {
      title: "PROJECT.CREATE.TITLE",
      template: "<tg-create-project-form type=\"scrum\"></tg-create-project-form>",
      loader: true
    });
    $routeProvider.when("/project/new/kanban", {
      title: "PROJECT.CREATE.TITLE",
      template: "<tg-create-project-form type=\"kanban\"></tg-create-project-form>",
      loader: true
    });
    $routeProvider.when("/project/new/duplicate", {
      title: "PROJECT.CREATE.TITLE",
      template: "<tg-duplicate-project></tg-duplicate-project>",
      loader: true
    });
    $routeProvider.when("/project/new/import/:platform?", {
      title: "PROJECT.CREATE.TITLE",
      template: "<tg-import-project></tg-import-project>",
      loader: true
    });
    $routeProvider.when("/project/:pslug/", {
      template: "",
      loader: true,
      controller: "ProjectRouter"
    });
    $routeProvider.when("/project/:pslug/timeline", {
      templateUrl: "projects/project/project.html",
      loader: true,
      controller: "Project",
      controllerAs: "vm",
      section: "project-timeline"
    });
    $routeProvider.when("/project/:pslug/t/:ref", {
      loader: true,
      controller: "DetailController",
      template: ""
    });
    $routeProvider.when("/project/:pslug/search", {
      templateUrl: "search/search.html",
      reloadOnSearch: false,
      section: "search",
      loader: true
    });
    $routeProvider.when("/project/:pslug/epics", {
      section: "epics",
      templateUrl: "epics/dashboard/epics-dashboard.html",
      loader: true,
      controller: "EpicsDashboardCtrl",
      controllerAs: "vm"
    });
    $routeProvider.when("/project/:pslug/epic/:epicref", {
      templateUrl: "epic/epic-detail.html",
      loader: true,
      section: "epics"
    });
    $routeProvider.when("/project/:pslug/backlog", {
      templateUrl: "backlog/backlog.html",
      loader: true,
      section: "backlog",
      joyride: "backlog"
    });
    $routeProvider.when("/project/:pslug/kanban", {
      templateUrl: "kanban/kanban.html",
      loader: true,
      section: "kanban",
      joyride: "kanban"
    });
    $routeProvider.when("/project/:pslug/taskboard/:sslug", {
      templateUrl: "taskboard/taskboard.html",
      loader: true,
      section: "backlog"
    });
    $routeProvider.when("/project/:pslug/us/:usref", {
      templateUrl: "us/us-detail.html",
      loader: true,
      section: "backlog-kanban"
    });
    $routeProvider.when("/project/:pslug/task/:taskref", {
      templateUrl: "task/task-detail.html",
      loader: true,
      section: "backlog-kanban"
    });
    $routeProvider.when("/project/:pslug/wiki", {
      redirectTo: function(params) {
        return "/project/" + params.pslug + "/wiki/home";
      }
    });
    $routeProvider.when("/project/:pslug/wiki-list", {
      templateUrl: "wiki/wiki-list.html",
      loader: true,
      section: "wiki"
    });
    $routeProvider.when("/project/:pslug/wiki/:slug", {
      templateUrl: "wiki/wiki.html",
      loader: true,
      section: "wiki"
    });
    $routeProvider.when("/project/:pslug/team", {
      templateUrl: "team/team.html",
      loader: true,
      section: "team"
    });
    $routeProvider.when("/project/:pslug/issues", {
      templateUrl: "issue/issues.html",
      loader: true,
      section: "issues"
    });
    $routeProvider.when("/project/:pslug/issue/:issueref", {
      templateUrl: "issue/issues-detail.html",
      loader: true,
      section: "issues"
    });
    $routeProvider.when("/project/:pslug/admin/project-profile/details", {
      templateUrl: "admin/admin-project-profile.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-profile/default-values", {
      templateUrl: "admin/admin-project-default-values.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-profile/modules", {
      templateUrl: "admin/admin-project-modules.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-profile/export", {
      templateUrl: "admin/admin-project-export.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-profile/reports", {
      templateUrl: "admin/admin-project-reports.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-values/status", {
      templateUrl: "admin/admin-project-values-status.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-values/points", {
      templateUrl: "admin/admin-project-values-points.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-values/priorities", {
      templateUrl: "admin/admin-project-values-priorities.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-values/severities", {
      templateUrl: "admin/admin-project-values-severities.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-values/types", {
      templateUrl: "admin/admin-project-values-types.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-values/custom-fields", {
      templateUrl: "admin/admin-project-values-custom-fields.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-values/tags", {
      templateUrl: "admin/admin-project-values-tags.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/project-values/due-dates", {
      templateUrl: "admin/admin-project-values-due-dates.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/memberships", {
      templateUrl: "admin/admin-memberships.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/roles", {
      templateUrl: "admin/admin-roles.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/third-parties/webhooks", {
      templateUrl: "admin/admin-third-parties-webhooks.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/third-parties/github", {
      templateUrl: "admin/admin-third-parties-github.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/third-parties/gitlab", {
      templateUrl: "admin/admin-third-parties-gitlab.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/third-parties/bitbucket", {
      templateUrl: "admin/admin-third-parties-bitbucket.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/third-parties/gogs", {
      templateUrl: "admin/admin-third-parties-gogs.html",
      section: "admin"
    });
    $routeProvider.when("/project/:pslug/admin/contrib/:plugin", {
      templateUrl: "contrib/main.html"
    });
    $routeProvider.when("/project/:pslug/transfer/:token", {
      templateUrl: "projects/transfer/transfer-page.html",
      loader: true,
      controller: "Project",
      controllerAs: "vm"
    });
    $routeProvider.when("/user-settings/user-profile", {
      templateUrl: "user/user-profile.html"
    });
    $routeProvider.when("/user-settings/user-change-password", {
      templateUrl: "user/user-change-password.html"
    });
    $routeProvider.when("/user-settings/user-project-settings", {
      templateUrl: "user/user-project-settings.html"
    });
    $routeProvider.when("/user-settings/mail-notifications", {
      templateUrl: "user/mail-notifications.html"
    });
    $routeProvider.when("/user-settings/live-notifications", {
      templateUrl: "user/live-notifications.html"
    });
    $routeProvider.when("/user-settings/web-notifications", {
      templateUrl: "user/web-notifications.html"
    });
    $routeProvider.when("/change-email/:email_token", {
      templateUrl: "user/change-email.html"
    });
    $routeProvider.when("/verify-email/:email_token", {
      templateUrl: "user/verify-email.html"
    });
    $routeProvider.when("/cancel-account/:cancel_token", {
      templateUrl: "user/cancel-account.html"
    });
    $routeProvider.when("/user-settings/contrib/:plugin", {
      templateUrl: "contrib/user-settings.html"
    });
    $routeProvider.when("/profile", {
      templateUrl: "profile/profile.html",
      loader: true,
      access: {
        requiresLogin: true
      },
      controller: "Profile",
      controllerAs: "vm"
    });
    $routeProvider.when("/notifications", {
      templateUrl: "notifications/notifications.html",
      loader: true,
      access: {
        requiresLogin: true
      },
      controller: "Notifications",
      controllerAs: "vm"
    });
    $routeProvider.when("/profile/:slug", {
      templateUrl: "profile/profile.html",
      loader: true,
      controller: "Profile",
      controllerAs: "vm"
    });
    $routeProvider.when("/login", {
      templateUrl: "auth/login.html",
      title: "LOGIN.PAGE_TITLE",
      description: "LOGIN.PAGE_DESCRIPTION",
      disableHeader: true,
      controller: "LoginPage"
    });
    $routeProvider.when("/register", {
      templateUrl: "auth/register.html",
      title: "REGISTER.PAGE_TITLE",
      description: "REGISTER.PAGE_DESCRIPTION",
      disableHeader: true
    });
    $routeProvider.when("/forgot-password", {
      templateUrl: "auth/forgot-password.html",
      title: "FORGOT_PASSWORD.PAGE_TITLE",
      description: "FORGOT_PASSWORD.PAGE_DESCRIPTION",
      disableHeader: true
    });
    $routeProvider.when("/change-password/:token", {
      templateUrl: "auth/change-password-from-recovery.html",
      title: "CHANGE_PASSWORD.PAGE_TITLE",
      description: "CHANGE_PASSWORD.PAGE_TITLE",
      disableHeader: true
    });
    $routeProvider.when("/invitation/:token", {
      templateUrl: "auth/invitation.html",
      title: "INVITATION.PAGE_TITLE",
      description: "INVITATION.PAGE_DESCRIPTION",
      disableHeader: true
    });
    $routeProvider.when("/external-apps", {
      templateUrl: "external-apps/external-app.html",
      title: "EXTERNAL_APP.PAGE_TITLE",
      description: "EXTERNAL_APP.PAGE_DESCRIPTION",
      controller: "ExternalApp",
      controllerAs: "vm",
      disableHeader: true,
      mobileViewport: true
    });
    $routeProvider.when("/blocked-project/:pslug/", {
      templateUrl: "projects/project/blocked-project.html",
      loader: true
    });
    $routeProvider.when("/error", {
      templateUrl: "error/error.html"
    });
    $routeProvider.when("/not-found", {
      templateUrl: "error/not-found.html"
    });
    $routeProvider.when("/permission-denied", {
      templateUrl: "error/permission-denied.html"
    });
    $routeProvider.otherwise({
      templateUrl: "error/not-found.html"
    });
    $locationProvider.html5Mode({
      enabled: true,
      requireBase: false
    });
    defaultHeaders = {
      "Content-Type": "application/json",
      "Accept-Language": window.taigaConfig.defaultLanguage || "en",
      "X-Session-Id": taiga.sessionId
    };
    $httpProvider.defaults.headers["delete"] = defaultHeaders;
    $httpProvider.defaults.headers.patch = defaultHeaders;
    $httpProvider.defaults.headers.post = defaultHeaders;
    $httpProvider.defaults.headers.put = defaultHeaders;
    $httpProvider.defaults.headers.get = {
      "X-Session-Id": taiga.sessionId
    };
    $httpProvider.useApplyAsync(true);
    $tgEventsProvider.setSessionId(taiga.sessionId);
    authHttpIntercept = function($q, $location, $navUrls, $lightboxService, errorHandlingService) {
      var httpResponseError;
      httpResponseError = function(response) {
        var nextUrl, search;
        if (response.status === 0 || (response.status === -1 && !response.config.cancelable)) {
          $lightboxService.closeAll();
          errorHandlingService.error();
        } else if (response.status === 401 && $location.url().indexOf('/login') === -1) {
          nextUrl = $location.url();
          search = $location.search();
          if (search.force_next) {
            $location.url($navUrls.resolve("login")).search("force_next", search.force_next);
          } else {
            $location.url($navUrls.resolve("login")).search({
              "unauthorized": true,
              "next": nextUrl
            });
          }
        }
        return $q.reject(response);
      };
      return {
        responseError: httpResponseError
      };
    };
    $provide.factory("authHttpIntercept", ["$q", "$location", "$tgNavUrls", "lightboxService", "tgErrorHandlingService", authHttpIntercept]);
    $httpProvider.interceptors.push("authHttpIntercept");
    loaderIntercept = function($q, loaderService) {
      return {
        request: function(config) {
          loaderService.logRequest();
          return config;
        },
        requestError: function(rejection) {
          loaderService.logResponse();
          return $q.reject(rejection);
        },
        responseError: function(rejection) {
          loaderService.logResponse();
          return $q.reject(rejection);
        },
        response: function(response) {
          loaderService.logResponse();
          return response;
        }
      };
    };
    $provide.factory("loaderIntercept", ["$q", "tgLoader", loaderIntercept]);
    $httpProvider.interceptors.push("loaderIntercept");
    versionCheckHttpIntercept = function($q) {
      var httpResponseError;
      httpResponseError = function(response) {
        var $injector;
        if (response.status === 400 && response.data.version) {
          $injector = angular.element("body").injector();
          $injector.invoke([
            "$tgConfirm", "$translate", (function(_this) {
              return function($confirm, $translate) {
                var versionErrorMsg;
                versionErrorMsg = $translate.instant("ERROR.VERSION_ERROR");
                return $confirm.notify("error", versionErrorMsg, null, 10000);
              };
            })(this)
          ]);
        }
        return $q.reject(response);
      };
      return {
        responseError: httpResponseError
      };
    };
    $provide.factory("versionCheckHttpIntercept", ["$q", versionCheckHttpIntercept]);
    $httpProvider.interceptors.push("versionCheckHttpIntercept");
    blockingIntercept = function($q, errorHandlingService) {
      var redirectToBlockedPage, responseError, responseOk;
      redirectToBlockedPage = function() {
        return errorHandlingService.block();
      };
      responseOk = function(response) {
        if (response.data.blocked_code) {
          redirectToBlockedPage();
        }
        return response;
      };
      responseError = function(response) {
        if (response.status === 451) {
          redirectToBlockedPage();
        }
        return $q.reject(response);
      };
      return {
        response: responseOk,
        responseError: responseError
      };
    };
    $provide.factory("blockingIntercept", ["$q", "tgErrorHandlingService", blockingIntercept]);
    $httpProvider.interceptors.push("blockingIntercept");
    $compileProvider.debugInfoEnabled(window.taigaConfig.debugInfo || false);
    if (localStorage.userInfo) {
      userInfo = JSON.parse(localStorage.userInfo);
    }
    preferedLangCode = (userInfo != null ? userInfo.lang : void 0) || window.taigaConfig.defaultLanguage || "en";
    $translatePartialLoaderProvider.addPart('taiga');
    $translateProvider.useLoader('$translatePartialLoader', {
      urlTemplate: '/' + window._version + '/locales/{part}/locale-{lang}.json'
    }).useSanitizeValueStrategy('escapeParameters').addInterpolation('$translateMessageFormatInterpolation').preferredLanguage(preferedLangCode);
    $translateProvider.fallbackLanguage(preferedLangCode);
    decorators = window.getDecorators();
    return _.each(decorators, function(decorator) {
      return $provide.decorator(decorator.provider, decorator.decorator);
    });
  };

  i18nInit = function(lang, $translate) {
    var messages;
    moment.locale(lang);
    if (lang !== 'en') {
      ljs.load(("/" + window._version + "/locales/moment-locales/") + lang + ".js");
    }
    messages = {
      defaultMessage: $translate.instant("COMMON.FORM_ERRORS.DEFAULT_MESSAGE"),
      type: {
        email: $translate.instant("COMMON.FORM_ERRORS.TYPE_EMAIL"),
        url: $translate.instant("COMMON.FORM_ERRORS.TYPE_URL"),
        urlstrict: $translate.instant("COMMON.FORM_ERRORS.TYPE_URLSTRICT"),
        number: $translate.instant("COMMON.FORM_ERRORS.TYPE_NUMBER"),
        digits: $translate.instant("COMMON.FORM_ERRORS.TYPE_DIGITS"),
        dateIso: $translate.instant("COMMON.FORM_ERRORS.TYPE_DATEISO"),
        alphanum: $translate.instant("COMMON.FORM_ERRORS.TYPE_ALPHANUM"),
        phone: $translate.instant("COMMON.FORM_ERRORS.TYPE_PHONE")
      },
      notnull: $translate.instant("COMMON.FORM_ERRORS.NOTNULL"),
      notblank: $translate.instant("COMMON.FORM_ERRORS.NOT_BLANK"),
      required: $translate.instant("COMMON.FORM_ERRORS.REQUIRED"),
      regexp: $translate.instant("COMMON.FORM_ERRORS.REGEXP"),
      min: $translate.instant("COMMON.FORM_ERRORS.MIN"),
      max: $translate.instant("COMMON.FORM_ERRORS.MAX"),
      range: $translate.instant("COMMON.FORM_ERRORS.RANGE"),
      minlength: $translate.instant("COMMON.FORM_ERRORS.MIN_LENGTH"),
      maxlength: $translate.instant("COMMON.FORM_ERRORS.MAX_LENGTH"),
      rangelength: $translate.instant("COMMON.FORM_ERRORS.RANGE_LENGTH"),
      mincheck: $translate.instant("COMMON.FORM_ERRORS.MIN_CHECK"),
      maxcheck: $translate.instant("COMMON.FORM_ERRORS.MAX_CHECK"),
      rangecheck: $translate.instant("COMMON.FORM_ERRORS.RANGE_CHECK"),
      equalto: $translate.instant("COMMON.FORM_ERRORS.EQUAL_TO"),
      linewidth: $translate.instant("COMMON.FORM_ERRORS.LINEWIDTH"),
      pikaday: $translate.instant("COMMON.FORM_ERRORS.PIKADAY")
    };
    return checksley.updateMessages('default', messages);
  };

  init = function($log, $rootscope, $auth, $events, $analytics, $tagManager, $userPilot, $translate, $location, $navUrls, appMetaService, loaderService, navigationBarService, errorHandlingService, lightboxService, $tgConfig, projectService) {
    var un, user, validators;
    $log.debug("Initialize application");
    $rootscope.$on('$translatePartialLoaderStructureChanged', function() {
      return $translate.refresh();
    });
    validators = {
      linewidth: function(val, width) {
        var lines, valid;
        lines = taiga.nl2br(val).split("<br />");
        valid = _.every(lines, function(line) {
          return line.length < width;
        });
        return valid;
      },
      pikaday: function(val) {
        var prettyDate;
        prettyDate = $translate.instant("COMMON.PICKERDATE.FORMAT");
        return moment(val, prettyDate).isValid();
      },
      url: function(val) {
        var re_weburl;
        re_weburl = new RegExp("^" + "(?:(?:https?|ftp)://)" + "(?:\\S+(?::\\S*)?@)?" + "(?:" + "(?!(?:10|127)(?:\\.\\d{1,3}){3})" + "(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})" + "(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})" + "(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])" + "(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}" + "(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))" + "|" + "(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)" + "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*" + "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))" + "\\.?" + ")" + "(?::\\d{2,5})?" + "(?:[/?#]\\S*)?" + "$", "i");
        return re_weburl.test(val);
      }
    };
    checksley.updateValidators(validators);
    $rootscope.contribPlugins = this.taigaContribPlugins;
    $rootscope.adminPlugins = _.filter(this.taigaContribPlugins, {
      "type": "admin"
    });
    $rootscope.userSettingsPlugins = _.filter(this.taigaContribPlugins, {
      "type": "userSettings"
    });
    $rootscope.$on("$translateChangeEnd", function(e, ctx) {
      var lang, rtlLanguages;
      lang = ctx.language;
      i18nInit(lang, $translate);
      rtlLanguages = $tgConfig.get("rtlLanguages", []);
      return $rootscope.isRTL = rtlLanguages.indexOf(lang) > -1;
    });
    Promise.setScheduler(function(cb) {
      return $rootscope.$evalAsync(cb);
    });
    $events.setupConnection();
    if ($auth.isAuthenticated()) {
      user = $auth.getUser();
      $auth.showTerms();
    }
    $analytics.initialize();
    $tagManager.initialize();
    $userPilot.initialize();
    $userPilot.identify();
    $rootscope.$on('$locationChangeStart', function(event) {
      errorHandlingService.init();
      if (lightboxService.getLightboxOpen().length) {
        event.preventDefault();
        return lightboxService.closeAll();
      }
    });
    un = $rootscope.$on('$routeChangeStart', function(event, next) {
      if (next.loader) {
        loaderService.start(true);
      }
      return un();
    });
    return $rootscope.$on('$routeChangeSuccess', function(event, next) {
      var description, ref, title;
      if ((ref = projectService.project) != null ? ref.get('blocked_code') : void 0) {
        errorHandlingService.block();
      }
      if (next.loader) {
        loaderService.start(true);
      }
      if (next.access && next.access.requiresLogin) {
        if (!$auth.isAuthenticated()) {
          $location.path($navUrls.resolve("login"));
        }
      }
      if (next.title || next.description) {
        title = $translate.instant(next.title || "");
        description = $translate.instant(next.description || "");
        appMetaService.setAll(title, description);
      }
      if (next.mobileViewport) {
        appMetaService.addMobileViewport();
      } else {
        appMetaService.removeMobileViewport();
      }
      if (next.disableHeader) {
        return navigationBarService.disableHeader();
      } else {
        return navigationBarService.enableHeader();
      }
    });
  };

  angular.module('infinite-scroll').value('THROTTLE_MILLISECONDS', 500);

  pluginsWithModule = _.filter(this.taigaContribPlugins, function(plugin) {
    return plugin.module;
  });

  pluginsModules = _.map(pluginsWithModule, function(plugin) {
    return plugin.module;
  });

  modules = ["taigaBase", "taigaCommon", "taigaResources", "taigaResources2", "taigaAuth", "taigaEvents", "taigaHome", "taigaNavigationBar", "taigaProjects", "taigaRelatedTasks", "taigaBacklog", "taigaTaskboard", "taigaKanban", "taigaIssues", "taigaUserStories", "taigaTasks", "taigaTeam", "taigaWiki", "taigaSearch", "taigaAdmin", "taigaProject", "taigaUserSettings", "taigaFeedback", "taigaPlugins", "taigaIntegrations", "taigaComponents", "taigaProfile", "taigaHome", "taigaUserTimeline", "taigaExternalApps", "taigaDiscover", "taigaHistory", "taigaNotifications", "taigaWikiHistory", "taigaEpics", "taigaUtils", "templates", "ngSanitize", "ngRoute", "ngAnimate", "ngAria", "pascalprecht.translate", "infinite-scroll", "tgRepeat"].concat(pluginsModules);

  module = angular.module("taiga", modules);

  module.config(["$routeProvider", "$locationProvider", "$httpProvider", "$provide", "$tgEventsProvider", "$compileProvider", "$translateProvider", "$translatePartialLoaderProvider", "$animateProvider", configure]);

  module.run(["$log", "$rootScope", "$tgAuth", "$tgEvents", "$tgAnalytics", "$tgTagManager", "$tgUserPilot", "$translate", "$tgLocation", "$tgNavUrls", "tgAppMetaService", "tgLoader", "tgNavigationBarService", "tgErrorHandlingService", "lightboxService", "$tgConfig", "tgProjectService", init]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: classes.coffee
 */

(function() {
  var TaigaBase, TaigaController, TaigaService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  TaigaBase = (function() {
    function TaigaBase() {}

    return TaigaBase;

  })();

  TaigaService = (function(superClass) {
    extend(TaigaService, superClass);

    function TaigaService() {
      return TaigaService.__super__.constructor.apply(this, arguments);
    }

    return TaigaService;

  })(TaigaBase);

  TaigaController = (function(superClass) {
    extend(TaigaController, superClass);

    function TaigaController() {
      this.onInitialDataError = bind(this.onInitialDataError, this);
      return TaigaController.__super__.constructor.apply(this, arguments);
    }

    TaigaController.prototype.onInitialDataError = function(xhr) {
      if (xhr) {
        if (xhr.status === 404) {
          this.errorHandlingService.notfound();
        } else if (xhr.status === 403) {
          this.errorHandlingService.permissionDenied();
        }
      }
      return this.q.reject(xhr);
    };

    return TaigaController;

  })(TaigaBase);

  this.taiga.Base = TaigaBase;

  this.taiga.Service = TaigaService;

  this.taiga.Controller = TaigaController;

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: utils.coffee
 */

(function() {
  var DEFAULT_COLOR_LIST, addClass, bindMethods, bindOnce, cancelTimeout, debounce, debounceLeading, defineImmutableProperty, getDefaulColorList, getMatches, getRandomDefaultColor, groupBy, isEmail, isImage, isPdf, joinStr, mixOf, nl2br, normalizeString, patch, randomInt, replaceTags, scopeDefer, sizeFormat, slugify, startswith, stripTags, taiga, timeout, toString, toggleText, trim, truncate, unslugify,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  addClass = function(el, className) {
    if (el.classList) {
      return el.classList.add(className);
    } else {
      return el.className += ' ' + className;
    }
  };

  nl2br = (function(_this) {
    return function(str) {
      var breakTag;
      breakTag = '<br />';
      return (str + '').replace(/([^>\r\n]?)(\r\n|\n\r|\r|\n)/g, '$1' + breakTag + '$2');
    };
  })(this);

  bindMethods = (function(_this) {
    return function(object) {
      var dependencies, methods;
      dependencies = _.keys(object);
      methods = [];
      _.forIn(object, function(value, key) {
        if (indexOf.call(dependencies, key) < 0 && _.isFunction(value)) {
          return methods.push(key);
        }
      });
      return _.bindAll(object, methods);
    };
  })(this);

  bindOnce = (function(_this) {
    return function(scope, attr, continuation) {
      var delBind, val;
      val = scope.$eval(attr);
      if (val !== void 0) {
        return continuation(val);
      }
      delBind = null;
      return delBind = scope.$watch(attr, function(val) {
        if (val === void 0) {
          return;
        }
        continuation(val);
        if (delBind) {
          return delBind();
        }
      });
    };
  })(this);

  mixOf = function() {
    var Mixed, base, i, method, mixin, mixins, name, ref;
    base = arguments[0], mixins = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    Mixed = (function(superClass) {
      extend(Mixed, superClass);

      function Mixed() {
        return Mixed.__super__.constructor.apply(this, arguments);
      }

      return Mixed;

    })(base);
    for (i = mixins.length - 1; i >= 0; i += -1) {
      mixin = mixins[i];
      ref = mixin.prototype;
      for (name in ref) {
        method = ref[name];
        Mixed.prototype[name] = method;
      }
    }
    return Mixed;
  };

  trim = function(data, char) {
    return _.trim(data, char);
  };

  slugify = function(data) {
    return data.toString().toLowerCase().trim().replace(/\s+/g, '-').replace(/&/g, '-and-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-');
  };

  unslugify = function(data) {
    if (data) {
      return _.capitalize(data.replace(/-/g, ' '));
    }
    return data;
  };

  toggleText = function(element, texts) {
    var nextTextPosition, text;
    nextTextPosition = element.data('nextTextPosition');
    if ((nextTextPosition == null) || nextTextPosition >= texts.length) {
      nextTextPosition = 0;
    }
    text = texts[nextTextPosition];
    element.data('nextTextPosition', nextTextPosition + 1);
    return element.text(text);
  };

  groupBy = function(coll, pred) {
    var i, item, len, result;
    result = {};
    for (i = 0, len = coll.length; i < len; i++) {
      item = coll[i];
      result[pred(item)] = item;
    }
    return result;
  };

  timeout = function(wait, continuation) {
    return window.setTimeout(continuation, wait);
  };

  cancelTimeout = function(timeoutVar) {
    return window.clearTimeout(timeoutVar);
  };

  scopeDefer = function(scope, func) {
    return _.defer((function(_this) {
      return function() {
        return scope.$apply(func);
      };
    })(this));
  };

  toString = function(value) {
    if (_.isNumber(value)) {
      return value + "";
    } else if (_.isString(value)) {
      return value;
    } else if (_.isPlainObject(value)) {
      return JSON.stringify(value);
    } else if (_.isUndefined(value)) {
      return "";
    }
    return value.toString();
  };

  joinStr = function(str, coll) {
    return coll.join(str);
  };

  debounce = function(wait, func) {
    return _.debounce(func, wait, {
      leading: true,
      trailing: false
    });
  };

  debounceLeading = function(wait, func) {
    return _.debounce(func, wait, {
      leading: false,
      trailing: true
    });
  };

  startswith = function(str1, str2) {
    return _.startsWith(str1, str2);
  };

  truncate = function(str, maxLength, suffix) {
    var out;
    if (suffix == null) {
      suffix = "...";
    }
    if ((typeof str !== "string") && !(str instanceof String)) {
      return str;
    }
    out = str.slice(0);
    if (out.length > maxLength) {
      out = out.substring(0, maxLength + 1);
      out = out.substring(0, Math.min(out.length, out.lastIndexOf(" ")));
      out = out + suffix;
    }
    return out;
  };

  sizeFormat = function(input, precision) {
    var number, size, units;
    if (precision == null) {
      precision = 1;
    }
    if (isNaN(parseFloat(input)) || !isFinite(input)) {
      return "-";
    }
    if (input === 0) {
      return "0 bytes";
    }
    units = ["bytes", "KB", "MB", "GB", "TB", "PB"];
    number = Math.floor(Math.log(input) / Math.log(1024));
    if (number > 5) {
      number = 5;
    }
    size = (input / Math.pow(1024, number)).toFixed(precision);
    return size + " " + units[number];
  };

  stripTags = function(str, exception) {
    var pattern;
    if (exception) {
      pattern = new RegExp('<(?!' + exception + '\s*\/?)[^>]+>', 'gi');
      return String(str).replace(pattern, '');
    } else {
      return String(str).replace(/<\/?[^>]+>/g, '');
    }
  };

  replaceTags = function(str, tags, replace) {
    var pattern;
    pattern = new RegExp('<(' + tags + ')>', 'gi');
    str = str.replace(pattern, '<' + replace + '>');
    pattern = new RegExp('<\/(' + tags + ')>', 'gi');
    str = str.replace(pattern, '</' + replace + '>');
    return str;
  };

  defineImmutableProperty = (function(_this) {
    return function(obj, name, fn) {
      return Object.defineProperty(obj, name, {
        get: function() {
          var fn_result;
          if (!_.isFunction(fn)) {
            throw "defineImmutableProperty third param must be a function";
          }
          fn_result = fn();
          if (fn_result && _.isObject(fn_result)) {
            if (fn_result.size === void 0) {
              throw "defineImmutableProperty must return immutable data";
            }
          }
          return fn_result;
        }
      });
    };
  })(this);

  _.mixin({
    removeKeys: function(obj, keys) {
      return _.chain([keys]).flatten().reduce(function(obj, key) {
        delete obj[key];
        return obj;
      }, obj).value();
    },
    cartesianProduct: function() {
      return _.reduceRight(arguments, function(a, b) {
        return _.flatten(_.map(a, function(x) {
          return _.map(b, function(y) {
            return [y].concat(x);
          });
        }), true);
      }, [[]]);
    }
  });

  isImage = function(name) {
    return name.match(/\.(jpe?g|png|gif|gifv|webm|svg|psd)/i) !== null;
  };

  isEmail = function(name) {
    return (name != null) && name.match(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/) !== null;
  };

  isPdf = function(name) {
    return name.match(/\.(pdf)/i) !== null;
  };

  patch = function(oldImmutable, newImmutable) {
    var pathObj;
    pathObj = {};
    newImmutable.forEach(function(newValue, key) {
      if (newValue !== oldImmutable.get(key)) {
        if (newValue.toJS) {
          return pathObj[key] = newValue.toJS();
        } else {
          return pathObj[key] = newValue;
        }
      }
    });
    return pathObj;
  };

  DEFAULT_COLOR_LIST = ['#fce94f', '#edd400', '#c4a000', '#8ae234', '#73d216', '#4e9a06', '#d3d7cf', '#fcaf3e', '#f57900', '#ce5c00', '#729fcf', '#3465a4', '#204a87', '#888a85', '#ad7fa8', '#75507b', '#5c3566', '#ef2929', '#cc0000', '#a40000', '#222222'];

  getRandomDefaultColor = function() {
    return _.sample(DEFAULT_COLOR_LIST);
  };

  getDefaulColorList = function() {
    return _.clone(DEFAULT_COLOR_LIST);
  };

  getMatches = function(string, regex, index) {
    var match, matches;
    index || (index = 1);
    matches = [];
    match = null;
    while (match = regex.exec(string)) {
      if (index === -1) {
        matches.push(match);
      } else {
        matches.push(match[index]);
      }
    }
    return matches;
  };

  randomInt = function(start, end) {
    var interval;
    interval = end - start;
    return start + Math.floor(Math.random() * (interval + 1));
  };

  normalizeString = function(string) {
    var normalizedString;
    normalizedString = string;
    normalizedString = normalizedString.replace("Á", "A").replace("Ä", "A").replace("À", "A");
    normalizedString = normalizedString.replace("É", "E").replace("Ë", "E").replace("È", "E");
    normalizedString = normalizedString.replace("Í", "I").replace("Ï", "I").replace("Ì", "I");
    normalizedString = normalizedString.replace("Ó", "O").replace("Ö", "O").replace("Ò", "O");
    normalizedString = normalizedString.replace("Ú", "U").replace("Ü", "U").replace("Ù", "U");
    return normalizedString;
  };

  taiga = this.taiga;

  taiga.addClass = addClass;

  taiga.nl2br = nl2br;

  taiga.bindMethods = bindMethods;

  taiga.bindOnce = bindOnce;

  taiga.mixOf = mixOf;

  taiga.trim = trim;

  taiga.slugify = slugify;

  taiga.unslugify = unslugify;

  taiga.toggleText = toggleText;

  taiga.groupBy = groupBy;

  taiga.timeout = timeout;

  taiga.cancelTimeout = cancelTimeout;

  taiga.scopeDefer = scopeDefer;

  taiga.toString = toString;

  taiga.joinStr = joinStr;

  taiga.truncate = truncate;

  taiga.debounce = debounce;

  taiga.debounceLeading = debounceLeading;

  taiga.startswith = startswith;

  taiga.sizeFormat = sizeFormat;

  taiga.stripTags = stripTags;

  taiga.replaceTags = replaceTags;

  taiga.defineImmutableProperty = defineImmutableProperty;

  taiga.isImage = isImage;

  taiga.isEmail = isEmail;

  taiga.isPdf = isPdf;

  taiga.patch = patch;

  taiga.getRandomDefaultColor = getRandomDefaultColor;

  taiga.getDefaulColorList = getDefaulColorList;

  taiga.getMatches = getMatches;

  taiga.randomInt = randomInt;

  taiga.normalizeString = normalizeString;

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/controllerMixins.coffee
 */

(function() {
  var FiltersMixin, PageMixin, UsFiltersMixin, groupBy, joinStr, taiga, toString, trim;

  taiga = this.taiga;

  groupBy = this.taiga.groupBy;

  joinStr = this.taiga.joinStr;

  trim = this.taiga.trim;

  toString = this.taiga.toString;

  PageMixin = (function() {
    function PageMixin() {}

    PageMixin.prototype.fillUsersAndRoles = function(users, roles) {
      var activeUsers, computableRoles;
      activeUsers = _.filter(users, (function(_this) {
        return function(user) {
          return user.is_active;
        };
      })(this));
      this.scope.activeUsers = _.sortBy(activeUsers, "full_name_display");
      this.scope.activeUsersById = groupBy(this.scope.activeUsers, function(e) {
        return e.id;
      });
      this.scope.users = _.sortBy(users, "full_name_display");
      this.scope.usersById = groupBy(users, function(e) {
        return e.id;
      });
      this.scope.roles = _.sortBy(roles, "order");
      computableRoles = _(this.scope.project.members).map("role").uniq().value();
      return this.scope.computableRoles = _(roles).filter("computable").filter(function(x) {
        return _.includes(computableRoles, x.id);
      }).value();
    };

    PageMixin.prototype.loadUsersAndRoles = function() {
      var promise;
      promise = this.q.all([this.rs.projects.usersList(this.scope.projectId), this.rs.projects.rolesList(this.scope.projectId)]);
      return promise.then((function(_this) {
        return function(results) {
          var roles, users;
          users = results[0], roles = results[1];
          _this.fillUsersAndRoles(users, roles);
          return results;
        };
      })(this));
    };

    return PageMixin;

  })();

  taiga.PageMixin = PageMixin;

  FiltersMixin = (function() {
    function FiltersMixin() {}

    FiltersMixin.prototype.excludePrefix = "exclude_";

    FiltersMixin.prototype.selectFilter = function(name, value, load, mode) {
      var existing, location, params;
      if (load == null) {
        load = false;
      }
      if (mode == null) {
        mode = "include";
      }
      params = this.location.search();
      if (mode === "exclude") {
        name = this.excludePrefix.concat(name);
      }
      if (params[name] !== void 0 && name !== "page") {
        existing = _.map(taiga.toString(params[name]).split(","), function(x) {
          return trim(x);
        });
        existing.push(taiga.toString(value));
        existing = _.compact(existing);
        value = joinStr(",", _.uniq(existing));
      }
      if (!this.location.isInCurrentRouteParams(name, value)) {
        location = load ? this.location : this.location.noreload(this.scope);
        return location.search(name, value);
      }
    };

    FiltersMixin.prototype.replaceFilter = function(name, value, load) {
      var location;
      if (load == null) {
        load = false;
      }
      if (!this.location.isInCurrentRouteParams(name, value)) {
        location = load ? this.location : this.location.noreload(this.scope);
        return location.search(name, value);
      }
    };

    FiltersMixin.prototype.replaceAllFilters = function(filters, load) {
      var location;
      if (load == null) {
        load = false;
      }
      location = load ? this.location : this.location.noreload(this.scope);
      return location.search(filters);
    };

    FiltersMixin.prototype.unselectFilter = function(name, value, load, mode) {
      var location, newValues, params, parsedValues;
      if (load == null) {
        load = false;
      }
      if (mode == null) {
        mode = 'include';
      }
      params = this.location.search();
      if (mode === "exclude") {
        name = this.excludePrefix.concat(name);
      }
      if (params[name] === void 0) {
        return;
      }
      if (value === void 0 || value === null) {
        delete params[name];
      }
      parsedValues = _.map(taiga.toString(params[name]).split(","), function(x) {
        return trim(x);
      });
      newValues = _.reject(parsedValues, function(x) {
        return x === taiga.toString(value);
      });
      newValues = _.compact(newValues);
      if (_.isEmpty(newValues)) {
        value = null;
      } else {
        value = joinStr(",", _.uniq(newValues));
      }
      location = load ? this.location : this.location.noreload(this.scope);
      return location.search(name, value);
    };

    FiltersMixin.prototype.applyStoredFilters = function(projectSlug, key) {
      var filters;
      if (_.isEmpty(this.location.search())) {
        filters = this.getFilters(projectSlug, key);
        if (Object.keys(filters).length) {
          this.location.search(filters);
          this.location.replace();
          return true;
        }
      }
      return false;
    };

    FiltersMixin.prototype.storeFilters = function(projectSlug, params, filtersHashSuffix) {
      var hash, ns;
      ns = projectSlug + ":" + filtersHashSuffix;
      hash = taiga.generateHash([projectSlug, ns]);
      return this.storage.set(hash, params);
    };

    FiltersMixin.prototype.getFilters = function(projectSlug, filtersHashSuffix) {
      var hash, ns;
      ns = projectSlug + ":" + filtersHashSuffix;
      hash = taiga.generateHash([projectSlug, ns]);
      return this.storage.get(hash) || {};
    };

    FiltersMixin.prototype.formatSelectedFilters = function(type, list, urlIds, mode) {
      var invalidAppliedTags, invalidTags, selectedFilters, selectedIds, validAppliedTags;
      if (mode == null) {
        mode = "include";
      }
      selectedIds = urlIds.split(',');
      selectedFilters = _.filter(list, function(it) {
        return selectedIds.indexOf(_.toString(it.id)) !== -1;
      });
      invalidTags = _.filter(selectedIds, function(it) {
        return !_.find(selectedFilters, function(sit) {
          return _.toString(sit.id) === it;
        });
      });
      invalidAppliedTags = _.map(invalidTags, function(it) {
        return {
          id: it,
          key: type + ":" + it,
          dataType: type,
          name: it,
          mode: mode
        };
      });
      validAppliedTags = _.map(selectedFilters, function(it) {
        return {
          id: it.id,
          key: type + ":" + it.id,
          dataType: type,
          name: it.name,
          color: it.color,
          mode: mode
        };
      });
      return invalidAppliedTags.concat(validAppliedTags);
    };

    return FiltersMixin;

  })();

  taiga.FiltersMixin = FiltersMixin;

  UsFiltersMixin = (function() {
    function UsFiltersMixin() {}

    UsFiltersMixin.prototype.excludePrefix = "exclude_";

    UsFiltersMixin.prototype.filterCategories = ["tags", "status", "assigned_users", "assigned_to", "owner", "epic", "role"];

    UsFiltersMixin.prototype.changeQ = function(q) {
      this.replaceFilter("q", q);
      this.filtersReloadContent();
      return this.generateFilters();
    };

    UsFiltersMixin.prototype.removeFilter = function(filter) {
      this.unselectFilter(filter.dataType, filter.id, false, filter.mode);
      this.filtersReloadContent();
      return this.generateFilters();
    };

    UsFiltersMixin.prototype.addFilter = function(newFilter) {
      this.selectFilter(newFilter.category.dataType, newFilter.filter.id, false, newFilter.mode);
      this.filtersReloadContent();
      return this.generateFilters();
    };

    UsFiltersMixin.prototype.selectCustomFilter = function(customFilter) {
      this.replaceAllFilters(customFilter.filter);
      this.filtersReloadContent();
      return this.generateFilters();
    };

    UsFiltersMixin.prototype.saveCustomFilter = function(name) {
      var excludeKey, filters, i, key, len, ref, urlfilters;
      filters = {};
      urlfilters = this.location.search();
      ref = this.filterCategories;
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        excludeKey = this.excludePrefix.concat(key);
        filters[key] = urlfilters[key];
        filters[excludeKey] = urlfilters[excludeKey];
      }
      return this.filterRemoteStorageService.getFilters(this.scope.projectId, this.storeCustomFiltersName).then((function(_this) {
        return function(userFilters) {
          userFilters[name] = filters;
          return _this.filterRemoteStorageService.storeFilters(_this.scope.projectId, userFilters, _this.storeCustomFiltersName).then(_this.generateFilters);
        };
      })(this));
    };

    UsFiltersMixin.prototype.removeCustomFilter = function(customFilter) {
      return this.filterRemoteStorageService.getFilters(this.scope.projectId, this.storeCustomFiltersName).then((function(_this) {
        return function(userFilters) {
          delete userFilters[customFilter.id];
          _this.filterRemoteStorageService.storeFilters(_this.scope.projectId, userFilters, _this.storeCustomFiltersName).then(_this.generateFilters);
          return _this.generateFilters();
        };
      })(this));
    };

    UsFiltersMixin.prototype.isFilterDataTypeSelected = function(filterDataType) {
      var filter, i, len, ref;
      ref = this.selectedFilters;
      for (i = 0, len = ref.length; i < len; i++) {
        filter = ref[i];
        if (filter['dataType'] === filterDataType) {
          return true;
        }
      }
      return false;
    };

    UsFiltersMixin.prototype.generateFilters = function(milestone) {
      var excludeKey, i, key, len, loadFilters, ref, urlfilters;
      this.storeFilters(this.params.pslug, this.location.search(), this.storeFiltersName);
      urlfilters = this.location.search();
      loadFilters = {};
      loadFilters.project = this.scope.projectId;
      loadFilters.q = urlfilters.q;
      ref = this.filterCategories;
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        excludeKey = this.excludePrefix.concat(key);
        loadFilters[key] = urlfilters[key];
        loadFilters[excludeKey] = urlfilters[excludeKey];
      }
      if (milestone) {
        loadFilters.milestone = milestone;
      }
      return this.q.all([this.rs.userstories.filtersData(loadFilters), this.filterRemoteStorageService.getFilters(this.scope.projectId, this.storeCustomFiltersName)]).then((function(_this) {
        return function(result) {
          var customFiltersRaw, data, dataCollection, j, len1, ref1, selected, tagsWithAtLeastOneElement;
          data = result[0];
          customFiltersRaw = result[1];
          dataCollection = {};
          dataCollection.status = _.map(data.statuses, function(it) {
            it.id = it.id.toString();
            return it;
          });
          dataCollection.tags = _.map(data.tags, function(it) {
            it.id = it.name;
            return it;
          });
          tagsWithAtLeastOneElement = _.filter(dataCollection.tags, function(tag) {
            return tag.count > 0;
          });
          dataCollection.assigned_users = _.map(data.assigned_users, function(it) {
            if (it.id) {
              it.id = it.id.toString();
            } else {
              it.id = "null";
            }
            it.name = it.full_name || "Unassigned";
            return it;
          });
          dataCollection.assigned_to = _.map(data.assigned_to, function(it) {
            if (it.id) {
              it.id = it.id.toString();
            } else {
              it.id = "null";
            }
            it.name = it.full_name || "Unassigned";
            return it;
          });
          dataCollection.role = _.map(data.roles, function(it) {
            if (it.id) {
              it.id = it.id.toString();
            } else {
              it.id = "null";
            }
            it.name = it.name || "Unassigned";
            return it;
          });
          dataCollection.owner = _.map(data.owners, function(it) {
            it.id = it.id.toString();
            it.name = it.full_name;
            return it;
          });
          dataCollection.epic = _.map(data.epics, function(it) {
            if (it.id) {
              it.id = it.id.toString();
              it.name = "#" + it.ref + " " + it.subject;
            } else {
              it.id = "null";
              it.name = "Not in an epic";
            }
            return it;
          });
          _this.selectedFilters = [];
          ref1 = _this.filterCategories;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            key = ref1[j];
            excludeKey = _this.excludePrefix.concat(key);
            if (loadFilters[key]) {
              selected = _this.formatSelectedFilters(key, dataCollection[key], loadFilters[key]);
              _this.selectedFilters = _this.selectedFilters.concat(selected);
            }
            if (loadFilters[excludeKey]) {
              selected = _this.formatSelectedFilters(key, dataCollection[key], loadFilters[excludeKey], "exclude");
              _this.selectedFilters = _this.selectedFilters.concat(selected);
            }
          }
          _this.filterQ = loadFilters.q;
          _this.filters = [
            {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.STATUS"),
              dataType: "status",
              content: dataCollection.status
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.TAGS"),
              dataType: "tags",
              content: dataCollection.tags,
              hideEmpty: true,
              totalTaggedElements: tagsWithAtLeastOneElement.length
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.ASSIGNED_USERS"),
              dataType: "assigned_users",
              content: dataCollection.assigned_users
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.ROLE"),
              dataType: "role",
              content: dataCollection.role
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.CREATED_BY"),
              dataType: "owner",
              content: dataCollection.owner
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.EPIC"),
              dataType: "epic",
              content: dataCollection.epic
            }
          ];
          _this.customFilters = [];
          return _.forOwn(customFiltersRaw, function(value, key) {
            return _this.customFilters.push({
              id: key,
              name: key,
              filter: value
            });
          });
        };
      })(this));
    };

    return UsFiltersMixin;

  })();

  taiga.UsFiltersMixin = UsFiltersMixin;

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/admin.coffee
 */

(function() {
  var module;

  module = angular.module("taigaAdmin", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/auth.coffee
 */

(function() {
  var AuthService, CancelAccountDirective, ChangeEmailDirective, ChangePasswordFromRecoveryDirective, ForgotPasswordDirective, InvitationDirective, LoginDirective, LoginPage, PublicRegisterMessageDirective, RegisterDirective, RegisterOptionsDirective, debounce, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  debounce = this.taiga.debounce;

  module = angular.module("taigaAuth", ["taigaResources"]);

  LoginPage = (function() {
    LoginPage.$inject = ['tgCurrentUserService', '$location', '$tgNavUrls', '$routeParams', '$tgAuth'];

    function LoginPage(currentUserService, $location, $navUrls, $routeParams, $auth) {
      var url;
      if (currentUserService.isAuthenticated()) {
        if (!$routeParams['force_login']) {
          url = $navUrls.resolve("home");
          if ($routeParams['next']) {
            url = decodeURIComponent($routeParams['next']);
            $location.search('next', null);
          }
          if ($routeParams['unauthorized']) {
            $auth.clear();
            $auth.removeToken();
          } else {
            $location.url(url);
          }
        }
      }
    }

    return LoginPage;

  })();

  module.controller('LoginPage', LoginPage);

  AuthService = (function(superClass) {
    extend(AuthService, superClass);

    AuthService.$inject = ["$rootScope", "$tgStorage", "$tgModel", "$tgResources", "$tgHttp", "$tgUrls", "$tgConfig", "$tgUserPilot", "$translate", "tgCurrentUserService", "tgThemeService", "$tgAnalytics", "tgTermsAnnouncementService"];

    function AuthService(rootscope, storage, model, rs, http, urls, config1, userpilot, translate, currentUserService1, themeService, analytics, termsAnnouncementService) {
      var userModel;
      this.rootscope = rootscope;
      this.storage = storage;
      this.model = model;
      this.rs = rs;
      this.http = http;
      this.urls = urls;
      this.config = config1;
      this.userpilot = userpilot;
      this.translate = translate;
      this.currentUserService = currentUserService1;
      this.themeService = themeService;
      this.analytics = analytics;
      this.termsAnnouncementService = termsAnnouncementService;
      AuthService.__super__.constructor.call(this);
      userModel = this.getUser();
      this._currentTheme = this._getUserTheme();
      this.setUserdata(userModel);
    }

    AuthService.prototype.setUserdata = function(userModel) {
      if (userModel) {
        this.userData = Immutable.fromJS(userModel.getAttrs());
        this.currentUserService.setUser(this.userData);
      } else {
        this.userData = null;
      }
      return this.analytics.setUserId();
    };

    AuthService.prototype._getUserTheme = function() {
      var defaultTheme, ref, ref1;
      defaultTheme = this.config.get("defaultTheme") || "taiga";
      if (!_.includes(this.config.get("themes"), (ref = this.rootscope.user) != null ? ref.theme : void 0)) {
        return defaultTheme;
      }
      return (ref1 = this.rootscope.user) != null ? ref1.theme : void 0;
    };

    AuthService.prototype._setTheme = function() {
      var newTheme;
      newTheme = this._getUserTheme();
      if (this._currentTheme !== newTheme) {
        this._currentTheme = newTheme;
        return this.themeService.use(this._currentTheme);
      }
    };

    AuthService.prototype._setLocales = function() {
      var lang, ref;
      lang = ((ref = this.rootscope.user) != null ? ref.lang : void 0) || this.config.get("defaultLanguage") || "en";
      this.translate.preferredLanguage(lang);
      return this.translate.use(lang);
    };

    AuthService.prototype.getUser = function() {
      var user, userData;
      if (this.rootscope.user) {
        return this.rootscope.user;
      }
      userData = this.storage.get("userInfo");
      if (userData) {
        user = this.model.make_model("users", userData);
        this.rootscope.user = user;
        this._setLocales();
        this._setTheme();
        return user;
      } else {
        this._setTheme();
      }
      return null;
    };

    AuthService.prototype.setUser = function(user) {
      this.rootscope.auth = user;
      this.storage.set("userInfo", user.getAttrs());
      this.rootscope.user = user;
      this.setUserdata(user);
      this._setLocales();
      return this._setTheme();
    };

    AuthService.prototype.clear = function() {
      this.rootscope.auth = null;
      this.rootscope.user = null;
      return this.storage.remove("userInfo");
    };

    AuthService.prototype.setToken = function(token) {
      return this.storage.set("token", token);
    };

    AuthService.prototype.getToken = function() {
      return this.storage.get("token");
    };

    AuthService.prototype.removeToken = function() {
      return this.storage.remove("token");
    };

    AuthService.prototype.isAuthenticated = function() {
      if (this.getUser() !== null) {
        return true;
      }
      return false;
    };

    AuthService.prototype.refresh = function() {
      var url;
      url = this.urls.resolve("user-me");
      return this.http.get(url).then((function(_this) {
        return function(data, status) {
          var user;
          user = data.data;
          user.token = _this.getUser().auth_token;
          user = _this.model.make_model("users", user);
          _this.setUser(user);
          _this.rootscope.$broadcast("auth:refresh", user);
          return user;
        };
      })(this));
    };

    AuthService.prototype.login = function(data, type) {
      var url;
      url = this.urls.resolve("auth");
      data = _.clone(data, false);
      data.type = type ? type : "normal";
      this.removeToken();
      return this.http.post(url, data).then((function(_this) {
        return function(data, status) {
          var user;
          user = _this.model.make_model("users", data.data);
          _this.setToken(user.auth_token);
          _this.setUser(user);
          _this.userpilot.identify(true);
          _this.rootscope.$broadcast("auth:login", user);
          return user;
        };
      })(this));
    };

    AuthService.prototype.logout = function() {
      this.removeToken();
      this.clear();
      this.currentUserService.removeUser();
      this._setTheme();
      this._setLocales();
      this.rootscope.$broadcast("auth:logout");
      return this.analytics.setUserId();
    };

    AuthService.prototype.register = function(data, type, existing) {
      var url;
      url = this.urls.resolve("auth-register");
      data = _.clone(data, false);
      data.type = type ? type : "public";
      if (type === "private") {
        data.existing = existing ? existing : false;
      }
      this.removeToken();
      return this.http.post(url, data).then((function(_this) {
        return function(response) {
          var user;
          user = _this.model.make_model("users", response.data);
          _this.setToken(user.auth_token);
          _this.setUser(user);
          _this.rootscope.$broadcast("auth:register", user);
          return user;
        };
      })(this));
    };

    AuthService.prototype.getInvitation = function(token) {
      return this.rs.invitations.get(token);
    };

    AuthService.prototype.acceptInvitiationWithNewUser = function(data) {
      return this.register(data, "private", false);
    };

    AuthService.prototype.forgotPassword = function(data) {
      var url;
      url = this.urls.resolve("users-password-recovery");
      data = _.clone(data, false);
      this.removeToken();
      return this.http.post(url, data);
    };

    AuthService.prototype.changePasswordFromRecovery = function(data) {
      var url;
      url = this.urls.resolve("users-change-password-from-recovery");
      data = _.clone(data, false);
      this.removeToken();
      return this.http.post(url, data);
    };

    AuthService.prototype.changeEmail = function(data) {
      var url;
      url = this.urls.resolve("users-change-email");
      data = _.clone(data, false);
      return this.http.post(url, data);
    };

    AuthService.prototype.cancelAccount = function(data) {
      var url;
      url = this.urls.resolve("users-cancel-account");
      data = _.clone(data, false);
      return this.http.post(url, data);
    };

    AuthService.prototype.exportProfile = function() {
      var url;
      url = this.urls.resolve("users-export");
      return this.http.post(url);
    };

    AuthService.prototype.showTerms = function(data) {
      var user;
      user = this.getUser();
      if (!user || user.read_new_terms) {
        return;
      }
      return this.termsAnnouncementService.show();
    };

    AuthService.prototype.sendVerificationEmail = function() {
      var url;
      url = this.urls.resolve("user-send-verification-email");
      return this.http.post(url);
    };

    return AuthService;

  })(taiga.Service);

  module.service("$tgAuth", AuthService);

  PublicRegisterMessageDirective = function($config, $navUrls, $routeParams, templates) {
    var template, templateFn;
    template = templates.get("auth/login-text.html", true);
    templateFn = function() {
      var nextUrl, publicRegisterEnabled, url;
      publicRegisterEnabled = $config.get("publicRegisterEnabled");
      if (!publicRegisterEnabled) {
        return "";
      }
      url = $navUrls.resolve("register");
      if ($routeParams['force_next']) {
        nextUrl = encodeURIComponent($routeParams['force_next']);
        url += "?next=" + nextUrl;
      }
      return template({
        url: url
      });
    };
    return {
      restrict: "AE",
      scope: {},
      template: templateFn
    };
  };

  module.directive("tgPublicRegisterMessage", ["$tgConfig", "$tgNavUrls", "$routeParams", "$tgTemplate", PublicRegisterMessageDirective]);

  LoginDirective = function($auth, $confirm, $location, $config, $routeParams, $navUrls, $events, $translate, $window, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, onError, onSuccess, submit;
      form = new checksley.Form($el.find("form.login-form"));
      $scope.defaultLoginEnabled = $config.get("defaultLoginEnabled", true);
      if ($routeParams['next'] && $routeParams['next'] !== $navUrls.resolve("login")) {
        $scope.nextUrl = decodeURIComponent($routeParams['next']);
      } else {
        $scope.nextUrl = $navUrls.resolve("home");
      }
      if ($routeParams['force_next']) {
        $scope.nextUrl = decodeURIComponent($routeParams['force_next']);
      }
      onSuccess = function(response) {
        $events.setupConnection();
        $analytics.trackEvent("auth", "login", "user login", 1);
        $auth.showTerms();
        if ($scope.nextUrl.indexOf('http') === 0) {
          return $window.location.href = $scope.nextUrl;
        } else {
          return $location.url($scope.nextUrl);
        }
      };
      onError = function(response) {
        return $confirm.notify("light-error", $translate.instant("LOGIN_FORM.ERROR_AUTH_INCORRECT"));
      };
      $scope.onKeyUp = function(event) {
        var target, value;
        target = angular.element(event.currentTarget);
        value = target.val();
        $scope.iscapsLockActivated = false;
        if (value !== value.toLowerCase()) {
          return $scope.iscapsLockActivated = true;
        }
      };
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var data, loginFormType, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          data = {
            "username": $el.find("form.login-form input[name=username]").val(),
            "password": $el.find("form.login-form input[name=password]").val()
          };
          loginFormType = $config.get("loginFormType", "normal");
          promise = $auth.login(data, loginFormType);
          return promise.then(onSuccess, onError);
        };
      })(this));
      $el.on("submit", "form", submit);
      window.prerenderReady = true;
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgLogin", ["$tgAuth", "$tgConfirm", "$tgLocation", "$tgConfig", "$routeParams", "$tgNavUrls", "$tgEvents", "$translate", "$window", "$tgAnalytics", LoginDirective]);

  RegisterDirective = function($auth, $confirm, $location, $navUrls, $config, $routeParams, $analytics, $translate, $window) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, onErrorSubmit, onSuccessSubmit, submit;
      if (!$config.get("publicRegisterEnabled")) {
        $location.path($navUrls.resolve("not-found"));
        $location.replace();
      }
      $scope.data = {};
      form = $el.find("form").checksley({
        onlyOneErrorElement: true
      });
      if ($routeParams['next'] && $routeParams['next'] !== $navUrls.resolve("login")) {
        $scope.nextUrl = decodeURIComponent($routeParams['next']);
      } else {
        $scope.nextUrl = $navUrls.resolve("home");
      }
      onSuccessSubmit = function(response) {
        $analytics.trackEvent("auth", "register", "user registration", 1);
        if ($scope.nextUrl.indexOf('http') === 0) {
          return $window.location.href = $scope.nextUrl;
        } else {
          return $location.url($scope.nextUrl);
        }
      };
      onErrorSubmit = function(response) {
        var text;
        if (response.data._error_message) {
          text = $translate.instant("COMMON.GENERIC_ERROR", {
            error: response.data._error_message
          });
          $confirm.notify("light-error", text);
        }
        return form.setErrors(response.data);
      };
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          promise = $auth.register($scope.data);
          return promise.then(onSuccessSubmit, onErrorSubmit);
        };
      })(this));
      $el.on("submit", "form", submit);
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return window.prerenderReady = true;
    };
    return {
      link: link
    };
  };

  module.directive("tgRegister", ["$tgAuth", "$tgConfirm", "$tgLocation", "$tgNavUrls", "$tgConfig", "$routeParams", "$tgAnalytics", "$translate", "$window", RegisterDirective]);

  RegisterOptionsDirective = function() {
    return {};
  };

  module.directive("tgRegisterOptions", [RegisterOptionsDirective]);

  ForgotPasswordDirective = function($auth, $confirm, $location, $navUrls, $translate) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, onErrorSubmit, onSuccessSubmit, submit;
      $scope.data = {};
      form = $el.find("form").checksley();
      onSuccessSubmit = function(response) {
        var message, title;
        $location.path($navUrls.resolve("login"));
        title = $translate.instant("FORGOT_PASSWORD_FORM.SUCCESS_TITLE");
        message = $translate.instant("FORGOT_PASSWORD_FORM.SUCCESS_TEXT");
        return $confirm.success(title, message);
      };
      onErrorSubmit = function(response) {
        var text;
        text = $translate.instant("FORGOT_PASSWORD_FORM.ERROR");
        return $confirm.notify("light-error", text);
      };
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          promise = $auth.forgotPassword($scope.data);
          return promise.then(onSuccessSubmit, onErrorSubmit);
        };
      })(this));
      $el.on("submit", "form", submit);
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return window.prerenderReady = true;
    };
    return {
      link: link
    };
  };

  module.directive("tgForgotPassword", ["$tgAuth", "$tgConfirm", "$tgLocation", "$tgNavUrls", "$translate", ForgotPasswordDirective]);

  ChangePasswordFromRecoveryDirective = function($auth, $confirm, $location, $params, $navUrls, $translate) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, onErrorSubmit, onSuccessSubmit, submit, text;
      $scope.data = {};
      if ($params.token != null) {
        $scope.tokenInParams = true;
        $scope.data.token = $params.token;
      } else {
        $location.path($navUrls.resolve("login"));
        text = $translate.instant("CHANGE_PASSWORD_RECOVERY_FORM.ERROR");
        $confirm.notify("light-error", text);
      }
      form = $el.find("form").checksley();
      onSuccessSubmit = function(response) {
        $location.path($navUrls.resolve("login"));
        text = $translate.instant("CHANGE_PASSWORD_RECOVERY_FORM.SUCCESS");
        return $confirm.success(text);
      };
      onErrorSubmit = function(response) {
        text = $translate.instant("CHANGE_PASSWORD_RECOVERY_FORM.ERROR");
        return $confirm.notify("light-error", text);
      };
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          promise = $auth.changePasswordFromRecovery($scope.data);
          return promise.then(onSuccessSubmit, onErrorSubmit);
        };
      })(this));
      $el.on("submit", "form", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgChangePasswordFromRecovery", ["$tgAuth", "$tgConfirm", "$tgLocation", "$routeParams", "$tgNavUrls", "$translate", ChangePasswordFromRecoveryDirective]);

  InvitationDirective = function($auth, $confirm, $location, $config, $params, $navUrls, $analytics, $translate, config) {
    var link;
    link = function($scope, $el, $attrs) {
      var loginForm, onErrorSubmitLogin, onErrorSubmitRegister, onSuccessSubmitLogin, onSuccessSubmitRegister, promise, registerForm, submitLogin, submitRegister, token;
      token = $params.token;
      promise = $auth.getInvitation(token);
      promise.then(function(invitation) {
        $scope.invitation = invitation;
        return $scope.publicRegisterEnabled = config.get("publicRegisterEnabled");
      });
      promise.then(null, function(response) {
        var text;
        $location.path($navUrls.resolve("login"));
        text = $translate.instant("INVITATION_LOGIN_FORM.NOT_FOUND");
        return $confirm.notify("light-error", text);
      });
      $scope.dataLogin = {
        token: token
      };
      loginForm = $el.find("form.login-form").checksley({
        onlyOneErrorElement: true
      });
      onSuccessSubmitLogin = function(response) {
        var text;
        $analytics.trackEvent("auth", "invitationAccept", "invitation accept with existing user", 1);
        $location.path($navUrls.resolve("project", {
          project: $scope.invitation.project_slug
        }));
        text = $translate.instant("INVITATION_LOGIN_FORM.SUCCESS", {
          "project_name": $scope.invitation.project_name
        });
        return $confirm.notify("success", text);
      };
      onErrorSubmitLogin = function(response) {
        return $confirm.notify("light-error", response.data._error_message);
      };
      submitLogin = debounce(2000, (function(_this) {
        return function(event) {
          var data, loginFormType;
          event.preventDefault();
          if (!loginForm.validate()) {
            return;
          }
          loginFormType = $config.get("loginFormType", "normal");
          data = $scope.dataLogin;
          promise = $auth.login({
            username: data.username,
            password: data.password,
            invitation_token: data.token
          }, loginFormType);
          return promise.then(onSuccessSubmitLogin, onErrorSubmitLogin);
        };
      })(this));
      $el.on("submit", "form.login-form", submitLogin);
      $el.on("click", ".button-login", submitLogin);
      $scope.dataRegister = {
        token: token
      };
      registerForm = $el.find("form.register-form").checksley({
        onlyOneErrorElement: true
      });
      onSuccessSubmitRegister = function(response) {
        var text;
        $analytics.trackEvent("auth", "invitationAccept", "invitation accept with new user", 1);
        $location.path($navUrls.resolve("project", {
          project: $scope.invitation.project_slug
        }));
        text = $translate.instant("INVITATION_LOGIN_FORM.SUCCESS", {
          "project_name": $scope.invitation.project_name
        });
        return $confirm.notify("success", text);
      };
      onErrorSubmitRegister = function(response) {
        var text;
        if (response.data._error_message) {
          text = $translate.instant("COMMON.GENERIC_ERROR", {
            error: response.data._error_message
          });
          $confirm.notify("light-error", text);
        }
        return registerForm.setErrors(response.data);
      };
      submitRegister = debounce(2000, (function(_this) {
        return function(event) {
          event.preventDefault();
          if (!registerForm.validate()) {
            return;
          }
          promise = $auth.acceptInvitiationWithNewUser($scope.dataRegister);
          return promise.then(onSuccessSubmitRegister, onErrorSubmitRegister);
        };
      })(this));
      $el.on("submit", "form.register-form", submitRegister);
      $el.on("click", ".button-register", submitRegister);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgInvitation", ["$tgAuth", "$tgConfirm", "$tgLocation", "$tgConfig", "$routeParams", "$tgNavUrls", "$tgAnalytics", "$translate", "$tgConfig", InvitationDirective]);

  ChangeEmailDirective = function($repo, $model, $auth, $confirm, $location, $params, $navUrls, $translate) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, onErrorSubmit, onSuccessSubmit, submit;
      $scope.data = {};
      $scope.data.email_token = $params.email_token;
      form = $el.find("form").checksley();
      onSuccessSubmit = function(response) {
        var text;
        if ($auth.isAuthenticated()) {
          $repo.queryOne("users", $auth.getUser().id).then((function(_this) {
            return function(data) {
              return $auth.setUser(data);
            };
          })(this));
          $location.url($navUrls.resolve("home"));
        } else {
          $location.url($navUrls.resolve("login"));
        }
        text = $translate.instant("CHANGE_EMAIL_FORM.SUCCESS");
        return $confirm.success(text);
      };
      onErrorSubmit = function(response) {
        var text;
        text = $translate.instant("COMMON.GENERIC_ERROR", {
          error: response.data._error_message
        });
        return $confirm.notify("light-error", text);
      };
      submit = function() {
        var promise;
        if (!form.validate()) {
          return;
        }
        promise = $auth.changeEmail($scope.data);
        return promise.then(onSuccessSubmit, onErrorSubmit);
      };
      $el.on("submit", function(event) {
        event.preventDefault();
        return submit();
      });
      $el.on("click", "a.button-change-email", function(event) {
        event.preventDefault();
        return submit();
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgChangeEmail", ["$tgRepo", "$tgModel", "$tgAuth", "$tgConfirm", "$tgLocation", "$routeParams", "$tgNavUrls", "$translate", ChangeEmailDirective]);

  CancelAccountDirective = function($repo, $model, $auth, $confirm, $location, $params, $navUrls) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, onErrorSubmit, onSuccessSubmit, submit;
      $scope.data = {};
      $scope.data.cancel_token = $params.cancel_token;
      form = $el.find("form").checksley();
      onSuccessSubmit = function(response) {
        var text;
        $auth.logout();
        $location.path($navUrls.resolve("home"));
        text = $translate.instant("CANCEL_ACCOUNT.SUCCESS");
        return $confirm.success(text);
      };
      onErrorSubmit = function(response) {
        var text;
        text = $translate.instant("COMMON.GENERIC_ERROR", {
          error: response.data._error_message
        });
        return $confirm.notify("error", text);
      };
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          promise = $auth.cancelAccount($scope.data);
          return promise.then(onSuccessSubmit, onErrorSubmit);
        };
      })(this));
      $el.on("submit", "form", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgCancelAccount", ["$tgRepo", "$tgModel", "$tgAuth", "$tgConfirm", "$tgLocation", "$routeParams", "$tgNavUrls", CancelAccountDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/backlog.coffee
 */

(function() {
  var module;

  module = angular.module("taigaBacklog", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base.coffee
 */

(function() {
  var TaigaMainDirective, bindOnce, groupBy, init, module, taiga, urls;

  taiga = this.taiga;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaBase", []);

  TaigaMainDirective = function($rootscope, $window) {
    var link;
    link = function($scope, $el, $attrs) {
      return $window.onresize = function() {
        return $rootscope.$broadcast("resize");
      };
    };
    return {
      link: link
    };
  };

  module.directive("tgMain", ["$rootScope", "$window", TaigaMainDirective]);

  urls = {
    "home": "/",
    "projects": "/projects",
    "error": "/error",
    "not-found": "/not-found",
    "permission-denied": "/permission-denied",
    "discover": "/discover",
    "discover-search": "/discover/search",
    "login": "/login",
    "forgot-password": "/forgot-password",
    "change-password": "/change-password/:token",
    "change-email": "/change-email/:token",
    "verified-email": "/change-email/:token",
    "cancel-account": "/cancel-account/:token",
    "register": "/register",
    "invitation": "/invitation/:token",
    "create-project": "/project/new",
    "create-project-scrum": "/project/new/scrum",
    "create-project-kanban": "/project/new/kanban",
    "create-project-duplicate": "/project/new/duplicate",
    "create-project-import": "/project/new/import",
    "create-project-import-platform": "/project/new/import/:platform",
    "profile": "/profile",
    "user-profile": "/profile/:username",
    "blocked-project": "/blocked-project/:project",
    "project": "/project/:project",
    "project-detail-ref": "/project/:project/t/:ref",
    "project-backlog": "/project/:project/backlog",
    "project-taskboard": "/project/:project/taskboard/:sprint",
    "project-kanban": "/project/:project/kanban",
    "project-issues": "/project/:project/issues",
    "project-epics": "/project/:project/epics",
    "project-search": "/project/:project/search",
    "project-timeline": "/project/:project/timeline",
    "project-epics-detail": "/project/:project/epic/:ref",
    "project-userstories-detail": "/project/:project/us/:ref",
    "project-tasks-detail": "/project/:project/task/:ref",
    "project-issues-detail": "/project/:project/issue/:ref",
    "project-wiki": "/project/:project/wiki",
    "project-wiki-list": "/project/:project/wiki-list",
    "project-wiki-page": "/project/:project/wiki/:slug",
    "project-team": "/project/:project/team",
    "project-admin-home": "/project/:project/admin/project-profile/details",
    "project-admin-project-profile-details": "/project/:project/admin/project-profile/details",
    "project-admin-project-profile-default-values": "/project/:project/admin/project-profile/default-values",
    "project-admin-project-profile-modules": "/project/:project/admin/project-profile/modules",
    "project-admin-project-profile-export": "/project/:project/admin/project-profile/export",
    "project-admin-project-profile-reports": "/project/:project/admin/project-profile/reports",
    "project-admin-project-values-status": "/project/:project/admin/project-values/status",
    "project-admin-project-values-points": "/project/:project/admin/project-values/points",
    "project-admin-project-values-priorities": "/project/:project/admin/project-values/priorities",
    "project-admin-project-values-severities": "/project/:project/admin/project-values/severities",
    "project-admin-project-values-types": "/project/:project/admin/project-values/types",
    "project-admin-project-values-custom-fields": "/project/:project/admin/project-values/custom-fields",
    "project-admin-project-values-tags": "/project/:project/admin/project-values/tags",
    "project-admin-project-values-due-dates": "/project/:project/admin/project-values/due-dates",
    "project-admin-memberships": "/project/:project/admin/memberships",
    "project-admin-roles": "/project/:project/admin/roles",
    "project-admin-third-parties-webhooks": "/project/:project/admin/third-parties/webhooks",
    "project-admin-third-parties-github": "/project/:project/admin/third-parties/github",
    "project-admin-third-parties-gitlab": "/project/:project/admin/third-parties/gitlab",
    "project-admin-third-parties-bitbucket": "/project/:project/admin/third-parties/bitbucket",
    "project-admin-third-parties-gogs": "/project/:project/admin/third-parties/gogs",
    "project-admin-contrib": "/project/:project/admin/contrib/:plugin",
    "user-settings-user-profile": "/user-settings/user-profile",
    "user-settings-user-change-password": "/user-settings/user-change-password",
    "user-settings-user-avatar": "/user-settings/user-avatar",
    "user-settings-user-project-settings": "/user-settings/user-project-settings",
    "user-settings-mail-notifications": "/user-settings/mail-notifications",
    "user-settings-live-notifications": "/user-settings/live-notifications",
    "user-settings-web-notifications": "/user-settings/web-notifications",
    "user-settings-contrib": "/user-settings/contrib/:plugin",
    "notifications": "/notifications"
  };

  init = function($log, $navurls) {
    $log.debug("Initialize navigation urls");
    return $navurls.update(urls);
  };

  module.run(["$log", "$tgNavUrls", init]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common.coffee
 */

(function() {
  var AnimationFrame, Autofocus, Capslock, CheckPermissionDirective, ClassPermissionDirective, CtrlClickDisable, DataPickerConfig, LightboxClose, ProjectUrl, Qqueue, QueueModelTransformation, SelectedText, Svg, Template, ToggleCommentDirective, module, taiga,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  module = angular.module("taigaCommon", []);

  DataPickerConfig = function($translate, $config, $auth) {
    return {
      get: function() {
        var isRTL, lang, rtlLanguages, user;
        user = $auth.getUser();
        lang = (user != null ? user.lang : void 0) || $translate.preferredLanguage();
        rtlLanguages = $config.get("rtlLanguages", []);
        isRTL = rtlLanguages.indexOf(lang) > -1;
        return {
          i18n: {
            previousMonth: $translate.instant("COMMON.PICKERDATE.PREV_MONTH"),
            nextMonth: $translate.instant("COMMON.PICKERDATE.NEXT_MONTH"),
            months: [$translate.instant("COMMON.PICKERDATE.MONTHS.JAN"), $translate.instant("COMMON.PICKERDATE.MONTHS.FEB"), $translate.instant("COMMON.PICKERDATE.MONTHS.MAR"), $translate.instant("COMMON.PICKERDATE.MONTHS.APR"), $translate.instant("COMMON.PICKERDATE.MONTHS.MAY"), $translate.instant("COMMON.PICKERDATE.MONTHS.JUN"), $translate.instant("COMMON.PICKERDATE.MONTHS.JUL"), $translate.instant("COMMON.PICKERDATE.MONTHS.AUG"), $translate.instant("COMMON.PICKERDATE.MONTHS.SEP"), $translate.instant("COMMON.PICKERDATE.MONTHS.OCT"), $translate.instant("COMMON.PICKERDATE.MONTHS.NOV"), $translate.instant("COMMON.PICKERDATE.MONTHS.DEC")],
            weekdays: [$translate.instant("COMMON.PICKERDATE.WEEK_DAYS.SUN"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS.MON"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS.TUE"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS.WED"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS.THU"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS.FRI"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS.SAT")],
            weekdaysShort: [$translate.instant("COMMON.PICKERDATE.WEEK_DAYS_SHORT.SUN"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS_SHORT.MON"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS_SHORT.TUE"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS_SHORT.WED"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS_SHORT.THU"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS_SHORT.FRI"), $translate.instant("COMMON.PICKERDATE.WEEK_DAYS_SHORT.SAT")]
          },
          isRTL: isRTL,
          firstDay: parseInt($translate.instant("COMMON.PICKERDATE.FIRST_DAY_OF_WEEK"), 10),
          format: $translate.instant("COMMON.PICKERDATE.FORMAT")
        };
      }
    };
  };

  module.factory("tgDatePickerConfigService", ["$translate", "$tgConfig", "$tgAuth", DataPickerConfig]);

  SelectedText = function($window, $document) {
    var get;
    get = function() {
      if ($window.getSelection) {
        return $window.getSelection().toString();
      } else if ($document.selection) {
        return $document.selection.createRange().text;
      }
      return "";
    };
    return {
      get: get
    };
  };

  module.factory("$selectedText", ["$window", "$document", SelectedText]);

  CheckPermissionDirective = function(projectService) {
    var link, render;
    render = function($el, project, permission) {
      if (project && permission) {
        if (project.get('my_permissions').indexOf(permission) > -1) {
          return $el.removeClass('hidden');
        }
      }
    };
    link = function($scope, $el, $attrs) {
      var permission, unObserve, unwatch;
      $el.addClass('hidden');
      permission = $attrs.tgCheckPermission;
      unwatch = $scope.$watch(function() {
        return projectService.project;
      }, function() {
        if (!projectService.project) {
          return;
        }
        render($el, projectService.project, permission);
        return unwatch();
      });
      unObserve = $attrs.$observe("tgCheckPermission", function(permission) {
        if (!permission) {
          return;
        }
        render($el, projectService.project, permission);
        return unObserve();
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  CheckPermissionDirective.$inject = ["tgProjectService"];

  module.directive("tgCheckPermission", CheckPermissionDirective);

  ClassPermissionDirective = function() {
    var link, name;
    name = "tgClassPermission";
    link = function($scope, $el, $attrs) {
      var checkPermissions, tgClassPermissionWatchAction, unbindWatcher;
      checkPermissions = function(project, className, permission) {
        var negation;
        negation = permission[0] === "!";
        if (negation) {
          permission = permission.slice(1);
        }
        if (negation && project.my_permissions.indexOf(permission) === -1) {
          return $el.addClass(className);
        } else if (!negation && project.my_permissions.indexOf(permission) !== -1) {
          return $el.addClass(className);
        } else {
          return $el.removeClass(className);
        }
      };
      tgClassPermissionWatchAction = function(project) {
        var className, classes, permission, results;
        if (project) {
          unbindWatcher();
          classes = $scope.$eval($attrs[name]);
          results = [];
          for (className in classes) {
            permission = classes[className];
            results.push(checkPermissions(project, className, permission));
          }
          return results;
        }
      };
      return unbindWatcher = $scope.$watch("project", tgClassPermissionWatchAction);
    };
    return {
      link: link
    };
  };

  module.directive("tgClassPermission", ClassPermissionDirective);

  AnimationFrame = function() {
    var add, animationFrame, performAnimation, tail;
    animationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
    performAnimation = (function(_this) {
      return function(time) {
        var fn;
        fn = tail.shift();
        fn();
        if (tail.length) {
          return animationFrame(performAnimation);
        }
      };
    })(this);
    tail = [];
    add = function() {
      var fn, i, len, results;
      results = [];
      for (i = 0, len = arguments.length; i < len; i++) {
        fn = arguments[i];
        tail.push(fn);
        if (tail.length === 1) {
          results.push(animationFrame(performAnimation));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    return {
      add: add
    };
  };

  module.factory("animationFrame", AnimationFrame);

  ToggleCommentDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return $el.find("textarea").on("focus", function() {
        return $el.addClass("active");
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgToggleComment", ToggleCommentDirective);

  ProjectUrl = function($navurls) {
    var get;
    get = function(project) {
      var ctx;
      if (project.toJS) {
        project = project.toJS();
      }
      ctx = {
        project: project.slug
      };
      if (project.is_backlog_activated && project.my_permissions.indexOf("view_us") > -1) {
        return $navurls.resolve("project-backlog", ctx);
      }
      if (project.is_kanban_activated && project.my_permissions.indexOf("view_us") > -1) {
        return $navurls.resolve("project-kanban", ctx);
      }
      if (project.is_wiki_activated && project.my_permissions.indexOf("view_wiki_pages") > -1) {
        return $navurls.resolve("project-wiki", ctx);
      }
      if (project.is_issues_activated && project.my_permissions.indexOf("view_issues") > -1) {
        return $navurls.resolve("project-issues", ctx);
      }
      return $navurls.resolve("project", ctx);
    };
    return {
      get: get
    };
  };

  module.factory("$projectUrl", ["$tgNavUrls", ProjectUrl]);

  Qqueue = function($q) {
    var deferred, lastPromise, qqueue;
    deferred = $q.defer();
    deferred.resolve();
    lastPromise = deferred.promise;
    qqueue = {
      bindAdd: (function(_this) {
        return function(fn) {
          return function() {
            var args;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return lastPromise = lastPromise.then(function() {
              return fn.apply(_this, args);
            });
          };
        };
      })(this),
      add: (function(_this) {
        return function(fn) {
          if (!lastPromise) {
            lastPromise = fn();
          } else {
            lastPromise = lastPromise.then(fn);
          }
          return qqueue;
        };
      })(this)
    };
    return qqueue;
  };

  module.factory("$tgQqueue", ["$q", Qqueue]);

  QueueModelTransformation = (function(superClass) {
    extend(QueueModelTransformation, superClass);

    QueueModelTransformation.$inject = ["$tgQqueue", "$tgRepo", "$q", "$tgModel"];

    function QueueModelTransformation(qqueue1, repo, q, model1) {
      this.qqueue = qqueue1;
      this.repo = repo;
      this.q = q;
      this.model = model1;
    }

    QueueModelTransformation.prototype.setObject = function(scope1, prop) {
      this.scope = scope1;
      this.prop = prop;
    };

    QueueModelTransformation.prototype.clone = function() {
      var attrs, model;
      attrs = _.cloneDeep(this.scope[this.prop]._attrs);
      model = this.model.make_model(this.scope[this.prop]._name, attrs);
      return model;
    };

    QueueModelTransformation.prototype.getObj = function() {
      return this.scope[this.prop];
    };

    QueueModelTransformation.prototype.save = function(transformation) {
      var defered;
      defered = this.q.defer();
      this.qqueue.add((function(_this) {
        return function() {
          var clone, comment, modified, obj, success;
          obj = _this.getObj();
          comment = obj.comment;
          obj.comment = '';
          clone = _this.clone();
          modified = _.omit(obj._modifiedAttrs, ['version']);
          clone = _.assign(clone, modified);
          transformation(clone);
          if (comment.length) {
            clone.comment = comment;
          }
          success = function() {
            _this.scope[_this.prop] = clone;
            return defered.resolve.apply(null, arguments);
          };
          return _this.repo.save(clone).then(success, defered.reject);
        };
      })(this));
      return defered.promise;
    };

    return QueueModelTransformation;

  })(taiga.Service);

  module.service("$tgQueueModelTransformation", QueueModelTransformation);

  Template = function($templateCache) {
    return {
      get: (function(_this) {
        return function(name, lodash) {
          var tmp;
          if (lodash == null) {
            lodash = false;
          }
          tmp = $templateCache.get(name);
          if (lodash) {
            tmp = _.template(tmp);
          }
          return tmp;
        };
      })(this)
    };
  };

  module.factory("$tgTemplate", ["$templateCache", Template]);

  Capslock = function() {
    var template;
    template = "<tg-svg class=\"capslock\" ng-if=\"capslockIcon && iscapsLockActivated\" svg-icon='icon-capslock' svg-title='COMMON.CAPSLOCK_WARNING'></tg-svg>";
    return {
      template: template
    };
  };

  module.directive("tgCapslock", [Capslock]);

  LightboxClose = function() {
    var link, template;
    template = "<a class=\"close\" ng-click=\"onClose()\" href=\"\" title=\"{{'COMMON.CLOSE' | translate}}\">\n    <tg-svg svg-icon=\"icon-close\"></tg-svg>\n</a>";
    link = function(scope, elm, attrs) {};
    return {
      scope: {
        onClose: '&'
      },
      link: link,
      template: template
    };
  };

  module.directive("tgLightboxClose", [LightboxClose]);

  Svg = function() {
    var template;
    template = "<svg class=\"{{ 'icon ' + svgIcon }}\" style=\"fill: {{ svgFill }}\">\n    <use xlink:href=\"\" ng-attr-xlink:href=\"{{ '#' + svgIcon }}\" ng-attr-href=\"{{ '#' + svgIcon }}\">\n        <title ng-if=\"svgTitle\">{{svgTitle}}</title>\n        <title ng-if=\"svgTitleTranslate\">{{svgTitleTranslate | translate: svgTitleTranslateValues}}</title>\n    </use>\n</svg>";
    return {
      scope: {
        svgIcon: "@",
        svgTitle: "@",
        svgTitleTranslate: "@",
        svgTitleTranslateValues: "=",
        svgFill: "="
      },
      template: template
    };
  };

  module.directive("tgSvg", [Svg]);

  Autofocus = function($timeout, $parse, animationFrame) {
    return {
      restrict: 'A',
      link: function($scope, $element, attrs) {
        var model;
        if (attrs.ngShow) {
          model = $parse(attrs.ngShow);
          return $scope.$watch(model, function(value) {
            if (value === true) {
              return $timeout(function() {
                return $element[0].focus();
              });
            }
          });
        } else {
          return $timeout(function() {
            return $element[0].focus();
          });
        }
      }
    };
  };

  module.directive('tgAutofocus', ['$timeout', '$parse', "animationFrame", Autofocus]);

  module.directive('tgPreloadImage', function() {
    var preload, spinner, template;
    spinner = "<img class='loading-spinner' src='/" + window._version + "/svg/spinner-circle.svg' alt='loading...' />";
    template = "<div>\n    <ng-transclude></ng-transclude>\n</div>";
    preload = function(src, onLoad) {
      var image;
      image = new Image();
      image.onload = onLoad;
      image.src = src;
      return image;
    };
    return {
      template: template,
      transclude: true,
      replace: true,
      link: function(scope, el, attrs) {
        var image, onLoad, timeout;
        image = el.find('img:last');
        timeout = null;
        onLoad = function() {
          el.find('.loading-spinner').remove();
          image.show();
          if (timeout) {
            clearTimeout(timeout);
            return timeout = null;
          }
        };
        return attrs.$observe('preloadSrc', function(src) {
          if (timeout) {
            clearTimeout(timeout);
          }
          el.find('.loading-spinner').remove();
          timeout = setTimeout(function() {
            return el.prepend(spinner);
          }, 200);
          image.hide();
          return preload(src, onLoad);
        });
      }
    };
  });

  CtrlClickDisable = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return $el.on("click", function($event) {
        if ($event.ctrlKey || $event.metaKey) {
          return $event.preventDefault();
        }
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgCtrlClickDisable", CtrlClickDisable);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/detail.coffee
 */

(function() {
  var DetailController, bindMethods, bindOnce, groupBy, joinStr, mixOf, module, taiga, toString;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  toString = this.taiga.toString;

  joinStr = this.taiga.joinStr;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  bindMethods = this.taiga.bindMethods;

  module = angular.module("taigaCommon");

  DetailController = (function() {
    DetailController.$inject = ['$routeParams', '$tgRepo', "tgProjectService", "$tgNavUrls", "$location"];

    function DetailController(params, repo, projectService, navurls, location) {
      this.params = params;
      this.repo = repo;
      this.projectService = projectService;
      this.navurls = navurls;
      this.location = location;
      this.repo.resolve({
        pslug: this.params.pslug,
        ref: this.params.ref
      }).then((function(_this) {
        return function(result) {
          var url;
          if (result.issue) {
            url = _this.navurls.resolve('project-issues-detail', {
              project: _this.projectService.project.get('slug'),
              ref: _this.params.ref
            });
          } else if (result.task) {
            url = _this.navurls.resolve('project-tasks-detail', {
              project: _this.projectService.project.get('slug'),
              ref: _this.params.ref
            });
          } else if (result.us) {
            url = _this.navurls.resolve('project-userstories-detail', {
              project: _this.projectService.project.get('slug'),
              ref: _this.params.ref
            });
          } else if (result.epic) {
            url = _this.navurls.resolve('project-epics-detail', {
              project: _this.projectService.project.get('slug'),
              ref: _this.params.ref
            });
          } else if (result.wikipage) {
            url = _this.navurls.resolve('project-wiki-page', {
              project: _this.projectService.project.get('slug'),
              slug: _this.params.ref
            });
          }
          return _this.location.path(url);
        };
      })(this));
    }

    return DetailController;

  })();

  module.controller("DetailController", DetailController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/epics.coffee
 */

(function() {
  var module;

  module = angular.module("taigaEpics", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/events.coffee
 */

(function() {
  var EventsProvider, EventsService, bindMethods, module, startswith, taiga,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  taiga = this.taiga;

  startswith = this.taiga.startswith;

  bindMethods = this.taiga.bindMethods;

  module = angular.module("taigaEvents", []);

  EventsService = (function() {
    function EventsService(win, log, config, auth, liveAnnouncementService1, rootScope) {
      this.win = win;
      this.log = log;
      this.config = config;
      this.auth = auth;
      this.liveAnnouncementService = liveAnnouncementService1;
      this.rootScope = rootScope;
      this.processMessage = bind(this.processMessage, this);
      bindMethods(this);
    }

    EventsService.prototype.initialize = function(sessionId) {
      this.sessionId = sessionId;
      this.subscriptions = {};
      this.connected = false;
      this.error = false;
      this.pendingMessages = [];
      this.missedHeartbeats = 0;
      this.heartbeatInterval = null;
      if (this.win.WebSocket === void 0) {
        return this.log.info("WebSockets not supported on your browser");
      }
    };

    EventsService.prototype.setupConnection = function() {
      var loc, path, scheme, url;
      this.stopExistingConnection();
      url = this.config.get("eventsUrl");
      if (!url) {
        return;
      }
      if (!startswith(url, "ws:") && !startswith(url, "wss:")) {
        loc = this.win.location;
        scheme = loc.protocol === "https:" ? "wss:" : "ws:";
        path = _.trimStart(url, "/");
        url = scheme + "//" + loc.host + "/" + path;
      }
      this.error = false;
      this.ws = new this.win.WebSocket(url);
      this.ws.addEventListener("open", this.onOpen);
      this.ws.addEventListener("message", this.onMessage);
      this.ws.addEventListener("error", this.onError);
      return this.ws.addEventListener("close", this.onClose);
    };

    EventsService.prototype.stopExistingConnection = function() {
      if (this.ws === void 0) {
        return;
      }
      this.ws.removeEventListener("open", this.onOpen);
      this.ws.removeEventListener("close", this.onClose);
      this.ws.removeEventListener("error", this.onError);
      this.ws.removeEventListener("message", this.onMessage);
      this.stopHeartBeatMessages();
      this.ws.close();
      return delete this.ws;
    };

    EventsService.prototype.notifications = function() {
      return this.subscribe(null, 'notifications', (function(_this) {
        return function(data) {
          _this.liveAnnouncementService.show(data.title, data.desc);
          return _this.rootScope.$digest();
        };
      })(this));
    };

    EventsService.prototype.liveNotifications = function() {
      var subscribe, userId;
      if (this.auth.userData == null) {
        return;
      }
      userId = this.auth.userData.get('id');
      subscribe = (function(_this) {
        return function() {
          return _this.subscribe(null, "live_notifications." + userId, function(data) {
            var notification;
            notification = new Notification(data.title, {
              icon: "/" + window._version + "/images/favicon.png",
              body: data.body,
              tag: data.id
            });
            notification.onshow = function() {
              if (data.timeout && data.timeout > 0) {
                return setTimeout(function() {
                  return notification.close();
                }, data.timeout);
              }
            };
            if (data.url) {
              return notification.onclick = function() {
                return window.open(data.url);
              };
            }
          });
        };
      })(this);
      if (!(indexOf.call(window, 'Notification') >= 0)) {
        return console.log("This browser does not support desktop notification");
      } else if (Notification.permission === "granted") {
        return subscribe();
      } else if (Notification.permission !== 'denied') {
        return Notification.requestPermission((function(_this) {
          return function(permission) {
            if (permission === "granted") {
              return subscribe();
            }
          };
        })(this));
      }
    };

    EventsService.prototype.webNotifications = function() {
      var randomTimeout, routingKey, userId;
      if (this.auth.userData == null) {
        return;
      }
      userId = this.auth.userData.get('id');
      routingKey = "web_notifications." + userId;
      randomTimeout = taiga.randomInt(700, 1000);
      return this.subscribe(null, routingKey, (function(_this) {
        return function(data) {
          return _this.rootScope.$broadcast("notifications:new");
        };
      })(this));
    };

    EventsService.prototype.startHeartBeatMessages = function() {
      var heartbeatIntervalTime, maxMissedHeartbeats, reconnectTryInterval;
      if (this.heartbeatInterval) {
        return;
      }
      maxMissedHeartbeats = this.config.get("eventsMaxMissedHeartbeats", 5);
      heartbeatIntervalTime = this.config.get("eventsHeartbeatIntervalTime", 60000);
      reconnectTryInterval = this.config.get("eventsReconnectTryInterval", 10000);
      this.missedHeartbeats = 0;
      this.heartbeatInterval = setInterval((function(_this) {
        return function() {
          var e;
          try {
            if (_this.missedHeartbeats >= maxMissedHeartbeats) {
              throw new Error("Too many missed heartbeats PINGs.");
            }
            _this.missedHeartbeats++;
            _this.sendMessage({
              cmd: "ping"
            });
            return _this.log.debug("HeartBeat send PING");
          } catch (error1) {
            e = error1;
            _this.log.error("HeartBeat error: " + e.message);
            return _this.setupConnection();
          }
        };
      })(this), heartbeatIntervalTime);
      return this.log.debug("HeartBeat enabled");
    };

    EventsService.prototype.stopHeartBeatMessages = function() {
      if (!this.heartbeatInterval) {
        return;
      }
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
      return this.log.debug("HeartBeat disabled");
    };

    EventsService.prototype.processHeartBeatPongMessage = function(data) {
      this.missedHeartbeats = 0;
      return this.log.debug("HeartBeat recived PONG");
    };

    EventsService.prototype.serialize = function(message) {
      if (_.isObject(message)) {
        return JSON.stringify(message);
      }
      return message;
    };

    EventsService.prototype.sendMessage = function(message) {
      var i, len, messages, msg, results;
      this.pendingMessages.push(message);
      if (!this.connected) {
        return;
      }
      messages = _.map(this.pendingMessages, this.serialize);
      this.pendingMessages = [];
      results = [];
      for (i = 0, len = messages.length; i < len; i++) {
        msg = messages[i];
        results.push(this.ws.send(msg));
      }
      return results;
    };

    EventsService.prototype.processMessage = function(data) {
      var routingKey, subscription;
      routingKey = data.routing_key;
      if (this.subscriptions[routingKey] == null) {
        return;
      }
      subscription = this.subscriptions[routingKey];
      if (subscription.scope) {
        return subscription.scope.$apply(function() {
          return subscription.callback(data.data);
        });
      } else {
        return subscription.callback(data.data);
      }
    };

    EventsService.prototype.subscribe = function(scope, routingKey, callback) {
      var message, subscription;
      if (this.error) {
        return;
      }
      this.log.debug("Subscribe to: " + routingKey);
      subscription = {
        scope: scope,
        routingKey: routingKey,
        callback: callback
      };
      message = {
        "cmd": "subscribe",
        "routing_key": routingKey
      };
      this.subscriptions[routingKey] = subscription;
      this.sendMessage(message);
      if (scope) {
        return scope.$on("$destroy", (function(_this) {
          return function() {
            return _this.unsubscribe(routingKey);
          };
        })(this));
      }
    };

    EventsService.prototype.unsubscribe = function(routingKey) {
      var message;
      if (this.error) {
        return;
      }
      this.log.debug("Unsubscribe from: " + routingKey);
      message = {
        "cmd": "unsubscribe",
        "routing_key": routingKey
      };
      return this.sendMessage(message);
    };

    EventsService.prototype.onOpen = function() {
      var message, token;
      this.connected = true;
      this.log.debug("WebSocket connection opened");
      token = this.auth.getToken();
      message = {
        cmd: "auth",
        data: {
          token: token,
          sessionId: this.sessionId
        }
      };
      this.sendMessage(message);
      this.startHeartBeatMessages();
      this.notifications();
      this.liveNotifications();
      return this.webNotifications();
    };

    EventsService.prototype.onMessage = function(event) {
      var data;
      this.log.debug("WebSocket message received: " + event.data);
      data = JSON.parse(event.data);
      if (data.cmd === "pong") {
        return this.processHeartBeatPongMessage(data);
      } else {
        return this.processMessage(data);
      }
    };

    EventsService.prototype.onError = function(error) {
      this.log.error("WebSocket error: " + error);
      this.error = true;
      return setTimeout(this.setupConnection, this.reconnectTryInterval);
    };

    EventsService.prototype.onClose = function() {
      this.log.debug("WebSocket closed.");
      this.connected = false;
      this.stopHeartBeatMessages();
      return setTimeout(this.setupConnection, this.reconnectTryInterval);
    };

    return EventsService;

  })();

  EventsProvider = (function() {
    function EventsProvider() {}

    EventsProvider.prototype.setSessionId = function(sessionId) {
      return this.sessionId = sessionId;
    };

    EventsProvider.prototype.$get = function($win, $log, $conf, $auth, liveAnnouncementService, $rootScope) {
      var service;
      service = new EventsService($win, $log, $conf, $auth, liveAnnouncementService, $rootScope);
      service.initialize(this.sessionId);
      return service;
    };

    EventsProvider.prototype.$get.$inject = ["$window", "$log", "$tgConfig", "$tgAuth", "tgLiveAnnouncementService", "$rootScope"];

    return EventsProvider;

  })();

  module.provider("$tgEvents", EventsProvider);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/feedback.coffee
 */

(function() {
  var FeedbackDirective, bindOnce, debounce, groupBy, mixOf, module, taiga, trim;

  taiga = this.taiga;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  mixOf = this.taiga.mixOf;

  debounce = this.taiga.debounce;

  trim = this.taiga.trim;

  module = angular.module("taigaFeedback", []);

  FeedbackDirective = function($lightboxService, $repo, $confirm, $loading, feedbackService) {
    var directive, link;
    link = function($scope, $el, $attrs) {
      var form, openLightbox, submit, submitButton;
      form = $el.find("form").checksley();
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          promise = $repo.create("feedback", $scope.feedback);
          promise.then(function(data) {
            currentLoading.finish();
            $lightboxService.close($el);
            return $confirm.notify("success", "\\o/ we'll be happy to read your");
          });
          return promise.then(null, function() {
            currentLoading.finish();
            return $confirm.notify("error");
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      $el.on("submit", "form", submit);
      openLightbox = function() {
        $scope.feedback = {};
        $lightboxService.open($el);
        return $el.find("textarea").focus();
      };
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return openLightbox();
    };
    directive = {
      link: link,
      templateUrl: "common/lightbox-feedback.html",
      scope: {}
    };
    return directive;
  };

  module.directive("tgLbFeedback", ["lightboxService", "$tgRepo", "$tgConfirm", "$tgLoading", "tgFeedbackService", FeedbackDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/integrations.coffee
 */

(function() {
  var module;

  module = angular.module("taigaIntegrations", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/issues.coffee
 */

(function() {
  var module;

  module = angular.module("taigaIssues", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/kanban.coffee
 */

(function() {
  var module;

  module = angular.module("taigaKanban", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/plugins.coffee
 */

(function() {
  var module;

  module = angular.module("taigaPlugins", ["ngRoute"]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/projects.coffee
 */

(function() {
  var module;

  module = angular.module("taigaProject", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/related-tasks.coffee
 */

(function() {
  var RelatedTaskAssignedToInlineEditionDirective, RelatedTaskCreateButtonDirective, RelatedTaskCreateFormDirective, RelatedTaskRowDirective, RelatedTasksDirective, debounce, module, taiga, trim;

  taiga = this.taiga;

  trim = this.taiga.trim;

  debounce = this.taiga.debounce;

  module = angular.module("taigaRelatedTasks", []);

  RelatedTaskRowDirective = function($repo, $compile, $confirm, $rootscope, $loading, $template, $translate, $emojis) {
    var link, templateEdit, templateView;
    templateView = $template.get("task/related-task-row.html", true);
    templateEdit = $template.get("task/related-task-row-edit.html", true);
    link = function($scope, $el, $attrs, $model) {
      var renderEdit, renderView, saveTask;
      saveTask = debounce(2000, function(task) {
        var currentLoading, promise;
        task.subject = $el.find('input').val();
        currentLoading = $loading().target($el.find('.task-name')).start();
        promise = $repo.save(task);
        promise.then((function(_this) {
          return function() {
            currentLoading.finish();
            return $rootscope.$broadcast("related-tasks:update");
          };
        })(this));
        promise.then(null, (function(_this) {
          return function() {
            currentLoading.finish();
            $el.find('input').val(task.subject);
            return $confirm.notify("error");
          };
        })(this));
        return promise;
      });
      renderEdit = function(task) {
        if (this.childScope) {
          this.childScope.$destroy();
        }
        this.childScope = $scope.$new();
        $el.off();
        $el.html($compile(templateEdit({
          task: task
        }))(childScope));
        $el.find(".task-name input").val(task.subject);
        $el.on("keyup", "input", function(event) {
          if (event.keyCode === 13) {
            return saveTask($model.$modelValue).then(function() {
              return renderView($model.$modelValue);
            });
          } else if (event.keyCode === 27) {
            return renderView($model.$modelValue);
          }
        });
        $el.on("click", ".save-task", function(event) {
          return saveTask($model.$modelValue).then(function() {
            return renderView($model.$modelValue);
          });
        });
        return $el.on("click", ".cancel-edit", function(event) {
          return renderView($model.$modelValue);
        });
      };
      renderView = function(task) {
        var perms;
        perms = {
          modify_task: $scope.project.my_permissions.indexOf("modify_task") !== -1,
          delete_task: $scope.project.my_permissions.indexOf("delete_task") !== -1
        };
        $el.html($compile(templateView({
          task: task,
          perms: perms,
          emojify: function(text) {
            return $emojis.replaceEmojiNameByHtmlImgs(_.escape(text));
          }
        }))($scope));
        $el.on("click", ".edit-task", function() {
          renderEdit($model.$modelValue);
          return $el.find('input').focus().select();
        });
        return $el.on("click", ".delete-task", function(event) {
          var message, title;
          title = $translate.instant("TASK.TITLE_DELETE_ACTION");
          task = $model.$modelValue;
          message = task.subject;
          return $confirm.askOnDelete(title, message).then(function(askResponse) {
            var promise;
            promise = $repo.remove(task);
            promise.then(function() {
              askResponse.finish();
              return $scope.$emit("related-tasks:delete");
            });
            return promise.then(null, function() {
              askResponse.finish(false);
              return $confirm.notify("error");
            });
          });
        });
      };
      $scope.$watch($attrs.ngModel, function(val) {
        if (!val) {
          return;
        }
        return renderView(val);
      });
      $scope.$on("related-tasks:assigned-to-changed", function() {
        return $rootscope.$broadcast("related-tasks:update");
      });
      $scope.$on("related-tasks:status-changed", function() {
        return $rootscope.$broadcast("related-tasks:update");
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      require: "ngModel"
    };
  };

  module.directive("tgRelatedTaskRow", ["$tgRepo", "$compile", "$tgConfirm", "$rootScope", "$tgLoading", "$tgTemplate", "$translate", "$tgEmojis", RelatedTaskRowDirective]);

  RelatedTaskCreateFormDirective = function($repo, $compile, $confirm, $tgmodel, $loading, $analytics) {
    var link, newTask;
    newTask = {
      subject: "",
      assigned_to: null
    };
    link = function($scope, $el, $attrs) {
      var close, createTask, render, reset;
      createTask = function(task) {
        var currentLoading, promise;
        task.subject = $el.find('input').val();
        task.assigned_to = $scope.newTask.assigned_to;
        task.status = $scope.newTask.status;
        $scope.newTask.status = $scope.project.default_task_status;
        $scope.newTask.assigned_to = null;
        currentLoading = $loading().target($el.find('.task-name')).start();
        promise = $repo.create("tasks", task);
        promise.then(function() {
          $analytics.trackEvent("task", "create", "create task on userstory", 1);
          currentLoading.finish();
          return $scope.$emit("related-tasks:add");
        });
        promise.then(null, function() {
          $el.find('input').val(task.subject);
          currentLoading.finish();
          return $confirm.notify("error");
        });
        return promise;
      };
      close = function() {
        $el.off();
        return $scope.openNewRelatedTask = false;
      };
      reset = function() {
        newTask = {
          subject: "",
          assigned_to: null
        };
        newTask["status"] = $scope.project.default_task_status;
        newTask["project"] = $scope.project.id;
        newTask["user_story"] = $scope.us.id;
        return $scope.newTask = $tgmodel.make_model("tasks", newTask);
      };
      render = function() {
        if ($scope.openNewRelatedTask) {
          return;
        }
        $scope.openNewRelatedTask = true;
        return $el.on("keyup", "input", function(event) {
          if (event.keyCode === 13) {
            return createTask(newTask).then(function() {
              reset();
              return $el.find('input').focus();
            });
          } else if (event.keyCode === 27) {
            return $scope.$apply(function() {
              return close();
            });
          }
        });
      };
      $scope.save = function() {
        return createTask(newTask).then(function() {
          return close();
        });
      };
      taiga.bindOnce($scope, "us", reset);
      $scope.$on("related-tasks:show-form", function() {
        return $scope.$apply(render);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      scope: true,
      link: link,
      templateUrl: 'task/related-task-create-form.html'
    };
  };

  module.directive("tgRelatedTaskCreateForm", ["$tgRepo", "$compile", "$tgConfirm", "$tgModel", "$tgLoading", "$tgAnalytics", RelatedTaskCreateFormDirective]);

  RelatedTaskCreateButtonDirective = function($repo, $compile, $confirm, $tgmodel, $template) {
    var link, template;
    template = $template.get("common/components/add-button.html", true);
    link = function($scope, $el, $attrs) {
      $scope.$watch("project", function(val) {
        if (!val) {
          return;
        }
        $el.off();
        if ($scope.project.my_permissions.indexOf("add_task") !== -1) {
          $el.html($compile(template())($scope));
        } else {
          $el.html("");
        }
        return $el.on("click", ".add-button", function(event) {
          return $scope.$emit("related-tasks:add-new-clicked");
        });
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgRelatedTaskCreateButton", ["$tgRepo", "$compile", "$tgConfirm", "$tgModel", "$tgTemplate", RelatedTaskCreateButtonDirective]);

  RelatedTasksDirective = function($repo, $rs, $rootscope) {
    var link;
    link = function($scope, $el, $attrs) {
      var _isEditable, _isVisible, loadTasks;
      loadTasks = function() {
        return $rs.tasks.list($scope.projectId, null, $scope.usId).then(function(result) {
          return Immutable.fromJS(result.data);
        });
      };
      _isVisible = function() {
        if ($scope.project) {
          return $scope.project.my_permissions.indexOf("view_tasks") !== -1;
        }
        return false;
      };
      _isEditable = function() {
        if ($scope.project) {
          return $scope.project.my_permissions.indexOf("modify_task") !== -1;
        }
        return false;
      };
      $scope.reorderTask = function(task, newIndex) {
        return $rootscope.$broadcast('task:reorder', task, newIndex);
      };
      $scope.showRelatedTasks = function() {
        var ref;
        return _isVisible() && (_isEditable() || ((ref = $scope.tasks) != null ? ref.length : void 0));
      };
      $scope.$on("related-tasks:add", function() {
        return loadTasks().then(function() {
          return $rootscope.$broadcast("related-tasks:update");
        });
      });
      $scope.$on("related-tasks:reordered", function() {
        return loadTasks();
      });
      $scope.$on("related-tasks:delete", function() {
        return loadTasks().then(function() {
          return $rootscope.$broadcast("related-tasks:update");
        });
      });
      $scope.$on("related-tasks:add-new-clicked", function() {
        return $scope.$broadcast("related-tasks:show-form");
      });
      taiga.bindOnce($scope, "us", function(val) {
        return loadTasks();
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgRelatedTasks", ["$tgRepo", "$tgResources", "$rootScope", RelatedTasksDirective]);

  RelatedTaskAssignedToInlineEditionDirective = function($repo, $rootscope, $translate, avatarService, $lightboxFactory) {
    var link, template;
    template = _.template("<img style=\"background-color: <%- bg %>\" src=\"<%- imgurl %>\" alt=\"<%- name %>\"/>\n<figcaption><%- name %></figcaption>");
    link = function($scope, $el, $attrs) {
      var $ctrl, autoSave, notAutoSave, task, updateRelatedTask;
      updateRelatedTask = function(task) {
        var avatar, ctx, member;
        ctx = {
          name: $translate.instant("COMMON.ASSIGNED_TO.NOT_ASSIGNED")
        };
        member = $scope.usersById[task.assigned_to];
        avatar = avatarService.getAvatar(member);
        ctx.imgurl = avatar.url;
        ctx.bg = avatar.bg;
        if (member) {
          ctx.name = member.full_name_display;
        }
        $el.find(".avatar").html(template(ctx));
        return $el.find(".task-assignedto").attr('title', ctx.name);
      };
      $ctrl = $el.controller();
      task = $scope.$eval($attrs.tgRelatedTaskAssignedToInlineEdition);
      notAutoSave = $scope.$eval($attrs.notAutoSave);
      autoSave = !notAutoSave;
      $scope.$watch($attrs.tgRelatedTaskAssignedToInlineEdition, function() {
        task = $scope.$eval($attrs.tgRelatedTaskAssignedToInlineEdition);
        return updateRelatedTask(task);
      });
      updateRelatedTask(task);
      $el.on("click", ".task-assignedto", function(event) {
        var onClose;
        event.preventDefault();
        event.stopPropagation();
        onClose = (function(_this) {
          return function(assignedUsers) {
            task.assigned_to = assignedUsers.pop() || null;
            if (autoSave) {
              return $repo.save(task).then(function() {
                $scope.$emit("related-tasks:assigned-to-changed");
                return updateRelatedTask(task);
              });
            }
          };
        })(this);
        return $lightboxFactory.create('tg-lb-select-user', {
          "class": "lightbox lightbox-select-user"
        }, {
          "currentUsers": [task.assigned_to],
          "activeUsers": $scope.activeUsers,
          "onClose": onClose,
          "single": true,
          "lbTitle": $translate.instant("COMMON.ASSIGNED_USERS.ADD")
        });
      });
      taiga.bindOnce($scope, "project", function(project) {
        if (project.my_permissions.indexOf("modify_task") === -1) {
          $el.unbind("click");
          return $el.find("a").addClass("not-clickable");
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgRelatedTaskAssignedToInlineEdition", ["$tgRepo", "$rootScope", "$translate", "tgAvatarService", "tgLightboxFactory", RelatedTaskAssignedToInlineEditionDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources.coffee
 */

(function() {
  var ResourcesService, initResources, initUrls, module, taiga, urls,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  ResourcesService = (function(superClass) {
    extend(ResourcesService, superClass);

    function ResourcesService() {
      return ResourcesService.__super__.constructor.apply(this, arguments);
    }

    return ResourcesService;

  })(taiga.Service);

  urls = {
    "auth": "/auth",
    "auth-register": "/auth/register",
    "invitations": "/invitations",
    "users": "/users",
    "by_username": "/users/by_username",
    "users-password-recovery": "/users/password_recovery",
    "users-change-password-from-recovery": "/users/change_password_from_recovery",
    "users-change-password": "/users/change_password",
    "users-change-email": "/users/change_email",
    "users-cancel-account": "/users/cancel",
    "users-export": "/users/export",
    "user-stats": "/users/%s/stats",
    "user-liked": "/users/%s/liked",
    "user-voted": "/users/%s/voted",
    "user-watched": "/users/%s/watched",
    "user-contacts": "/users/%s/contacts",
    "user-me": "/users/me",
    "user-send-verification-email": "/users/send_verification_email",
    "permissions": "/permissions",
    "notify-policies": "/notify-policies",
    "notifications": "/web-notifications",
    "user-project-settings": "/user-project-settings",
    "user-storage": "/user-storage",
    "memberships": "/memberships",
    "bulk-create-memberships": "/memberships/bulk_create",
    "roles": "/roles",
    "permissions": "/permissions",
    "resolver": "/resolver",
    "projects": "/projects",
    "project-templates": "/project-templates",
    "project-modules": "/projects/%s/modules",
    "bulk-update-projects-order": "/projects/bulk_update_order",
    "project-like": "/projects/%s/like",
    "project-unlike": "/projects/%s/unlike",
    "project-watch": "/projects/%s/watch",
    "project-unwatch": "/projects/%s/unwatch",
    "project-contact": "contact",
    "project-transfer-validate-token": "/projects/%s/transfer_validate_token",
    "project-transfer-accept": "/projects/%s/transfer_accept",
    "project-transfer-reject": "/projects/%s/transfer_reject",
    "project-transfer-request": "/projects/%s/transfer_request",
    "project-transfer-start": "/projects/%s/transfer_start",
    "epic-statuses": "/epic-statuses",
    "userstory-statuses": "/userstory-statuses",
    "userstory-due-dates": "/userstory-due-dates",
    "userstory-due-dates-create-default": "/userstory-due-dates/create_default",
    "points": "/points",
    "task-statuses": "/task-statuses",
    "task-due-dates": "/task-due-dates",
    "task-due-dates-create-default": "/task-due-dates/create_default",
    "issue-statuses": "/issue-statuses",
    "issue-due-dates": "/issue-due-dates",
    "issue-due-dates-create-default": "/issue-due-dates/create_default",
    "issue-types": "/issue-types",
    "priorities": "/priorities",
    "severities": "/severities",
    "milestones": "/milestones",
    "move-userstories-to-milestone": "/milestones/%s/move_userstories_to_sprint",
    "move-tasks-to-milestone": "/milestones/%s/move_tasks_to_sprint",
    "move-issues-to-milestone": "/milestones/%s/move_issues_to_sprint",
    "epics": "/epics",
    "epic-upvote": "/epics/%s/upvote",
    "epic-downvote": "/epics/%s/downvote",
    "epic-watch": "/epics/%s/watch",
    "epic-unwatch": "/epics/%s/unwatch",
    "epic-related-userstories": "/epics/%s/related_userstories",
    "epic-related-userstories-bulk-create": "/epics/%s/related_userstories/bulk_create",
    "userstories": "/userstories",
    "bulk-create-us": "/userstories/bulk_create",
    "bulk-update-us-backlog-order": "/userstories/bulk_update_backlog_order",
    "bulk-update-us-milestone": "/userstories/bulk_update_milestone",
    "bulk-update-us-miles-order": "/userstories/bulk_update_sprint_order",
    "bulk-update-us-kanban-order": "/userstories/bulk_update_kanban_order",
    "userstories-filters": "/userstories/filters_data",
    "userstory-upvote": "/userstories/%s/upvote",
    "userstory-downvote": "/userstories/%s/downvote",
    "userstory-watch": "/userstories/%s/watch",
    "userstory-unwatch": "/userstories/%s/unwatch",
    "tasks": "/tasks",
    "bulk-create-tasks": "/tasks/bulk_create",
    "bulk-update-task-taskboard-order": "/tasks/bulk_update_taskboard_order",
    "bulk-update-task-milestone": "/tasks/bulk_update_milestone",
    "task-upvote": "/tasks/%s/upvote",
    "task-downvote": "/tasks/%s/downvote",
    "task-watch": "/tasks/%s/watch",
    "task-unwatch": "/tasks/%s/unwatch",
    "task-filters": "/tasks/filters_data",
    "promote-task-to-us": "/tasks/%s/promote_to_user_story",
    "issues": "/issues",
    "bulk-create-issues": "/issues/bulk_create",
    "bulk-update-issue-milestone": "/issues/bulk_update_milestone",
    "issues-filters": "/issues/filters_data",
    "issue-upvote": "/issues/%s/upvote",
    "issue-downvote": "/issues/%s/downvote",
    "issue-watch": "/issues/%s/watch",
    "issue-unwatch": "/issues/%s/unwatch",
    "promote-issue-to-us": "/issues/%s/promote_to_user_story",
    "wiki": "/wiki",
    "wiki-restore": "/wiki/%s/restore",
    "wiki-links": "/wiki-links",
    "history/epic": "/history/epic",
    "history/us": "/history/userstory",
    "history/issue": "/history/issue",
    "history/task": "/history/task",
    "history/wiki": "/history/wiki",
    "attachments/epic": "/epics/attachments",
    "attachments/us": "/userstories/attachments",
    "attachments/issue": "/issues/attachments",
    "attachments/task": "/tasks/attachments",
    "attachments/wiki_page": "/wiki/attachments",
    "custom-attributes/epic": "/epic-custom-attributes",
    "custom-attributes/userstory": "/userstory-custom-attributes",
    "custom-attributes/task": "/task-custom-attributes",
    "custom-attributes/issue": "/issue-custom-attributes",
    "custom-attributes-values/epic": "/epics/custom-attributes-values",
    "custom-attributes-values/userstory": "/userstories/custom-attributes-values",
    "custom-attributes-values/task": "/tasks/custom-attributes-values",
    "custom-attributes-values/issue": "/issues/custom-attributes-values",
    "webhooks": "/webhooks",
    "webhooks-test": "/webhooks/%s/test",
    "webhooklogs": "/webhooklogs",
    "webhooklogs-resend": "/webhooklogs/%s/resend",
    "epics-csv": "/epics/csv?uuid=%s",
    "userstories-csv": "/userstories/csv?uuid=%s",
    "tasks-csv": "/tasks/csv?uuid=%s",
    "issues-csv": "/issues/csv?uuid=%s",
    "timeline-profile": "/timeline/profile",
    "timeline-user": "/timeline/user",
    "timeline-project": "/timeline/project",
    "search": "/search",
    "exporter": "/exporter",
    "importer": "/importer/load_dump",
    "feedback": "/feedback",
    "locales": "/locales",
    "applications": "/applications",
    "application-tokens": "/application-tokens",
    "stats-discover": "/stats/discover",
    "importers-trello-auth-url": "/importers/trello/auth_url",
    "importers-trello-authorize": "/importers/trello/authorize",
    "importers-trello-list-projects": "/importers/trello/list_projects",
    "importers-trello-list-users": "/importers/trello/list_users",
    "importers-trello-import-project": "/importers/trello/import_project",
    "importers-jira-auth-url": "/importers/jira/auth_url",
    "importers-jira-authorize": "/importers/jira/authorize",
    "importers-jira-list-projects": "/importers/jira/list_projects",
    "importers-jira-list-users": "/importers/jira/list_users",
    "importers-jira-import-project": "/importers/jira/import_project",
    "importers-github-auth-url": "/importers/github/auth_url",
    "importers-github-authorize": "/importers/github/authorize",
    "importers-github-list-projects": "/importers/github/list_projects",
    "importers-github-list-users": "/importers/github/list_users",
    "importers-github-import-project": "/importers/github/import_project",
    "importers-asana-auth-url": "/importers/asana/auth_url",
    "importers-asana-authorize": "/importers/asana/authorize",
    "importers-asana-list-projects": "/importers/asana/list_projects",
    "importers-asana-list-users": "/importers/asana/list_users",
    "importers-asana-import-project": "/importers/asana/import_project"
  };

  initUrls = function($log, $urls) {
    $log.debug("Initialize api urls");
    return $urls.update(urls);
  };

  initResources = function($log, $rs) {
    var i, len, provider, providers, results;
    $log.debug("Initialize resources");
    providers = _.toArray(arguments).slice(2);
    results = [];
    for (i = 0, len = providers.length; i < len; i++) {
      provider = providers[i];
      results.push(provider($rs));
    }
    return results;
  };

  module = angular.module("taigaResources", ["taigaBase"]);

  module.service("$tgResources", ResourcesService);

  module.run(["$log", "$tgUrls", initUrls]);

  module.run(["$log", "$tgResources", "$tgProjectsResourcesProvider", "$tgCustomAttributesResourcesProvider", "$tgCustomAttributesValuesResourcesProvider", "$tgMembershipsResourcesProvider", "$tgNotifyPoliciesResourcesProvider", "$tgInvitationsResourcesProvider", "$tgRolesResourcesProvider", "$tgUserProjectSettingsResourcesProvider", "$tgUserSettingsResourcesProvider", "$tgSprintsResourcesProvider", "$tgEpicsResourcesProvider", "$tgUserstoriesResourcesProvider", "$tgTasksResourcesProvider", "$tgIssuesResourcesProvider", "$tgWikiResourcesProvider", "$tgSearchResourcesProvider", "$tgMdRenderResourcesProvider", "$tgHistoryResourcesProvider", "$tgKanbanResourcesProvider", "$tgModulesResourcesProvider", "$tgWebhooksResourcesProvider", "$tgWebhookLogsResourcesProvider", "$tgLocalesResourcesProvider", "$tgUsersResourcesProvider", initResources]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/search.coffee
 */

(function() {
  var SearchBoxDirective, SearchController, SearchDirective, bindOnce, debounce, debounceLeading, groupBy, mixOf, module, taiga, trim,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  mixOf = this.taiga.mixOf;

  debounceLeading = this.taiga.debounceLeading;

  trim = this.taiga.trim;

  debounce = this.taiga.debounce;

  module = angular.module("taigaSearch", []);

  SearchController = (function(superClass) {
    extend(SearchController, superClass);

    SearchController.$inject = ["$scope", "$tgRepo", "$tgResources", "$routeParams", "$q", "$tgLocation", "tgAppMetaService", "$tgNavUrls", "$translate", "tgErrorHandlingService", "tgProjectService"];

    function SearchController(scope1, repo, rs, params, q, location, appMetaService, navUrls, translate, errorHandlingService, projectService1) {
      var description, loadSearchData, title;
      this.scope = scope1;
      this.repo = repo;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.appMetaService = appMetaService;
      this.navUrls = navUrls;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService1;
      this.scope.sectionName = "Search";
      this.loadInitialData();
      title = this.translate.instant("SEARCH.PAGE_TITLE", {
        projectName: this.scope.project.name
      });
      description = this.translate.instant("SEARCH.PAGE_DESCRIPTION", {
        projectName: this.scope.project.name,
        projectDescription: this.scope.project.description
      });
      this.appMetaService.setAll(title, description);
      this.scope.searchTerm = null;
      loadSearchData = debounceLeading(100, (function(_this) {
        return function(t) {
          return _this.loadSearchData(t);
        };
      })(this));
      bindOnce(this.scope, "projectId", (function(_this) {
        return function(projectId) {
          if (!_this.scope.searchResults && _this.scope.searchTerm) {
            return _this.loadSearchData();
          }
        };
      })(this));
      this.scope.$watch("searchTerm", (function(_this) {
        return function(term) {
          if (term !== void 0 && _this.scope.projectId) {
            return _this.loadSearchData(term);
          }
        };
      })(this));
    }

    SearchController.prototype.loadFilters = function() {
      var defered;
      defered = this.q.defer();
      defered.resolve();
      return defered.promise;
    };

    SearchController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      this.scope.epicStatusById = groupBy(project.epic_statuses, function(x) {
        return x.id;
      });
      this.scope.issueStatusById = groupBy(project.issue_statuses, function(x) {
        return x.id;
      });
      this.scope.taskStatusById = groupBy(project.task_statuses, function(x) {
        return x.id;
      });
      this.scope.severityById = groupBy(project.severities, function(x) {
        return x.id;
      });
      this.scope.priorityById = groupBy(project.priorities, function(x) {
        return x.id;
      });
      this.scope.usStatusById = groupBy(project.us_statuses, function(x) {
        return x.id;
      });
      return project;
    };

    SearchController.prototype.loadSearchData = function(term) {
      if (term == null) {
        term = "";
      }
      this.scope.loading = true;
      return this._loadSearchData(term).then((function(_this) {
        return function(data) {
          _this.scope.searchResults = data;
          return _this.scope.loading = false;
        };
      })(this));
    };

    SearchController.prototype._loadSearchData = function(term) {
      if (term == null) {
        term = "";
      }
      if (this._promise) {
        this._promise.abort();
      }
      this._promise = this.rs.search["do"](this.scope.projectId, term);
      return this._promise;
    };

    SearchController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.scope.projectId = project.id;
      return this.fillUsersAndRoles(project.members, project.roles);
    };

    return SearchController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("SearchController", SearchController);

  SearchBoxDirective = function(projectService, $lightboxService, $navurls, $location, $route) {
    var link;
    link = function($scope, $el, $attrs) {
      var openLightbox, project, submit;
      project = null;
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var form, text, url;
          event.preventDefault();
          form = $el.find("form").checksley();
          if (!form.validate()) {
            return;
          }
          text = $el.find("#search-text").val();
          url = $navurls.resolve("project-search", {
            project: project.get("slug")
          });
          return $scope.$apply(function() {
            $lightboxService.close($el);
            $location.path(url);
            $location.search("text", text).path(url);
            return $route.reload();
          });
        };
      })(this));
      openLightbox = function() {
        project = projectService.project;
        return $lightboxService.open($el).then(function() {
          return $el.find("#search-text").focus();
        });
      };
      $el.on("submit", "form", submit);
      return openLightbox();
    };
    return {
      templateUrl: "search/lightbox-search.html",
      link: link
    };
  };

  SearchBoxDirective.$inject = ["tgProjectService", "lightboxService", "$tgNavUrls", "$tgLocation", "$route"];

  module.directive("tgSearchBox", SearchBoxDirective);

  SearchDirective = function($log, $compile, $templatecache, $routeparams, $location, $analytics) {
    var link, linkTable;
    linkTable = function($scope, $el, $attrs, $ctrl) {
      var activeSectionName, applyAutoTab, currentSearchResults, getActiveSection, markSectionTabActive, renderFilterTabs, renderTableContent, tabsDom, templates;
      applyAutoTab = true;
      activeSectionName = "userstories";
      tabsDom = $el.find(".search-filter");
      currentSearchResults = null;
      getActiveSection = function(data) {
        var i, len, maxVal, name, ref, selectedSection, value;
        maxVal = 0;
        selectedSection = {};
        selectedSection.name = "userstories";
        selectedSection.value = [];
        if (!applyAutoTab) {
          selectedSection.name = activeSectionName;
          selectedSection.value = data[activeSectionName];
          return selectedSection;
        }
        if (data) {
          ref = ["userstories", "epics", "issues", "tasks", "wikipages"];
          for (i = 0, len = ref.length; i < len; i++) {
            name = ref[i];
            value = data[name];
            if (value.length > maxVal) {
              maxVal = value.length;
              selectedSection.name = name;
              selectedSection.value = value;
              break;
            }
          }
        }
        if (maxVal === 0) {
          return selectedSection;
        }
        return selectedSection;
      };
      renderFilterTabs = function(data) {
        var name, results, value;
        results = [];
        for (name in data) {
          value = data[name];
          tabsDom.find("li." + name).show();
          results.push(tabsDom.find("li." + name + " .num").html(value.length));
        }
        return results;
      };
      markSectionTabActive = function(section) {
        tabsDom.find("a.active").removeClass("active");
        tabsDom.find("li." + section.name + " a").addClass("active");
        applyAutoTab = false;
        return activeSectionName = section.name;
      };
      templates = {
        epics: $templatecache.get("search-epics"),
        issues: $templatecache.get("search-issues"),
        tasks: $templatecache.get("search-tasks"),
        userstories: $templatecache.get("search-userstories"),
        wikipages: $templatecache.get("search-wikipages")
      };
      renderTableContent = function(section) {
        var element, oldElements, oldScope, scope, template;
        oldElements = $el.find(".search-result-table").children();
        oldScope = oldElements.scope();
        if (oldScope) {
          oldScope.$destroy();
          oldElements.remove();
        }
        scope = $scope.$new();
        scope[section.name] = section.value;
        template = angular.element.parseHTML(trim(templates[section.name]));
        element = $compile(template)(scope);
        return $el.find(".search-result-table").html(element);
      };
      $scope.$watch("searchResults", function(data) {
        var activeSection;
        currentSearchResults = data;
        if (!currentSearchResults) {
          return;
        }
        activeSection = getActiveSection(data);
        renderFilterTabs(data);
        renderTableContent(activeSection);
        return markSectionTabActive(activeSection);
      });
      $scope.$watch("searchTerm", function(searchTerm) {
        if (searchTerm !== void 0) {
          $location.search("text", searchTerm);
        }
        return $analytics.trackPage($location.url(), "Search");
      });
      return $el.on("click", ".search-filter li > a", function(event) {
        var section, sectionData, sectionName, target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        sectionName = target.parent().data("name");
        sectionData = !currentSearchResults ? [] : currentSearchResults[sectionName];
        section = {
          name: sectionName,
          value: sectionData
        };
        return $scope.$apply(function() {
          renderTableContent(section);
          return markSectionTabActive(section);
        });
      });
    };
    link = function($scope, $el, $attrs) {
      var $ctrl, searchText;
      $ctrl = $el.controller();
      linkTable($scope, $el, $attrs, $ctrl);
      searchText = $routeparams.text;
      return $scope.$watch("projectId", function(projectId) {
        if (projectId != null) {
          return $scope.searchTerm = searchText;
        }
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgSearch", ["$log", "$compile", "$templateCache", "$routeParams", "$tgLocation", "$tgAnalytics", SearchDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/taskboard.coffee
 */

(function() {
  var module;

  module = angular.module("taigaTaskboard", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/tasks.coffee
 */

(function() {
  var module;

  module = angular.module("taigaTasks", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/team.coffee
 */

(function() {
  var module;

  module = angular.module("taigaTeam", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings.coffee
 */

(function() {
  var module;

  module = angular.module("taigaUserSettings", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/userstories.coffee
 */

(function() {
  var module;

  module = angular.module("taigaUserStories", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/wiki.coffee
 */

(function() {
  var module;

  module = angular.module("taigaWiki", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/analytics.coffee
 */

(function() {
  var AnalyticsService, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  module = angular.module("taigaCommon");

  AnalyticsService = (function(superClass) {
    extend(AnalyticsService, superClass);

    AnalyticsService.$inject = ["$rootScope", "$log", "$tgConfig", "$window", "$document", "$location"];

    function AnalyticsService(rootscope, log, config, win, doc, location) {
      var conf;
      this.rootscope = rootscope;
      this.log = log;
      this.config = config;
      this.win = win;
      this.doc = doc;
      this.location = location;
      this.initialized = false;
      conf = this.config.get("analytics", {});
      this.accountId = conf.accountId;
      this.pageEvent = conf.pageEvent || "$routeChangeSuccess";
      this.trackRoutes = conf.trackRoutes || true;
      this.ignoreFirstPageLoad = conf.ignoreFirstPageLoad || false;
    }

    AnalyticsService.prototype.initialize = function() {
      if (!this.accountId) {
        this.log.debug("Analytics: no acount id provided. Disabling.");
        return;
      }
      this.injectAnalytics();
      this.win.ga("create", this.accountId, "auto");
      this.win.ga("require", "ec");
      this.win.ga("require", "displayfeatures");
      if (this.trackRoutes && (!this.ignoreFirstPageLoad)) {
        this.win.ga("send", "pageview", this.getUrl());
      }
      if (this.trackRoutes) {
        this.rootscope.$on(this.pageEvent, (function(_this) {
          return function() {
            return _this.trackPage(_this.getUrl(), "Taiga");
          };
        })(this));
      }
      this.initialized = true;
      return this.setUserId();
    };

    AnalyticsService.prototype.setUserId = function() {
      var ref, ref1;
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      return this.win.ga('set', 'userId', (ref = this.rootscope) != null ? (ref1 = ref.user) != null ? ref1.uuid : void 0 : void 0);
    };

    AnalyticsService.prototype.getUrl = function() {
      return this.location.path();
    };

    AnalyticsService.prototype.injectAnalytics = function() {
      var fn;
      fn = (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments);},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m);});
      return fn(window, document, "script", "//www.google-analytics.com/analytics.js", "ga");
    };

    AnalyticsService.prototype.trackPage = function(url, title) {
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      title = title || this.doc[0].title;
      return this.win.ga("send", "pageview", {
        "page": url,
        "title": title
      });
    };

    AnalyticsService.prototype.trackEvent = function(category, action, label, value) {
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      return this.win.ga("send", "event", category, action, label, value);
    };

    AnalyticsService.prototype.ecViewPlan = function(plan) {
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      this.win.ga('ec:addProduct', {
        'id': plan.plan_id,
        'name': plan.name,
        'category': "plans",
        'quantity': 1,
        'position': 1
      });
      this.win.ga('ec:setAction', 'detail');
      return this.trackEvent("ecommerce", "view-product-detail", plan.name, plan.plan_id);
    };

    AnalyticsService.prototype.ecClickPlan = function(plan) {
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      this.win.ga('ec:addProduct', {
        'id': plan.plan_id,
        'name': plan.name,
        'category': "plans",
        'quantity': 1,
        'position': 1
      });
      this.win.ga('ec:setAction', 'click');
      return this.trackEvent("ecommerce", "click-product", plan.name, plan.plan_id);
    };

    AnalyticsService.prototype.ecListPlans = function(arg, page) {
      var i, len, plan, plans, position;
      plans = arg[0];
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      position = 1;
      for (i = 0, len = plans.length; i < len; i++) {
        plan = plans[i];
        this.win.ga('ec:addImpression', {
          'id': plan.plan_id,
          'name': plan.name,
          'list': page,
          'position': position
        });
        position++;
      }
      return this.trackEvent("ecommerce", "list-plans");
    };

    AnalyticsService.prototype.ecAddToCart = function(plan_id, plan_name, plan_price) {
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      this.win.ga('ec:addProduct', {
        'id': plan_id,
        'name': plan_name,
        'price': plan_price,
        'category': "plans",
        'quantity': 1,
        'position': 1
      });
      this.win.ga('ec:setAction', 'add');
      return this.trackEvent('ecommerce', 'add-to-cart', 'Collect Payment Info', null);
    };

    AnalyticsService.prototype.ecConfirmChange = function(plan_id, plan_name, plan_price) {
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      this.win.ga('ec:addProduct', {
        'id': plan_id,
        'name': plan_name,
        'price': plan_price,
        'category': "plans",
        'quantity': 1,
        'position': 1
      });
      this.win.ga('ec:setAction', 'checkout', {
        'step': 1
      });
      return this.trackEvent("ecommerce", "start-checkout", "start", 1);
    };

    AnalyticsService.prototype.ecPurchase = function(plan_id, plan_name, plan_price) {
      if (!this.initialized) {
        return;
      }
      if (!this.win.ga) {
        return;
      }
      this.win.ga('ec:addProduct', {
        'id': plan_id,
        'name': plan_name,
        'price': plan_price,
        'category': "plans",
        'quantity': 1,
        'position': 1
      });
      this.win.ga('ec:setAction', 'checkout', {
        'step': 2
      });
      this.trackEvent("ecommerce", "end-checkout", "end", 2);
      this.win.ga('ec:addProduct', {
        'id': plan_id,
        'name': plan_name,
        'price': plan_price,
        'category': "plans",
        'quantity': 1,
        'position': 1
      });
      this.win.ga('ec:setAction', 'purchase', {
        'id': plan_id,
        'revenue': plan_price
      });
      return this.trackEvent('ecommerce', 'checkout', 'Plan checkout', null);
    };

    return AnalyticsService;

  })(taiga.Service);

  module.service("$tgAnalytics", AnalyticsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/bind-scope.coffee
 */

(function() {
  var BindScope, module;

  module = angular.module("taigaCommon");

  BindScope = function(config) {
    var link;
    if (!config.debugInfo) {
      jQuery.fn.scope = function() {
        return this.data('scope');
      };
    }
    link = function($scope, $el) {
      if (!config.debugInfo) {
        return $el.data('scope', $scope).addClass('tg-scope');
      }
    };
    return {
      link: link
    };
  };

  module.directive("tgBindScope", ["$tgConfig", BindScope]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/compile-html.directive.coffee
 */

(function() {
  var CompileHtmlDirective;

  CompileHtmlDirective = function($compile) {
    var link;
    link = function(scope, element, attrs) {
      return scope.$watch(attrs.tgCompileHtml, function(newValue, oldValue) {
        element.html(newValue);
        return $compile(element.contents())(scope);
      });
    };
    return {
      link: link
    };
  };

  CompileHtmlDirective.$inject = ["$compile"];

  angular.module("taigaCommon").directive("tgCompileHtml", CompileHtmlDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/components.coffee
 */

(function() {
  var BlockButtonDirective, CreatedByDisplayDirective, DateRangeDirective, DateSelectorDirective, DeleteButtonDirective, ListItemAssignedtoDirective, ListItemEpicStatusDirective, ListItemIssueStatusDirective, ListItemPriorityDirective, ListItemSeverityDirective, ListItemTaskStatusDirective, ListItemTypeDirective, ListItemUsStatusDirective, SprintProgressBarDirective, TgMainTitleDirective, TgProgressBarDirective, UserDisplayDirective, bindOnce, module, taiga;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaCommon");

  DateRangeDirective = function($translate) {
    var link, renderRange;
    renderRange = function($el, first, second) {
      var endDate, initDate, prettyDate;
      prettyDate = $translate.instant("BACKLOG.SPRINTS.DATE");
      initDate = moment(first).format(prettyDate);
      endDate = moment(second).format(prettyDate);
      return $el.html(initDate + "-" + endDate);
    };
    link = function($scope, $el, $attrs) {
      var first, ref, second;
      ref = $attrs.tgDateRange.split(","), first = ref[0], second = ref[1];
      return bindOnce($scope, first, function(valFirst) {
        return bindOnce($scope, second, function(valSecond) {
          return renderRange($el, valFirst, valSecond);
        });
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgDateRange", ["$translate", DateRangeDirective]);

  DateSelectorDirective = function($rootscope, datePickerConfigService) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var initialize, selectedDate, unbind;
      selectedDate = null;
      initialize = function() {
        var datePickerConfig;
        datePickerConfig = datePickerConfigService.get();
        _.merge(datePickerConfig, {
          field: $el[0]
        });
        return $el.picker = new Pikaday(datePickerConfig);
      };
      unbind = $rootscope.$on("$translateChangeEnd", (function(_this) {
        return function(ctx) {
          if ($el.picker) {
            $el.picker.destroy();
          }
          return initialize();
        };
      })(this));
      $attrs.$observe("pickerValue", function(val) {
        $el.val(val);
        if (val != null) {
          if ($el.picker) {
            $el.picker.destroy();
          }
          initialize();
        }
        return $el.picker.setDate(val);
      });
      return $scope.$on("$destroy", function() {
        $el.off();
        unbind();
        return $el.picker.destroy();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgDateSelector", ["$rootScope", "tgDatePickerConfigService", DateSelectorDirective]);

  SprintProgressBarDirective = function() {
    var link, renderProgress;
    renderProgress = function($el, percentage, visual_percentage) {
      if ($el.hasClass(".current-progress")) {
        return $el.css("width", percentage + "%");
      } else {
        $el.find(".current-progress").css("width", visual_percentage + "%");
        return $el.find(".number").html(percentage + " %");
      }
    };
    link = function($scope, $el, $attrs) {
      bindOnce($scope, $attrs.tgSprintProgressbar, function(sprint) {
        var closedPoints, percentage, totalPoints, visual_percentage;
        closedPoints = sprint.closed_points;
        totalPoints = sprint.total_points;
        percentage = 0;
        if (totalPoints !== 0) {
          percentage = Math.round(100 * (closedPoints / totalPoints));
        }
        visual_percentage = 0;
        if (totalPoints !== 0) {
          visual_percentage = Math.round(98 * (closedPoints / totalPoints));
        }
        return renderProgress($el, percentage, visual_percentage);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgSprintProgressbar", SprintProgressBarDirective);

  CreatedByDisplayDirective = function($template, $compile, $translate, $navUrls, avatarService) {
    var link;
    link = function($scope, $el, $attrs) {
      bindOnce($scope, $attrs.ngModel, function(model) {
        var avatar, ref;
        if (model != null) {
          avatar = avatarService.getAvatar(model.owner_extra_info);
          $scope.owner = model.owner_extra_info || {
            full_name_display: $translate.instant("COMMON.EXTERNAL_USER")
          };
          $scope.owner.avatar = avatar.url;
          $scope.owner.bg = avatar.bg;
          $scope.url = ((ref = $scope.owner) != null ? ref.is_active : void 0) ? $navUrls.resolve("user-profile", {
            username: $scope.owner.username
          }) : "";
          return $scope.date = moment(model.created_date).format($translate.instant("COMMON.DATETIME"));
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel",
      scope: true,
      templateUrl: "common/components/created-by.html"
    };
  };

  module.directive("tgCreatedByDisplay", ["$tgTemplate", "$compile", "$translate", "$tgNavUrls", "tgAvatarService", CreatedByDisplayDirective]);

  UserDisplayDirective = function($template, $compile, $translate, $navUrls, avatarService) {
    var link;
    link = function($scope, $el, $attrs) {
      var avatar, id;
      id = $attrs.tgUserId;
      $scope.user = $scope.usersById[id] || {
        full_name_display: $translate.instant("COMMON.EXTERNAL_USER")
      };
      avatar = avatarService.getAvatar($scope.usersById[id] || null);
      $scope.user.avatar = avatar.url;
      $scope.user.bg = avatar.bg;
      $scope.url = $scope.user.is_active ? $navUrls.resolve("user-profile", {
        username: $scope.user.username
      }) : "";
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      scope: true,
      templateUrl: "common/components/user-display.html"
    };
  };

  module.directive("tgUserDisplay", ["$tgTemplate", "$compile", "$translate", "$tgNavUrls", "tgAvatarService", UserDisplayDirective]);

  BlockButtonDirective = function($rootscope, $loading, $template) {
    var link, template;
    template = $template.get("common/components/block-button.html");
    link = function($scope, $el, $attrs, $model) {
      var isEditable;
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_us") !== -1;
      };
      $scope.$watch($attrs.ngModel, function(item) {
        if (!item) {
          return;
        }
        if (isEditable()) {
          $el.find('.item-block').addClass('editable');
        }
        if (item.is_blocked) {
          $el.find('.item-block').removeClass('is-active');
          return $el.find('.item-unblock').addClass('is-active');
        } else {
          $el.find('.item-block').addClass('is-active');
          return $el.find('.item-unblock').removeClass('is-active');
        }
      });
      $el.on("click", ".item-block", function(event) {
        event.preventDefault();
        return $rootscope.$broadcast("block", $model.$modelValue);
      });
      $el.on("click", ".item-unblock", function(event) {
        var currentLoading, finish;
        event.preventDefault();
        currentLoading = $loading().target($el.find(".item-unblock")).start();
        finish = function() {
          return currentLoading.finish();
        };
        return $rootscope.$broadcast("unblock", $model.$modelValue, finish);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel",
      template: template
    };
  };

  module.directive("tgBlockButton", ["$rootScope", "$tgLoading", "$tgTemplate", BlockButtonDirective]);

  DeleteButtonDirective = function($log, $repo, $confirm, $location, $template) {
    var link, template;
    template = $template.get("common/components/delete-button.html");
    link = function($scope, $el, $attrs, $model) {
      if (!$attrs.onDeleteGoToUrl) {
        return $log.error("DeleteButtonDirective requires on-delete-go-to-url set in scope.");
      }
      if (!$attrs.onDeleteTitle) {
        return $log.error("DeleteButtonDirective requires on-delete-title set in scope.");
      }
      $el.on("click", ".button-delete", function(event) {
        var subtitle, title;
        title = $attrs.onDeleteTitle;
        subtitle = $model.$modelValue.subject;
        return $confirm.askOnDelete(title, subtitle).then((function(_this) {
          return function(askResponse) {
            var promise;
            promise = $repo.remove($model.$modelValue);
            promise.then(function() {
              var url;
              askResponse.finish();
              url = $scope.$eval($attrs.onDeleteGoToUrl);
              return $location.path(url);
            });
            return promise.then(null, function() {
              askResponse.finish(false);
              return $confirm.notify("error");
            });
          };
        })(this));
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel",
      template: template
    };
  };

  module.directive("tgDeleteButton", ["$log", "$tgRepo", "$tgConfirm", "$tgLocation", "$tgTemplate", DeleteButtonDirective]);

  ListItemEpicStatusDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var epic;
      epic = $scope.$eval($attrs.tgListitemEpicStatus);
      return bindOnce($scope, "epicStatusById", function(epicStatusById) {
        return $el.html(epicStatusById[epic.status].name);
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgListitemEpicStatus", ListItemEpicStatusDirective);

  ListItemUsStatusDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var us;
      us = $scope.$eval($attrs.tgListitemUsStatus);
      return bindOnce($scope, "usStatusById", function(usStatusById) {
        return $el.html(usStatusById[us.status].name);
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgListitemUsStatus", ListItemUsStatusDirective);

  ListItemTaskStatusDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var task;
      task = $scope.$eval($attrs.tgListitemTaskStatus);
      return bindOnce($scope, "taskStatusById", function(taskStatusById) {
        return $el.html(taskStatusById[task.status].name);
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgListitemTaskStatus", ListItemTaskStatusDirective);

  ListItemAssignedtoDirective = function($template, $translate, avatarService) {
    var link, template;
    template = $template.get("common/components/list-item-assigned-to-avatar.html", true);
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, "usersById", function(usersById) {
        var avatar, ctx, item, member;
        item = $scope.$eval($attrs.tgListitemAssignedto);
        ctx = {
          name: $translate.instant("COMMON.ASSIGNED_TO.NOT_ASSIGNED")
        };
        member = usersById[item.assigned_to];
        avatar = avatarService.getAvatar(member);
        ctx.imgurl = avatar.url;
        ctx.bg = avatar.bg;
        if (member) {
          ctx.name = member.full_name_display;
        }
        return $el.html(template(ctx));
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgListitemAssignedto", ["$tgTemplate", "$translate", "tgAvatarService", ListItemAssignedtoDirective]);

  ListItemIssueStatusDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var issue;
      issue = $scope.$eval($attrs.tgListitemIssueStatus);
      return bindOnce($scope, "issueStatusById", function(issueStatusById) {
        return $el.html(issueStatusById[issue.status].name);
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgListitemIssueStatus", ListItemIssueStatusDirective);

  ListItemTypeDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var render;
      render = function(issueTypeById, issue) {
        var domNode, type;
        type = issueTypeById[issue.type];
        domNode = $el.find(".level");
        domNode.css("background-color", type.color);
        return domNode.attr("title", type.name);
      };
      bindOnce($scope, "issueTypeById", function(issueTypeById) {
        var issue;
        issue = $scope.$eval($attrs.tgListitemType);
        return render(issueTypeById, issue);
      });
      return $scope.$watch($attrs.tgListitemType, function(issue) {
        return render($scope.issueTypeById, issue);
      });
    };
    return {
      link: link,
      templateUrl: "common/components/level.html"
    };
  };

  module.directive("tgListitemType", ListItemTypeDirective);

  ListItemPriorityDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var render;
      render = function(priorityById, issue) {
        var domNode, priority;
        priority = priorityById[issue.priority];
        domNode = $el.find(".level");
        domNode.css("background-color", priority.color);
        return domNode.attr("title", priority.name);
      };
      bindOnce($scope, "priorityById", function(priorityById) {
        var issue;
        issue = $scope.$eval($attrs.tgListitemPriority);
        return render(priorityById, issue);
      });
      return $scope.$watch($attrs.tgListitemPriority, function(issue) {
        return render($scope.priorityById, issue);
      });
    };
    return {
      link: link,
      templateUrl: "common/components/level.html"
    };
  };

  module.directive("tgListitemPriority", ListItemPriorityDirective);

  ListItemSeverityDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var render;
      render = function(severityById, issue) {
        var domNode, severity;
        severity = severityById[issue.severity];
        domNode = $el.find(".level");
        domNode.css("background-color", severity.color);
        return domNode.attr("title", severity.name);
      };
      bindOnce($scope, "severityById", function(severityById) {
        var issue;
        issue = $scope.$eval($attrs.tgListitemSeverity);
        return render(severityById, issue);
      });
      return $scope.$watch($attrs.tgListitemSeverity, function(issue) {
        return render($scope.severityById, issue);
      });
    };
    return {
      link: link,
      templateUrl: "common/components/level.html"
    };
  };

  module.directive("tgListitemSeverity", ListItemSeverityDirective);

  TgProgressBarDirective = function($template) {
    var link, render, template;
    template = $template.get("common/components/progress-bar.html", true);
    render = function(el, percentage) {
      return el.html(template({
        percentage: percentage
      }));
    };
    link = function($scope, $el, $attrs) {
      var element;
      element = angular.element($el);
      $scope.$watch($attrs.tgProgressBar, function(percentage) {
        percentage = _.max([0, percentage]);
        percentage = _.min([100, percentage]);
        return render($el, percentage);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgProgressBar", ["$tgTemplate", TgProgressBarDirective]);

  TgMainTitleDirective = function($translate) {
    var link;
    link = function($scope, $el, $attrs) {
      $attrs.$observe("i18nSectionName", function(i18nSectionName) {
        return $scope.sectionName = i18nSectionName;
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      templateUrl: "common/components/main-title.html",
      scope: {
        projectName: "=projectName"
      }
    };
  };

  module.directive("tgMainTitle", ["$translate", TgMainTitleDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/confirm.coffee
 */

(function() {
  var ConfirmService, NOTIFICATION_MSG, bindMethods, cancelTimeout, debounce, module, taiga, timeout,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  timeout = this.taiga.timeout;

  cancelTimeout = this.taiga.cancelTimeout;

  debounce = this.taiga.debounce;

  bindMethods = this.taiga.bindMethods;

  NOTIFICATION_MSG = {
    "success": {
      title: "NOTIFICATION.OK",
      message: "NOTIFICATION.SAVED"
    },
    "error": {
      title: "NOTIFICATION.WARNING",
      message: "NOTIFICATION.WARNING_TEXT"
    },
    "light-error": {
      title: "NOTIFICATION.WARNING",
      message: "NOTIFICATION.WARNING_TEXT"
    }
  };

  ConfirmService = (function(superClass) {
    extend(ConfirmService, superClass);

    ConfirmService.$inject = ["$q", "lightboxService", "$tgLoading", "$translate", "$filter"];

    function ConfirmService(q, lightboxService, loading, translate, filter) {
      this.q = q;
      this.lightboxService = lightboxService;
      this.loading = loading;
      this.translate = translate;
      this.filter = filter;
      bindMethods(this);
    }

    ConfirmService.prototype.hide = function(el) {
      if (el) {
        this.lightboxService.close(el);
        return el.off(".confirm-dialog");
      }
    };

    ConfirmService.prototype.ask = function(title, subtitle, message, lightboxSelector) {
      var defered, el, onEsc;
      if (lightboxSelector == null) {
        lightboxSelector = ".lightbox-generic-ask";
      }
      defered = this.q.defer();
      el = angular.element(lightboxSelector);
      el.find(".title").text(title || '');
      el.find(".subtitle").text(subtitle || '');
      if (message) {
        message = this.filter('textToHTML')(message);
      }
      el.find(".message").html(message || '');
      el.on("click.confirm-dialog", ".button-green", debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, target;
          event.preventDefault();
          target = angular.element(event.currentTarget);
          currentLoading = _this.loading().target(target).start();
          return defered.resolve({
            finish: function(ok) {
              if (ok == null) {
                ok = true;
              }
              currentLoading.finish();
              if (ok) {
                return _this.hide(el);
              }
            }
          });
        };
      })(this)));
      el.on("click.confirm-dialog", ".button-red", (function(_this) {
        return function(event) {
          event.preventDefault();
          defered.reject();
          return _this.hide(el);
        };
      })(this));
      onEsc = (function(_this) {
        return function() {
          return _this.hide(el);
        };
      })(this);
      this.lightboxService.open(el, null, onEsc);
      return defered.promise;
    };

    ConfirmService.prototype.askOnDelete = function(title, message, subtitle) {
      if (subtitle == null) {
        subtitle = this.translate.instant("NOTIFICATION.ASK_DELETE");
      }
      return this.ask(title, subtitle, message);
    };

    ConfirmService.prototype.askChoice = function(title, subtitle, choices, replacement, warning, lightboxSelector) {
      var choicesField, defered, el;
      if (lightboxSelector == null) {
        lightboxSelector = ".lightbox-ask-choice";
      }
      defered = this.q.defer();
      el = angular.element(lightboxSelector);
      el.find(".title").text(title);
      el.find(".subtitle").text(subtitle);
      if (replacement) {
        el.find(".replacement").text(replacement);
      } else {
        el.find(".replacement").remove();
      }
      if (warning) {
        el.find(".warning").text(warning);
      } else {
        el.find(".warning").remove();
      }
      choicesField = el.find(".choices");
      choicesField.html('');
      _.each(choices, function(value, key) {
        value = _.escape(value);
        return choicesField.append(angular.element("<option value='" + key + "'>" + value + "</option>"));
      });
      el.on("click.confirm-dialog", "a.button-green", debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, target;
          event.preventDefault();
          target = angular.element(event.currentTarget);
          currentLoading = _this.loading().target(target).start();
          return defered.resolve({
            selected: choicesField.val(),
            finish: function(ok) {
              if (ok == null) {
                ok = true;
              }
              currentLoading.finish();
              if (ok) {
                return _this.hide(el);
              }
            }
          });
        };
      })(this)));
      el.on("click.confirm-dialog", ".button-red", (function(_this) {
        return function(event) {
          event.preventDefault();
          defered.reject();
          return _this.hide(el);
        };
      })(this));
      this.lightboxService.open(el);
      return defered.promise;
    };

    ConfirmService.prototype.error = function(message) {
      var defered, el;
      defered = this.q.defer();
      el = angular.element(".lightbox-generic-error");
      el.find(".title").html(message);
      el.on("click.confirm-dialog", ".button-green", (function(_this) {
        return function(event) {
          event.preventDefault();
          defered.resolve();
          return _this.hide(el);
        };
      })(this));
      el.on("click.confirm-dialog", ".close", (function(_this) {
        return function(event) {
          event.preventDefault();
          defered.resolve();
          return _this.hide(el);
        };
      })(this));
      this.lightboxService.open(el);
      return defered.promise;
    };

    ConfirmService.prototype.success = function(title, message, icon, action) {
      var defered, detailImage, el, svgContainer, useSVG;
      defered = this.q.defer();
      el = angular.element(".lightbox-generic-success");
      el.find("img").remove();
      el.find("svg").remove();
      if (icon) {
        if (icon.type === "img") {
          detailImage = $('<img>').addClass('lb-icon').attr('src', icon.name);
        } else if (icon.type === "svg") {
          detailImage = document.createElement("div");
          taiga.addClass(detailImage, "icon");
          taiga.addClass(detailImage, icon.name);
          taiga.addClass(detailImage, "lb-icon");
          svgContainer = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          useSVG = document.createElementNS('http://www.w3.org/2000/svg', 'use');
          useSVG.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + icon.name);
          detailImage.appendChild(svgContainer).appendChild(useSVG);
        }
        if (detailImage) {
          el.find('section').prepend(detailImage);
        }
      }
      if (title) {
        el.find(".title").html(title);
      }
      if (message) {
        el.find(".message").html(message);
      }
      if (action) {
        el.find(".button-green").html(action);
        el.find(".button-green").attr('title', action);
      }
      el.on("click.confirm-dialog", ".button-green", (function(_this) {
        return function(event) {
          event.preventDefault();
          defered.resolve();
          return _this.hide(el);
        };
      })(this));
      el.on("click.confirm-dialog", ".close", (function(_this) {
        return function(event) {
          event.preventDefault();
          defered.resolve();
          return _this.hide(el);
        };
      })(this));
      this.lightboxService.open(el);
      return defered.promise;
    };

    ConfirmService.prototype.loader = function(title, message, spin) {
      var el;
      if (spin == null) {
        spin = false;
      }
      el = angular.element(".lightbox-generic-loading");
      if (title) {
        el.find(".title").html(title);
      }
      if (message) {
        el.find(".message").html(message);
      }
      if (spin) {
        el.find(".spin").removeClass("hidden");
      }
      return {
        start: (function(_this) {
          return function() {
            return _this.lightboxService.open(el);
          };
        })(this),
        stop: (function(_this) {
          return function() {
            return _this.lightboxService.close(el);
          };
        })(this),
        update: (function(_this) {
          return function(status, title, message, percent) {
            if (title) {
              el.find(".title").html(title);
            }
            if (message) {
              el.find(".message").html(message);
            }
            if (percent) {
              el.find(".spin").addClass("hidden");
              el.find(".progress-bar-wrapper").removeClass("hidden");
              el.find(".progress-bar-wrapper > .bar").width(percent + '%');
              return el.find(".progress-bar-wrapper > span").html(percent + '%').css('left', (percent - 9) + '%');
            } else {
              el.find(".spin").removeClass("hidden");
              return el.find(".progress-bar-wrapper").addClass("hidden");
            }
          };
        })(this)
      };
    };

    ConfirmService.prototype.notify = function(type, message, title, time) {
      var body, el, selector;
      selector = ".notification-message-" + type;
      el = angular.element(selector);
      if (el.hasClass("active")) {
        return;
      }
      if (title) {
        el.find("h4").html(title);
      } else {
        el.find("h4").html(this.translate.instant(NOTIFICATION_MSG[type].title));
      }
      if (message) {
        el.find("p").html(message);
      } else {
        el.find("p").html(this.translate.instant(NOTIFICATION_MSG[type].message));
      }
      body = angular.element("body");
      body.find(".notification-message .notification-light").removeClass('active').addClass('inactive');
      body.find(selector).removeClass('inactive').addClass('active');
      if (this.tsem) {
        cancelTimeout(this.tsem);
      }
      if (!time) {
        time = type === 'error' || type === 'light-error' ? 3500 : 1500;
      }
      this.tsem = timeout(time, (function(_this) {
        return function() {
          body.find(selector).removeClass('active').addClass('inactive').one('animationend', function() {
            return $(this).removeClass('inactive');
          });
          return delete _this.tsem;
        };
      })(this));
      return el.on("click", ".icon-close, .close", (function(_this) {
        return function(event) {
          return body.find(selector).removeClass('active').addClass('inactive');
        };
      })(this));
    };

    return ConfirmService;

  })(taiga.Service);

  module = angular.module("taigaCommon");

  module.service("$tgConfirm", ConfirmService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/custom-field-values.coffee
 */

(function() {
  var CHECKBOX_TYPE, CustomAttributeValueDirective, CustomAttributesValuesController, CustomAttributesValuesDirective, DATE_TYPE, DROPDOWN_TYPE, MULTILINE_TYPE, NUMBER_TYPE, RICHTEXT_TYPE, TEXT_TYPE, TYPE_CHOICES, URL_TYPE, bindMethods, bindOnce, debounce, generateHash, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  bindMethods = this.taiga.bindMethods;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  generateHash = taiga.generateHash;

  module = angular.module("taigaCommon");

  TEXT_TYPE = "text";

  RICHTEXT_TYPE = "url";

  MULTILINE_TYPE = "multiline";

  DATE_TYPE = "date";

  URL_TYPE = "url";

  DROPDOWN_TYPE = "dropdown";

  CHECKBOX_TYPE = "checkbox";

  NUMBER_TYPE = "number";

  TYPE_CHOICES = [
    {
      key: TEXT_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_TEXT"
    }, {
      key: MULTILINE_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_MULTI"
    }, {
      key: DATE_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_DATE"
    }, {
      key: URL_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_URL"
    }, {
      key: RICHTEXT_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_RICHTEXT"
    }, {
      key: DROPDOWN_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_DROPDOWN"
    }, {
      key: CHECKBOX_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_CHECKBOX"
    }, {
      key: NUMBER_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_NUMBER"
    }
  ];

  CustomAttributesValuesController = (function(superClass) {
    extend(CustomAttributesValuesController, superClass);

    CustomAttributesValuesController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgResources", "$tgConfirm", "$q"];

    function CustomAttributesValuesController(scope1, rootscope, repo, rs, confirm, q) {
      this.scope = scope1;
      this.rootscope = rootscope;
      this.repo = repo;
      this.rs = rs;
      this.confirm = confirm;
      this.q = q;
      bindMethods(this);
      this.type = null;
      this.objectId = null;
      this.projectId = null;
      this.customAttributes = [];
      this.customAttributesValues = null;
    }

    CustomAttributesValuesController.prototype.initialize = function(type, objectId) {
      this.project = this.scope.project;
      this.type = type;
      this.objectId = objectId;
      return this.projectId = this.scope.projectId;
    };

    CustomAttributesValuesController.prototype.loadCustomAttributesValues = function() {
      if (!this.objectId) {
        return this.customAttributesValues;
      }
      return this.rs.customAttributesValues[this.type].get(this.objectId).then((function(_this) {
        return function(customAttributesValues) {
          _this.customAttributes = _this.project[_this.type + "_custom_attributes"];
          _this.customAttributesValues = customAttributesValues;
          return customAttributesValues;
        };
      })(this));
    };

    CustomAttributesValuesController.prototype.getAttributeValue = function(attribute) {
      var attributeValue;
      attributeValue = _.clone(attribute, false);
      attributeValue.value = this.customAttributesValues.attributes_values[attribute.id];
      return attributeValue;
    };

    CustomAttributesValuesController.prototype.updateAttributeValue = function(attributeValue) {
      var attributesValues, onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          return _this.rootscope.$broadcast("custom-attributes-values:edit");
        };
      })(this);
      onError = (function(_this) {
        return function(response) {
          _this.confirm.notify("error");
          return _this.q.reject();
        };
      })(this);
      attributesValues = _.clone(this.customAttributesValues.attributes_values, true);
      attributesValues[attributeValue.id] = attributeValue.value;
      this.customAttributesValues.attributes_values = attributesValues;
      this.customAttributesValues.id = this.objectId;
      return this.repo.save(this.customAttributesValues).then(onSuccess, onError);
    };

    return CustomAttributesValuesController;

  })(taiga.Controller);

  CustomAttributesValuesDirective = function($templates, $storage) {
    var collapsedHash, link, template, templateFn;
    template = $templates.get("custom-attributes/custom-attributes-values.html", true);
    collapsedHash = function(type) {
      return generateHash(["custom-attributes-collapsed", type]);
    };
    link = function($scope, $el, $attrs, $ctrls) {
      var $ctrl, $model, hash;
      $ctrl = $ctrls[0];
      $model = $ctrls[1];
      hash = collapsedHash($attrs.type);
      $scope.collapsed = $storage.get(hash) || false;
      bindOnce($scope, $attrs.ngModel, function(value) {
        $ctrl.initialize($attrs.type, value.id);
        return $ctrl.loadCustomAttributesValues();
      });
      $scope.toggleCollapse = function() {
        $scope.collapsed = !$scope.collapsed;
        return $storage.set(hash, $scope.collapsed);
      };
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    templateFn = function($el, $attrs) {
      return template({
        requiredEditionPerm: $attrs.requiredEditionPerm
      });
    };
    return {
      require: ["tgCustomAttributesValues", "ngModel"],
      controller: CustomAttributesValuesController,
      controllerAs: "ctrl",
      restrict: "AE",
      scope: true,
      link: link,
      template: templateFn
    };
  };

  module.directive("tgCustomAttributesValues", ["$tgTemplate", "$tgStorage", "$translate", CustomAttributesValuesDirective]);

  CustomAttributeValueDirective = function($template, $selectedText, $compile, $translate, datePickerConfigService, wysiwygService) {
    var link, template, templateEdit;
    template = $template.get("custom-attributes/custom-attribute-value.html", true);
    templateEdit = $template.get("custom-attributes/custom-attribute-value-edit.html", true);
    link = function($scope, $el, $attrs, $ctrl) {
      var attributeValue, isEditable, prettyDate, render, setFocusAndSelectOnInputField, submit;
      prettyDate = $translate.instant("COMMON.PICKERDATE.FORMAT");
      render = function(attributeValue, edit) {
        var ctx, datePickerConfig, editable, html, scope, value;
        if (edit == null) {
          edit = false;
        }
        if (attributeValue.type === DATE_TYPE && attributeValue.value) {
          value = moment(attributeValue.value, "YYYY-MM-DD").format(prettyDate);
        }
        if (attributeValue.type === NUMBER_TYPE && attributeValue.value) {
          value = parseFloat(attributeValue.value);
        } else {
          value = attributeValue.value;
        }
        editable = isEditable();
        ctx = {
          id: attributeValue.id,
          name: attributeValue.name,
          description: attributeValue.description,
          value: value,
          type: attributeValue.type,
          isEditable: editable
        };
        scope = $scope.$new();
        scope.attributeHtml = wysiwygService.getHTML(value);
        scope.extra = attributeValue.extra;
        scope.model = value;
        if (editable && (edit || !value)) {
          html = templateEdit(ctx);
          html = $compile(html)(scope);
          $el.html(html);
          if (attributeValue.type === DATE_TYPE) {
            datePickerConfig = datePickerConfigService.get();
            _.merge(datePickerConfig, {
              field: $el.find("input[name=value]")[0],
              onSelect: (function(_this) {
                return function(date) {
                  var selectedDate;
                  return selectedDate = date;
                };
              })(this),
              onOpen: (function(_this) {
                return function() {
                  if (typeof selectedDate !== "undefined" && selectedDate !== null) {
                    return $el.picker.setDate(selectedDate);
                  }
                };
              })(this)
            });
            return $el.picker = new Pikaday(datePickerConfig);
          }
        } else {
          html = template(ctx);
          html = $compile(html)(scope);
          return $el.html(html);
        }
      };
      isEditable = function() {
        var permissions, requiredEditionPerm;
        permissions = $scope.project.my_permissions;
        requiredEditionPerm = $attrs.requiredEditionPerm;
        return permissions.indexOf(requiredEditionPerm) > -1;
      };
      $scope.saveCustomRichText = (function(_this) {
        return function(markdown, callback) {
          attributeValue.value = markdown;
          return $ctrl.updateAttributeValue(attributeValue).then(function() {
            callback();
            return render(attributeValue, false);
          });
        };
      })(this);
      $scope.cancelCustomRichText = (function(_this) {
        return function() {
          render(attributeValue, false);
          return null;
        };
      })(this);
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var form, formControl;
          event.preventDefault();
          form = $el.find("form").checksley();
          if (!form.validate()) {
            return;
          }
          if (attributeValue.type === DROPDOWN_TYPE) {
            formControl = $el.find("select[name='value']");
            attributeValue.value = formControl.val();
          } else if (attributeValue.type === CHECKBOX_TYPE) {
            formControl = $el.find("input[name=value]");
            attributeValue.value = formControl[0].checked;
          } else {
            formControl = $el.find("input[name=value], textarea[name='value']");
            attributeValue.value = formControl.val();
            if (attributeValue.type === DATE_TYPE && moment(attributeValue.value, prettyDate).isValid()) {
              attributeValue.value = moment(attributeValue.value, prettyDate).format("YYYY-MM-DD");
            }
            if (attributeValue.type === NUMBER_TYPE) {
              attributeValue.value = parseFloat(attributeValue.value);
            }
          }
          return $scope.$apply(function() {
            return $ctrl.updateAttributeValue(attributeValue).then(function() {
              return render(attributeValue, false);
            });
          });
        };
      })(this));
      setFocusAndSelectOnInputField = function() {
        return $el.find("input[name='value'], textarea[name='value']").focus().select();
      };
      attributeValue = $scope.$eval($attrs.tgCustomAttributeValue);
      if (attributeValue.value === null || attributeValue.value === void 0) {
        attributeValue.value = "";
      }
      $scope.customAttributeValue = attributeValue;
      render(attributeValue);
      $el.on("click", ".js-value-view-mode span a", function(event) {
        return event.stopPropagation();
      });
      $el.on("click", ".js-value-view-mode", function() {
        if (!isEditable()) {
          return;
        }
        if ($selectedText.get().length) {
          return;
        }
        render(attributeValue, true);
        return setFocusAndSelectOnInputField();
      });
      $el.on("click", ".js-edit-description", function(event) {
        event.preventDefault();
        render(attributeValue, true);
        return setFocusAndSelectOnInputField();
      });
      $el.on("keyup", "input[name=value], textarea[name='value']", function(event) {
        if (event.keyCode === 13 && event.currentTarget.type !== "textarea") {
          return submit(event);
        } else if (event.keyCode === 27) {
          return render(attributeValue, false);
        }
      });
      $el.on("submit", "form", submit);
      $el.on("click", ".js-save-description", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      require: "^tgCustomAttributesValues",
      restrict: "AE"
    };
  };

  module.directive("tgCustomAttributeValue", ["$tgTemplate", "$selectedText", "$compile", "$translate", "tgDatePickerConfigService", "tgWysiwygService", CustomAttributeValueDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/emojis.coffee
 */

(function() {
  var EmojisService, module, taiga,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  module = angular.module("taigaCommon");

  EmojisService = (function(superClass) {
    extend(EmojisService, superClass);

    EmojisService.$inject = [];

    function EmojisService() {
      this.replaceEmojiNameByHtmlImgs = bind(this.replaceEmojiNameByHtmlImgs, this);
      this.replaceEmojiNameByImgs = bind(this.replaceEmojiNameByImgs, this);
      this.replaceImgsByEmojiName = bind(this.replaceImgsByEmojiName, this);
      this.getEmojiByName = bind(this.getEmojiByName, this);
      this.getEmojiById = bind(this.getEmojiById, this);
      this.searchByName = bind(this.searchByName, this);
      this.emojis = _.map(taiga.emojis, function(it) {
        it.image = ("/" + window._version + "/emojis/") + it.image;
        return it;
      });
      this.emojisById = _.keyBy(this.emojis, 'id');
      this.emojisByName = _.keyBy(this.emojis, 'name');
    }

    EmojisService.prototype.searchByName = function(name) {
      return _.filter(this.emojis, function(it) {
        return it.name.indexOf(name) !== -1;
      });
    };

    EmojisService.prototype.getEmojiById = function(id) {
      return this.emojisById[id];
    };

    EmojisService.prototype.getEmojiByName = function(name) {
      return this.emojisByName[name];
    };

    EmojisService.prototype.replaceImgsByEmojiName = function(html) {
      var emoji, emojiId, emojiIds, i, len, regexImgs;
      emojiIds = taiga.getMatches(html, /emojis\/([^"]+).png"/gi);
      for (i = 0, len = emojiIds.length; i < len; i++) {
        emojiId = emojiIds[i];
        regexImgs = new RegExp('<img(.*)' + emojiId + '[^>]+\>', 'g');
        emoji = this.getEmojiById(emojiId);
        html = html.replace(regexImgs, ':' + emoji.name + ':');
      }
      return html;
    };

    EmojisService.prototype.replaceEmojiNameByImgs = function(text) {
      var emoji, emojiId, emojiIds, i, len, regexImgs;
      emojiIds = taiga.getMatches(text, /:([\w +-]*):/g);
      for (i = 0, len = emojiIds.length; i < len; i++) {
        emojiId = emojiIds[i];
        regexImgs = new RegExp(':' + emojiId + ':', 'g');
        emoji = this.getEmojiByName(emojiId);
        if (emoji) {
          text = text.replace(regexImgs, '![alt](' + emoji.image + ')');
        }
      }
      return text;
    };

    EmojisService.prototype.replaceEmojiNameByHtmlImgs = function(text) {
      var emoji, emojiId, emojiIds, i, len, regexImgs;
      emojiIds = taiga.getMatches(text, /:([\w +-]*):/g);
      for (i = 0, len = emojiIds.length; i < len; i++) {
        emojiId = emojiIds[i];
        regexImgs = new RegExp(':' + _.escapeRegExp(emojiId) + ':', 'g');
        emoji = this.getEmojiByName(emojiId);
        if (emoji) {
          text = text.replace(regexImgs, '<img src="' + emoji.image + '" />');
        }
      }
      return text;
    };

    return EmojisService;

  })(taiga.Service);

  module.service("$tgEmojis", EmojisService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/estimation.coffee
 */

(function() {
  var EstimationsService, LbUsEstimationDirective, UsEstimationDirective, groupBy, module, taiga,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  taiga = this.taiga;

  groupBy = this.taiga.groupBy;

  module = angular.module("taigaCommon");

  LbUsEstimationDirective = function($tgEstimationsService, $rootScope, $repo, $template, $compile) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      $scope.$watch($attrs.ngModel, function(us) {
        var estimationProcess;
        if (us) {
          estimationProcess = $tgEstimationsService.create($el, us, $scope.project);
          estimationProcess.onSelectedPointForRole = function(roleId, pointId, points) {
            us.points = points;
            estimationProcess.render();
            return $scope.$apply(function() {
              return $model.$setViewValue(us);
            });
          };
          estimationProcess.render = function() {
            var ctx, html, mainTemplate, template;
            ctx = {
              totalPoints: this.calculateTotalPoints(),
              roles: this.calculateRoles(),
              editable: this.isEditable,
              loading: false
            };
            mainTemplate = "common/estimation/us-estimation-points-per-role.html";
            template = $template.get(mainTemplate, true);
            html = template(ctx);
            html = $compile(html)($scope);
            return this.$el.html(html);
          };
          return estimationProcess.render();
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgLbUsEstimation", ["$tgEstimationsService", "$rootScope", "$tgRepo", "$tgTemplate", "$compile", LbUsEstimationDirective]);

  UsEstimationDirective = function($tgEstimationsService, $rootScope, $repo, $template, $compile, $modelTransform, $confirm) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var save;
      save = function(points) {
        var onError, transform;
        transform = $modelTransform.save((function(_this) {
          return function(us) {
            us.points = points;
            return us;
          };
        })(this));
        onError = (function(_this) {
          return function() {
            return $confirm.notify("error");
          };
        })(this);
        return transform.then(null, onError);
      };
      $scope.$watchCollection(function() {
        return $model.$modelValue && $model.$modelValue.points;
      }, function() {
        var estimationProcess, us;
        us = $model.$modelValue;
        if (us) {
          estimationProcess = $tgEstimationsService.create($el, us, $scope.project);
          estimationProcess.onSelectedPointForRole = function(roleId, pointId, points) {
            estimationProcess.loading = roleId;
            estimationProcess.render();
            return save(points).then(function() {
              estimationProcess.loading = false;
              $rootScope.$broadcast("object:updated");
              return estimationProcess.render();
            });
          };
          estimationProcess.render = function() {
            var ctx, html, mainTemplate, template;
            ctx = {
              totalPoints: this.calculateTotalPoints(),
              roles: this.calculateRoles(),
              editable: this.isEditable,
              loading: estimationProcess.loading
            };
            mainTemplate = "common/estimation/us-estimation-points-per-role.html";
            template = $template.get(mainTemplate, true);
            html = template(ctx);
            html = $compile(html)($scope);
            return this.$el.html(html);
          };
          return estimationProcess.render();
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgUsEstimation", ["$tgEstimationsService", "$rootScope", "$tgRepo", "$tgTemplate", "$compile", "$tgQueueModelTransformation", "$tgConfirm", UsEstimationDirective]);

  EstimationsService = function($template, $repo, $confirm, $q, $qqueue) {
    var EstimationProcess, create, pointsTemplate;
    pointsTemplate = $template.get("common/estimation/us-estimation-points.html", true);
    EstimationProcess = (function() {
      function EstimationProcess($el1, us1, project1) {
        this.$el = $el1;
        this.us = us1;
        this.project = project1;
        this.bindClickEvents = bind(this.bindClickEvents, this);
        this.isEditable = this.project.my_permissions.indexOf("modify_us") !== -1;
        this.roles = this.project.roles;
        this.points = this.project.points;
        this.loading = false;
        this.pointsById = groupBy(this.points, function(x) {
          return x.id;
        });
        this.onSelectedPointForRole = function(roleId, pointId) {};
        this.render = function() {};
      }

      EstimationProcess.prototype.save = function(roleId, pointId) {
        var deferred;
        deferred = $q.defer();
        $qqueue.add((function(_this) {
          return function() {
            var onError, onSuccess;
            onSuccess = function() {
              deferred.resolve();
              return _this.render();
            };
            onError = function() {
              $confirm.notify("error");
              _this.us.revert();
              _this.render();
              return deferred.reject();
            };
            return $repo.save(_this.us).then(onSuccess, onError);
          };
        })(this));
        return deferred.promise;
      };

      EstimationProcess.prototype.calculateTotalPoints = function() {
        var notNullValues, values;
        values = _.map(this.us.points, (function(_this) {
          return function(v, k) {
            var ref;
            return (ref = _this.pointsById[v]) != null ? ref.value : void 0;
          };
        })(this));
        if (values.length === 0) {
          return "?";
        }
        notNullValues = _.filter(values, function(v) {
          return v != null;
        });
        if (notNullValues.length === 0) {
          return "?";
        }
        return _.reduce(notNullValues, function(acc, num) {
          return acc + num;
        });
      };

      EstimationProcess.prototype.calculateRoles = function() {
        var computableRoles, roles;
        computableRoles = _.filter(this.project.roles, "computable");
        roles = _.map(computableRoles, (function(_this) {
          return function(role) {
            var pointId, pointObj;
            pointId = _this.us.points[role.id];
            pointObj = _this.pointsById[pointId];
            role = _.clone(role, true);
            role.points = (pointObj != null) && (pointObj.name != null) ? pointObj.name : "?";
            return role;
          };
        })(this));
        return roles;
      };

      EstimationProcess.prototype.bindClickEvents = function() {
        this.$el.on("click", ".total.clickable", (function(_this) {
          return function(event) {
            var roleId, target;
            event.preventDefault();
            event.stopPropagation();
            target = angular.element(event.currentTarget);
            roleId = target.data("role-id");
            _this.renderPointsSelector(roleId, target);
            target.siblings().removeClass('active');
            return target.addClass('active');
          };
        })(this));
        return this.$el.on("click", ".point", (function(_this) {
          return function(event) {
            var pointId, points, roleId, target;
            event.preventDefault();
            event.stopPropagation();
            target = angular.element(event.currentTarget);
            roleId = target.data("role-id");
            pointId = target.data("point-id");
            _this.$el.find(".popover").popover().close();
            points = _.clone(_this.us.points, true);
            points[roleId] = pointId;
            return _this.onSelectedPointForRole(roleId, pointId, points);
          };
        })(this));
      };

      EstimationProcess.prototype.renderPointsSelector = function(roleId, target) {
        var horizontalList, html, maxPointLength, points, pop;
        points = _.map(this.points, (function(_this) {
          return function(point) {
            point = _.clone(point, true);
            point.selected = _this.us.points[roleId] === point.id ? false : true;
            return point;
          };
        })(this));
        maxPointLength = 5;
        horizontalList = _.some(points, (function(_this) {
          return function(point) {
            return point.name.length > maxPointLength;
          };
        })(this));
        html = pointsTemplate({
          "points": points,
          roleId: roleId,
          horizontal: horizontalList
        });
        this.$el.find(".popover").popover().close();
        this.$el.find(".pop-points-open").remove();
        if (target != null) {
          this.$el.find(target).append(html);
        } else {
          this.$el.append(html);
        }
        this.$el.find(".pop-points-open").popover().open(function() {
          return $(this).removeClass("active").closest("li").removeClass("active");
        });
        this.$el.find(".pop-points-open").show();
        pop = this.$el.find(".pop-points-open");
        if (pop.offset().top + pop.height() > document.body.clientHeight) {
          return pop.addClass('pop-bottom');
        }
      };

      return EstimationProcess;

    })();
    create = function($el, us, project) {
      var estimationProcess;
      $el.unbind("click");
      estimationProcess = new EstimationProcess($el, us, project);
      if (estimationProcess.isEditable) {
        estimationProcess.bindClickEvents();
      }
      return estimationProcess;
    };
    return {
      create: create
    };
  };

  module.factory("$tgEstimationsService", ["$tgTemplate", "$tgRepo", "$tgConfirm", "$q", "$tgQqueue", EstimationsService]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/filters.coffee
 */

(function() {
  var byRefFilter, darkerFilter, defaultFilter, emojify, inArray, markdownToHTML, module, momentFormat, momentFromNow, sizeFormat, taiga, textToHTML, toMutableFilter, unslugify, yesNoFilter;

  taiga = this.taiga;

  module = angular.module("taigaCommon");

  defaultFilter = function() {
    return function(value, defaultValue) {
      if (value === [null, void 0]) {
        return defaultValue;
      }
      return value;
    };
  };

  module.filter("default", defaultFilter);

  yesNoFilter = function($translate) {
    return function(value) {
      if (value) {
        return $translate.instant("COMMON.YES");
      }
      return $translate.instant("COMMON.NO");
    };
  };

  module.filter("yesNo", ["$translate", yesNoFilter]);

  unslugify = function() {
    return taiga.unslugify;
  };

  module.filter("unslugify", unslugify);

  momentFormat = function() {
    return function(input, format) {
      if (input) {
        return moment(input).format(format);
      }
      return "";
    };
  };

  module.filter("momentFormat", momentFormat);

  momentFromNow = function() {
    return function(input, without_suffix) {
      if (input) {
        return moment(input).fromNow(without_suffix || false);
      }
      return "";
    };
  };

  module.filter("momentFromNow", momentFromNow);

  sizeFormat = (function(_this) {
    return function() {
      return _this.taiga.sizeFormat;
    };
  })(this);

  module.filter("sizeFormat", sizeFormat);

  toMutableFilter = function() {
    var memoizedMutable, toMutable;
    toMutable = function(js) {
      return js.toJS();
    };
    memoizedMutable = _.memoize(toMutable);
    return function(input) {
      if (input instanceof Immutable.List) {
        return memoizedMutable(input);
      }
      return input;
    };
  };

  module.filter("toMutable", toMutableFilter);

  byRefFilter = function($filterFilter) {
    return function(userstories, filter) {
      var cleanRef;
      if (filter != null ? filter.startsWith("#") : void 0) {
        cleanRef = filter.substr(1);
        return _.filter(userstories, (function(_this) {
          return function(us) {
            return String(us.ref).startsWith(cleanRef);
          };
        })(this));
      }
      return $filterFilter(userstories, filter);
    };
  };

  module.filter("byRef", ["filterFilter", byRefFilter]);

  darkerFilter = function() {
    return function(color, luminosity) {
      var black, c, i, j, len, newColor, ref, white;
      color = new String(color).replace(/[^0-9a-f]/gi, '');
      if (color.length < 6) {
        color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];
      }
      luminosity = luminosity || 0;
      newColor = "#";
      c = 0;
      i = 0;
      black = 0;
      white = 255;
      ref = [0, 1, 2];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        c = parseInt(color.substr(i * 2, 2), 16);
        c = Math.round(Math.min(Math.max(black, c + (luminosity * white)), white)).toString(16);
        newColor += ("00" + c).substr(c.length);
      }
      return newColor;
    };
  };

  module.filter("darker", darkerFilter);

  markdownToHTML = function(wysiwigService) {
    return function(input) {
      if (input) {
        return wysiwigService.getHTML(input);
      }
      return "";
    };
  };

  module.filter("markdownToHTML", ["tgWysiwygService", markdownToHTML]);

  inArray = function($filter) {
    return function(list, arrayFilter, element) {
      var filter;
      if (arrayFilter) {
        filter = $filter("filter");
        return filter(list, function(listItem) {
          return arrayFilter.indexOf(listItem[element]) !== -1;
        });
      }
    };
  };

  module.filter("inArray", ["$filter", inArray]);

  emojify = function($emojis) {
    return function(input) {
      if (input) {
        return $emojis.replaceEmojiNameByHtmlImgs(_.escape(input));
      }
      return "";
    };
  };

  module.filter("emojify", ["$tgEmojis", emojify]);

  textToHTML = function($filter) {
    return function(input) {
      if (input) {
        return input.replace(/\<(?!(\/?)(strong|br)(\/?)).*?\>/g, "");
      }
      return "";
    };
  };

  module.filter("textToHTML", ["$filter", textToHTML]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/lightboxes.coffee
 */

(function() {
  var BlockLightboxDirective, BlockingMessageInputDirective, CreateBulkUserstoriesDirective, CreateEditDirective, LightboxDirective, LightboxKeyboardNavigationService, LightboxLeaveProjectWarningDirective, LightboxService, RelateToEpicLightboxDirective, SetDueDateDirective, bindOnce, debounce, debounceLeading, groupBy, module, normalizeString, sizeFormat, timeout, trim,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module = angular.module("taigaCommon");

  bindOnce = this.taiga.bindOnce;

  timeout = this.taiga.timeout;

  debounce = this.taiga.debounce;

  sizeFormat = this.taiga.sizeFormat;

  trim = this.taiga.trim;

  normalizeString = this.taiga.normalizeString;

  LightboxService = (function(superClass) {
    extend(LightboxService, superClass);

    function LightboxService(animationFrame, q, rootScope) {
      this.animationFrame = animationFrame;
      this.q = q;
      this.rootScope = rootScope;
    }

    LightboxService.prototype.open = function($el, onClose, onEsc, ignoreEsc) {
      var defered, docEl, lightboxContent;
      this.onClose = onClose;
      if (_.isString($el)) {
        $el = $($el);
      }
      defered = this.q.defer();
      lightboxContent = $el.children().not(".close");
      lightboxContent.hide();
      this.animationFrame.add(function() {
        return $el.css('display', 'flex');
      });
      this.animationFrame.add(function() {
        $el.addClass("open");
        return $el.one("transitionend", (function(_this) {
          return function() {
            var firstField;
            firstField = $el.find('input:not(.no-focus),textarea:not(.no-focus)').first();
            if (firstField.length) {
              return firstField.focus();
            } else if (document.activeElement) {
              return $(document.activeElement).blur();
            }
          };
        })(this));
      });
      this.animationFrame.add((function(_this) {
        return function() {
          lightboxContent.show();
          return defered.resolve();
        };
      })(this));
      if (!ignoreEsc) {
        docEl = angular.element(document);
        docEl.on("keydown.lightbox", (function(_this) {
          return function(e) {
            var code;
            code = e.keyCode ? e.keyCode : e.which;
            if (code === 27) {
              if (onEsc) {
                return _this.rootScope.$applyAsync(onEsc);
              } else {
                return _this.close($el);
              }
            }
          };
        })(this));
      }
      return defered.promise;
    };

    LightboxService.prototype.close = function($el) {
      return new Promise((function(_this) {
        return function(resolve) {
          var docEl, scope;
          if (_.isString($el)) {
            $el = $($el);
          }
          docEl = angular.element(document);
          docEl.off(".lightbox");
          docEl.off(".keyboard-navigation");
          $el.addClass('close-started');
          _this.animationFrame.add(function() {
            $el.addClass('close');
            return $el.one("transitionend", function() {
              $el.removeAttr('style');
              $el.removeClass("open").removeClass('close').removeClass('close-started');
              if (_this.onClose) {
                _this.rootScope.$apply(_this.onClose);
              }
              return resolve();
            });
          });
          if ($el.hasClass("remove-on-close")) {
            scope = $el.data("scope");
            if (scope) {
              scope.$destroy();
            }
            return $el.remove();
          }
        };
      })(this));
    };

    LightboxService.prototype.getLightboxOpen = function() {
      return $(".lightbox.open:not(.close-started)");
    };

    LightboxService.prototype.closeAll = function() {
      var docEl, i, len, lightboxEl, ref, results;
      docEl = angular.element(document);
      ref = docEl.find(".lightbox.open");
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        lightboxEl = ref[i];
        results.push(this.close($(lightboxEl)));
      }
      return results;
    };

    return LightboxService;

  })(taiga.Service);

  module.service("lightboxService", ["animationFrame", "$q", "$rootScope", LightboxService]);

  LightboxKeyboardNavigationService = (function(superClass) {
    extend(LightboxKeyboardNavigationService, superClass);

    function LightboxKeyboardNavigationService() {
      return LightboxKeyboardNavigationService.__super__.constructor.apply(this, arguments);
    }

    LightboxKeyboardNavigationService.prototype.stop = function() {
      var docEl;
      docEl = angular.element(document);
      return docEl.off(".keyboard-navigation");
    };

    LightboxKeyboardNavigationService.prototype.dispatch = function($el, code) {
      var activeElement, next, prev;
      activeElement = $el.find(".selected");
      if (code === 13) {
        if ($el.find(".user-list-single").length === 1) {
          return $el.find('.user-list-single:first').trigger("click");
        } else {
          return activeElement.trigger("click");
        }
      } else if (code === 40) {
        if (!activeElement.length) {
          return $el.find('.user-list-single:not(".is-active"):first').addClass('selected');
        } else {
          next = activeElement.next('.user-list-single');
          if (next.length) {
            activeElement.removeClass('selected');
            return next.addClass('selected');
          }
        }
      } else if (code === 38) {
        if (!activeElement.length) {
          return $el.find('.user-list-single:last').addClass('selected');
        } else {
          prev = activeElement.prev('.user-list-single:not(".is-active")');
          if (prev.length) {
            activeElement.removeClass('selected');
            return prev.addClass('selected');
          }
        }
      }
    };

    LightboxKeyboardNavigationService.prototype.init = function($el) {
      var docEl;
      this.stop();
      docEl = angular.element(document);
      return docEl.on("keydown.keyboard-navigation", (function(_this) {
        return function(event) {
          var code;
          code = event.keyCode ? event.keyCode : event.which;
          if (code === 40 || code === 38 || code === 13) {
            event.preventDefault();
            return _this.dispatch($el, code);
          }
        };
      })(this));
    };

    return LightboxKeyboardNavigationService;

  })(taiga.Service);

  module.service("lightboxKeyboardNavigationService", LightboxKeyboardNavigationService);

  LightboxDirective = function(lightboxService) {
    var link;
    link = function($scope, $el, $attrs) {
      if (!$attrs.$attr.visible) {
        return $el.on("click", ".close", function(event) {
          event.preventDefault();
          return lightboxService.close($el);
        });
      }
    };
    return {
      restrict: "C",
      link: link
    };
  };

  module.directive("lightbox", ["lightboxService", LightboxDirective]);

  BlockLightboxDirective = function($rootscope, $tgrepo, $confirm, lightboxService, $loading, $modelTransform, $translate) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var block, title, unblock;
      title = $translate.instant($attrs.title);
      $el.find("h2.title").text(title);
      unblock = (function(_this) {
        return function(finishCallback) {
          var transform;
          transform = $modelTransform.save(function(item) {
            item.is_blocked = false;
            item.blocked_note = "";
            return item;
          });
          transform.then(function() {
            $confirm.notify("success");
            $rootscope.$broadcast("object:updated");
            return finishCallback();
          });
          transform.then(null, function() {
            $confirm.notify("error");
            return item.revert();
          });
          transform["finally"](function() {
            return finishCallback();
          });
          return transform;
        };
      })(this);
      block = function() {
        var currentLoading, transform;
        currentLoading = $loading().target($el.find(".button-green")).start();
        transform = $modelTransform.save(function(item) {
          item.is_blocked = true;
          item.blocked_note = $el.find(".reason").val();
          return item;
        });
        transform.then(function() {
          $confirm.notify("success");
          return $rootscope.$broadcast("object:updated");
        });
        transform.then(null, function() {
          return $confirm.notify("error");
        });
        return transform["finally"](function() {
          currentLoading.finish();
          return lightboxService.close($el);
        });
      };
      $scope.$on("block", function() {
        $el.find(".reason").val($model.$modelValue.blocked_note);
        return lightboxService.open($el);
      });
      $scope.$on("unblock", (function(_this) {
        return function(event, model, finishCallback) {
          return unblock(finishCallback);
        };
      })(this));
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return $el.on("click", ".button-green", function(event) {
        event.preventDefault();
        return block();
      });
    };
    return {
      templateUrl: "common/lightbox/lightbox-block.html",
      link: link,
      require: "ngModel"
    };
  };

  module.directive("tgLbBlock", ["$rootScope", "$tgRepo", "$tgConfirm", "lightboxService", "$tgLoading", "$tgQueueModelTransformation", "$translate", BlockLightboxDirective]);

  BlockingMessageInputDirective = function($log, $template, $compile) {
    var link, template, templateFn;
    template = $template.get("common/lightbox/lightbox-blocking-message-input.html", true);
    link = function($scope, $el, $attrs, $model) {
      if (!$attrs.watch) {
        return $log.error("No watch attribute on tg-blocking-message-input directive");
      }
      return $scope.$watch($attrs.watch, function(value) {
        if (value === !void 0 && value === true) {
          return $el.find(".blocked-note").removeClass("hidden");
        } else {
          return $el.find(".blocked-note").addClass("hidden");
        }
      });
    };
    templateFn = function($el, $attrs) {
      return template({
        ngmodel: $attrs.ngModel
      });
    };
    return {
      template: templateFn,
      link: link,
      require: "ngModel",
      restrict: "EA"
    };
  };

  module.directive("tgBlockingMessageInput", ["$log", "$tgTemplate", "$compile", BlockingMessageInputDirective]);

  CreateBulkUserstoriesDirective = function($repo, $rs, $rootscope, lightboxService, $loading, $model) {
    var link;
    link = function($scope, $el, attrs) {
      var form, submit, submitButton;
      form = null;
      $scope.$on("usform:bulk", function(ctx, projectId, status) {
        if (form) {
          form.reset();
        }
        $scope["new"] = {
          projectId: projectId,
          statusId: status,
          bulk: ""
        };
        return lightboxService.open($el);
      });
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, promise;
          event.preventDefault();
          form = $el.find("form").checksley({
            onlyOneErrorElement: true
          });
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          promise = $rs.userstories.bulkCreate($scope["new"].projectId, $scope["new"].statusId, $scope["new"].bulk);
          promise.then(function(result) {
            result = _.map(result.data, (function(_this) {
              return function(x) {
                return $model.make_model('userstories', x);
              };
            })(this));
            currentLoading.finish();
            $rootscope.$broadcast("usform:bulk:success", result);
            return lightboxService.close($el);
          });
          return promise.then(null, function(data) {
            currentLoading.finish();
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("error", data._error_message);
            }
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      $el.on("submit", "form", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgLbCreateBulkUserstories", ["$tgRepo", "$tgResources", "$rootScope", "lightboxService", "$tgLoading", "$tgModel", CreateBulkUserstoriesDirective]);

  LightboxLeaveProjectWarningDirective = function(lightboxService, $template, $compile) {
    var link;
    link = function($scope, $el, attrs) {
      return lightboxService.open($el);
    };
    return {
      templateUrl: 'common/lightbox/lightbox-leave-project-warning.html',
      link: link,
      scope: true
    };
  };

  module.directive("tgLightboxLeaveProjectWarning", ["lightboxService", LightboxLeaveProjectWarningDirective]);

  SetDueDateDirective = function($rootscope, lightboxService, $loading, $translate, $confirm, $modelTransform) {
    var link;
    link = function($scope, $el, attrs) {
      var prettyDate, remove, save;
      prettyDate = $translate.instant("COMMON.PICKERDATE.FORMAT");
      lightboxService.open($el);
      if ($scope.object.due_date) {
        $scope.new_due_date = moment($scope.object.due_date).format(prettyDate);
      }
      $el.on("click", ".suggestion", function(event) {
        var quantity, target, unit, value;
        target = angular.element(event.currentTarget);
        quantity = target.data('quantity');
        unit = target.data('unit');
        value = moment().add(quantity, unit).format(prettyDate);
        return $el.find(".due-date").val(value);
      });
      save = function() {
        var currentLoading, new_due_date, transform;
        currentLoading = $loading().target($el.find(".submit-button")).start();
        if ($scope.notAutoSave) {
          new_due_date = $('.due-date').val();
          $scope.object.due_date = new_due_date ? moment(new_due_date, prettyDate).format("YYYY-MM-DD") : null;
          $scope.$apply();
          currentLoading.finish();
          lightboxService.close($el);
          return;
        }
        transform = $modelTransform.save(function(object) {
          new_due_date = $('.due-date').val();
          object.due_date = new_due_date ? moment(new_due_date, prettyDate).format("YYYY-MM-DD") : null;
          return object;
        });
        transform.then(function() {
          return $confirm.notify("success");
        });
        transform.then(null, function() {
          return $confirm.notify("error");
        });
        return transform["finally"](function() {
          currentLoading.finish();
          lightboxService.close($el);
          return $rootscope.$broadcast("object:updated");
        });
      };
      $el.on("click", ".submit-button", function(event) {
        event.preventDefault();
        return save();
      });
      remove = function() {
        var message, subtitle, title;
        title = $translate.instant("LIGHTBOX.DELETE_DUE_DATE.TITLE");
        subtitle = $translate.instant("LIGHTBOX.DELETE_DUE_DATE.SUBTITLE");
        message = moment($scope.object.due_date).format(prettyDate);
        return $confirm.askOnDelete(title, message, subtitle).then(function(askResponse) {
          askResponse.finish();
          $('.due-date').val(null);
          $scope.object.due_date_reason = null;
          if ($scope.notAutoSave) {
            $scope.object.due_date = null;
            return lightboxService.close($el);
          } else {
            return save();
          }
        });
      };
      return $el.on("click", ".delete-due-date", function(event) {
        event.preventDefault();
        return remove();
      });
    };
    return {
      templateUrl: 'common/lightbox/lightbox-due-date.html',
      link: link,
      scope: true
    };
  };

  module.directive("tgLbSetDueDate", ["$rootScope", "lightboxService", "$tgLoading", "$translate", "$tgConfirm", "$tgQueueModelTransformation", SetDueDateDirective]);

  groupBy = this.taiga.groupBy;

  CreateEditDirective = function($log, $repo, $model, $rs, $rootScope, lightboxService, $loading, $translate, $confirm, $q, attachmentsService, $template, $compile) {
    var link;
    link = function($scope, $el, attrs) {
      var addExistingToSprint, attachmentsToAdd, attachmentsToDelete, checkClose, close, createAttachments, deleteAttachments, docEl, form, getSchema, isDisabledExisting, mount, objType, render, resetAttachments, saveItem, schema, schemas, setStatus, sprintChangeConfirmAndSave, submit;
      schema = null;
      objType = null;
      form = null;
      attachmentsToAdd = Immutable.List();
      attachmentsToDelete = Immutable.List();
      schemas = {
        us: {
          objName: 'User Story',
          model: 'userstories',
          params: {
            include_attachments: true,
            include_tasks: true
          },
          data: function(project) {
            return {
              translationID: 'US',
              translationIDPlural: 'US',
              statusList: _.sortBy(project.us_statuses, "order")
            };
          },
          initialData: function(data) {
            return {
              project: data.project.id,
              subject: "",
              description: "",
              tags: [],
              points: {},
              status: data.statusId ? data.statusId : data.project.default_us_status,
              is_archived: false
            };
          }
        },
        task: {
          objName: 'Task',
          model: 'tasks',
          params: {
            include_attachments: true
          },
          data: function(project) {
            return {
              translationID: 'TASK',
              translationIDPlural: 'TASKS',
              statusList: _.sortBy(project.task_statuses, "order")
            };
          },
          initialData: function(data) {
            return {
              project: data.project.id,
              subject: "",
              description: "",
              assigned_to: null,
              tags: [],
              milestone: data.sprintId,
              status: data.project.default_task_status,
              user_story: data.usId,
              is_archived: false
            };
          }
        },
        issue: {
          objName: 'Issue',
          model: 'issues',
          params: {
            include_attachments: true
          },
          data: function(project) {
            return {
              translationID: 'ISSUE',
              translationIDPlural: 'ISSUES',
              project: project,
              statusList: _.sortBy(project.issue_statuses, "order"),
              typeById: groupBy(project.issue_types, function(x) {
                return x.id;
              }),
              typeList: _.sortBy(project.issue_types, "order"),
              severityById: groupBy(project.severities, function(x) {
                return x.id;
              }),
              severityList: _.sortBy(project.severities, "order"),
              priorityById: groupBy(project.priorities, function(x) {
                return x.id;
              }),
              priorityList: _.sortBy(project.priorities, "order"),
              milestonesById: groupBy(project.milestones, function(x) {
                return x.id;
              })
            };
          },
          initialData: function(data) {
            return {
              assigned_to: null,
              milestone: data.sprintId,
              priority: data.project.default_priority,
              project: data.project.id,
              severity: data.project.default_severity,
              status: data.project.default_issue_status,
              subject: "",
              tags: [],
              type: data.project.default_issue_type
            };
          }
        }
      };
      $scope.setMode = function(value) {
        return $scope.mode = value;
      };
      $scope.$on("genericform:new", function(ctx, params) {
        getSchema(params);
        $scope.mode = 'new';
        $scope.getOrCreate = false;
        return mount(params);
      });
      $scope.$on("genericform:new-or-existing", function(ctx, params) {
        getSchema(params);
        $scope.mode = 'add-existing';
        $scope.getOrCreate = true;
        $scope.existingFilterText = '';
        $rs[schema.model].listInAllProjects({
          project: $scope.project.id
        }, true).then(function(data) {
          return $scope.existingItems = angular.copy(data);
        });
        return mount(params);
      });
      $scope.$on("genericform:edit", function(ctx, params) {
        getSchema(params);
        $scope.mode = 'edit';
        $scope.getOrCreate = false;
        return mount(params);
      });
      getSchema = function(params) {
        _.map(params, function(value, key) {
          return $scope[key] = value;
        });
        if (!$scope.objType || !schemas[$scope.objType]) {
          return $log.error("Invalid objType `" + $scope.objType + "` for `genericform` event");
        }
        return schema = schemas[$scope.objType];
      };
      mount = function(params) {
        $scope.objName = schema.objName;
        if ($scope.mode === 'edit') {
          $scope.obj = params.obj;
          $scope.attachments = Immutable.fromJS(params.attachments);
        } else {
          $scope.obj = $model.make_model(schema.model, schema.initialData(params));
          $scope.attachments = Immutable.List();
        }
        _.map(schema.data($scope.project), function(value, key) {
          return $scope[key] = value;
        });
        if (form) {
          form.reset();
        }
        resetAttachments();
        setStatus($scope.obj.status);
        render();
        $scope.lightboxOpen = true;
        return lightboxService.open($el, null, null, true);
      };
      resetAttachments = function() {
        attachmentsToAdd = Immutable.List();
        return attachmentsToDelete = Immutable.List();
      };
      $scope.addAttachment = function(attachment) {
        return attachmentsToAdd = attachmentsToAdd.push(attachment);
      };
      $scope.deleteAttachment = function(attachment) {
        attachmentsToAdd = attachmentsToAdd.filter(function(it) {
          return it.get('name') !== attachment.get('name');
        });
        if (attachment.get("id")) {
          return attachmentsToDelete = attachmentsToDelete.push(attachment);
        }
      };
      $scope.addTag = function(tag, color) {
        var inserted, itemtags, projectTags, tags, value;
        value = trim(tag.toLowerCase());
        tags = $scope.project.tags;
        projectTags = $scope.project.tags_colors;
        if (tags == null) {
          tags = [];
        }
        if (projectTags == null) {
          projectTags = {};
        }
        if (indexOf.call(tags, value) < 0) {
          tags.push(value);
        }
        projectTags[tag] = color || null;
        $scope.project.tags = tags;
        itemtags = _.clone($scope.obj.tags);
        inserted = _.find(itemtags, function(it) {
          return it[0] === value;
        });
        if (!inserted) {
          itemtags.push([value, color]);
          return $scope.obj.tags = itemtags;
        }
      };
      $scope.deleteTag = function(tag) {
        var itemtags, tags, value;
        value = trim(tag[0].toLowerCase());
        tags = $scope.project.tags;
        itemtags = _.clone($scope.obj.tags);
        _.remove(itemtags, function(tag) {
          return tag[0] === value;
        });
        $scope.obj.tags = itemtags;
        return _.pull($scope.obj.tags, value);
      };
      createAttachments = function(obj) {
        var promises;
        promises = _.map(attachmentsToAdd.toJS(), function(attachment) {
          return attachmentsService.upload(attachment.file, obj.id, $scope.obj.project, $scope.objType);
        });
        return $q.all(promises);
      };
      deleteAttachments = function(obj) {
        var promises;
        promises = _.map(attachmentsToDelete.toJS(), function(attachment) {
          return attachmentsService["delete"]($scope.objType, attachment.id);
        });
        return $q.all(promises);
      };
      addExistingToSprint = function(item) {
        var currentLoading, onError, onSuccess;
        currentLoading = $loading().target($el.find(".add-existing-button")).start();
        if (item.milestone) {
          return sprintChangeConfirmAndSave(item);
        } else {
          onSuccess = function() {
            close();
            return $rootScope.$broadcast($scope.objType + "form:add:success", item);
          };
          onError = function() {
            return close();
          };
          return saveItem(item, onSuccess, onError);
        }
      };
      sprintChangeConfirmAndSave = function(item) {
        var message, newSprintName, oldSprintName, title;
        oldSprintName = $scope.milestonesById[item.milestone].name;
        newSprintName = $scope.milestonesById[$scope.relatedObjectId].name;
        title = $translate.instant("ISSUES.CONFIRM_CHANGE_FROM_SPRINT.TITLE");
        message = $translate.instant("ISSUES.CONFIRM_CHANGE_FROM_SPRINT.MESSAGE", {
          issue: item.subject,
          oldSprintName: oldSprintName,
          newSprintName: newSprintName
        });
        return $confirm.ask(title, null, message).then(function(askResponse) {
          var onError, onSuccess;
          onSuccess = function() {
            askResponse.finish();
            lightboxService.closeAll();
            $scope.lightboxOpen = false;
            return $rootScope.$broadcast($scope.objType + "form:add:success", item);
          };
          onError = function() {
            askResponse.finish(false);
            return $confirm.notify("error");
          };
          return saveItem(item, onSuccess, onError);
        });
      };
      saveItem = function(item, onSuccess, onError) {
        item.setAttr($scope.relatedField, $scope.relatedObjectId);
        return $repo.save(item, true).then(onSuccess, onError);
      };
      isDisabledExisting = function(item) {
        return item && item[$scope.relatedField] === $scope.relatedObjectId;
      };
      $scope.isDisabledExisting = function(selectedItem) {
        return isDisabledExisting(selectedItem);
      };
      $scope.addExistingToSprint = function(selectedItem) {
        return addExistingToSprint(selectedItem);
      };
      submit = debounce(2000, function(event) {
        var broadcastEvent, currentLoading, prettyDate, promise;
        form = $el.find("form").checksley();
        if (!form.validate()) {
          return;
        }
        currentLoading = $loading().target($el.find("#submitButton")).start();
        if ($scope.mode === 'new') {
          promise = $repo.create(schema.model, $scope.obj);
          broadcastEvent = $scope.objType + "form:new:success";
        } else {
          if ($scope.obj.due_date instanceof moment) {
            prettyDate = $translate.instant("COMMON.PICKERDATE.FORMAT");
            $scope.obj.due_date = $scope.obj.due_date.format("YYYY-MM-DD");
          }
          promise = $repo.save($scope.obj, true);
          broadcastEvent = $scope.objType + "form:edit:success";
        }
        promise.then(function(data) {
          return deleteAttachments(data).then(function() {
            return createAttachments(data).then(function() {
              currentLoading.finish();
              $confirm.notify("success");
              close();
              if (data.ref) {
                return $rs[schema.model].getByRef(data.project, data.ref, schema.params).then(function(obj) {
                  return $rootScope.$broadcast(broadcastEvent, obj);
                });
              }
            });
          });
        });
        return promise.then(null, function(data) {
          currentLoading.finish();
          form.setErrors(data);
          if (data._error_message) {
            return $confirm.notify("error", data._error_message);
          }
        });
      });
      checkClose = function() {
        if (!$scope.obj.isModified()) {
          close();
          return $scope.$apply(function() {
            return $scope.obj.revert();
          });
        } else {
          return $confirm.ask($translate.instant("LIGHTBOX.CREATE_EDIT.CONFIRM_CLOSE")).then(function(result) {
            result.finish();
            return close();
          });
        }
      };
      close = function() {
        lightboxService.closeAll();
        return $scope.lightboxOpen = false;
      };
      docEl = angular.element(document);
      docEl.on("keydown.lightbox-create-edit", function(event) {
        var code;
        if ($scope.lightboxOpen) {
          event.stopPropagation();
          code = event.keyCode ? event.keyCode : event.which;
          if (code === 27) {
            return checkClose();
          }
        }
      });
      $el.on("submit", "form", submit);
      $el.find('.close').on("click", function(event) {
        event.preventDefault();
        event.stopPropagation();
        return checkClose();
      });
      $el.on("click", ".status-dropdown", function(event) {
        event.preventDefault();
        event.stopPropagation();
        return $el.find(".pop-status").popover().open();
      });
      $el.on("click", ".status", function(event) {
        event.preventDefault();
        event.stopPropagation();
        setStatus(angular.element(event.currentTarget).data("status-id"));
        $scope.$apply();
        $scope.$broadcast("status:changed", $scope.obj.status);
        return $el.find(".pop-status").popover().close();
      });
      $el.on("click", ".team-requirement", function(event) {
        $scope.obj.team_requirement = !$scope.obj.team_requirement;
        return $scope.$apply();
      });
      $el.on("click", ".client-requirement", function(event) {
        $scope.obj.client_requirement = !$scope.obj.client_requirement;
        return $scope.$apply();
      });
      $el.on("click", ".is-blocked", function(event) {
        $scope.obj.is_blocked = !$scope.obj.is_blocked;
        return $scope.$apply();
      });
      $el.on("click", ".iocaine", function(event) {
        $scope.obj.is_iocaine = !$scope.obj.is_iocaine;
        return $scope.$broadcast("isiocaine:changed", $scope.obj);
      });
      $scope.isTeamRequirement = function() {
        var ref;
        return (ref = $scope.obj) != null ? ref.team_requirement : void 0;
      };
      $scope.isClientRequirement = function() {
        var ref;
        return (ref = $scope.obj) != null ? ref.client_requirement : void 0;
      };
      setStatus = function(id) {
        $scope.obj.status = id;
        $scope.selectedStatus = _.find($scope.statusList, function(item) {
          return item.id === id;
        });
        return $scope.obj.is_closed = $scope.selectedStatus.is_closed;
      };
      return render = function(sprint) {
        var compiledTemplate, template, templateScope;
        template = $template.get("common/lightbox/lightbox-create-edit/lb-create-edit.html");
        templateScope = $scope.$new();
        compiledTemplate = $compile(template)(templateScope);
        return $el.html(compiledTemplate);
      };
    };
    return {
      link: link
    };
  };

  module.directive("tgLbCreateEdit", ["$log", "$tgRepo", "$tgModel", "$tgResources", "$rootScope", "lightboxService", "$tgLoading", "$translate", "$tgConfirm", "$q", "tgAttachmentsService", "$tgTemplate", "$compile", CreateEditDirective]);

  debounceLeading = this.taiga.debounceLeading;

  RelateToEpicLightboxDirective = function($rootScope, $confirm, lightboxService, $tgCurrentUserService, tgResources, $tgResources, $epicsService, tgAnalytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var existingEpicForm, filterEpics, loadProjects, newEpicForm, selectProject, us;
      us = null;
      $scope.projects = null;
      $scope.projectEpics = Immutable.List();
      $scope.loading = false;
      $scope.selectedProject = $scope.project.id;
      newEpicForm = $el.find(".new-epic-form").checksley();
      existingEpicForm = $el.find(".existing-epic-form").checksley();
      loadProjects = function() {
        if ($scope.projects === null) {
          return $scope.projects = $tgCurrentUserService.projects.get("unblocked");
        }
      };
      filterEpics = function(selectedProjectId, filterText) {
        return tgResources.epics.listInAllProjects({
          is_epics_activated: true,
          project__blocked_code: 'null',
          project: selectedProjectId,
          q: filterText
        }, true).then(function(data) {
          var excludeIds, filteredData;
          excludeIds = [];
          if (us.epics) {
            excludeIds = us.epics.map(function(epic) {
              return epic.id;
            });
          }
          filteredData = data.filter(function(epic) {
            return excludeIds.indexOf(epic.get('id')) === -1;
          });
          return $scope.projectEpics = filteredData;
        });
      };
      selectProject = function(selectedProjectId) {
        $scope.selectedEpic = null;
        $scope.searchEpic = "";
        return filterEpics(selectedProjectId, $scope.searchEpic);
      };
      $el.on("click", ".close", function(event) {
        event.preventDefault();
        return lightboxService.close($el);
      });
      $scope.$on("relate-to-epic:add", function(ctx, item) {
        us = item;
        $scope.selectedEpic = null;
        $scope.searchEpic = "";
        loadProjects();
        return filterEpics($scope.selectedProject, $scope.searchEpic).then(function() {
          return lightboxService.open($el).then(function() {
            return $el.find('input').focus;
          });
        });
      });
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      $scope.selectProject = function(selectedProjectId) {
        return selectProject(selectedProjectId);
      };
      $scope.onUpdateSearchEpic = debounceLeading(300, function() {
        $scope.selectedEpic = null;
        return filterEpics($scope.selectedProject, $scope.searchEpic);
      });
      $scope.saveRelatedEpic = function(selectedEpicId, onSavedRelatedEpic) {
        var onError, onSuccess, usId;
        if (!existingEpicForm.validate()) {
          return;
        }
        $scope.loading = true;
        onError = function(data) {
          $scope.loading = false;
          $confirm.notify("error");
          return existingEpicForm.setErrors(data);
        };
        onSuccess = function(data) {
          tgAnalytics.trackEvent("user story related epic", "create", "create related epic on user story", 1);
          $scope.loading = false;
          $rootScope.$broadcast("related-epics:changed", us);
          return lightboxService.close($el);
        };
        usId = us.id;
        return tgResources.epics.addRelatedUserstory(selectedEpicId, usId).then(onSuccess, onError);
      };
      return $scope.createEpic = function(selectedProjectId, epicSubject) {
        var onCreateEpic, onError, onSuccess;
        if (!newEpicForm.validate()) {
          return;
        }
        this.loading = true;
        onError = function(data) {
          $scope.loading = false;
          $confirm.notify("error");
          return newEpicForm.setErrors(errors);
        };
        onSuccess = function() {
          tgAnalytics.trackEvent("user story related epic", "create", "create related epic on user story", 1);
          $scope.loading = false;
          $rootScope.$broadcast("related-epics:changed", us);
          return lightboxService.close($el);
        };
        onCreateEpic = function(epic) {
          var epicId, usId;
          epicId = epic.get('id');
          usId = us.id;
          return tgResources.epics.addRelatedUserstory(epicId, usId).then(onSuccess, onError);
        };
        return $epicsService.createEpic({
          subject: epicSubject
        }, null, selectedProjectId).then(onCreateEpic, onError);
      };
    };
    return {
      templateUrl: "common/lightbox/lightbox-relate-to-epic.html",
      link: link
    };
  };

  module.directive("tgLbRelatetoepic", ["$rootScope", "$tgConfirm", "lightboxService", "tgCurrentUserService", "tgResources", "$tgResources", "tgEpicsService", "$tgAnalytics", RelateToEpicLightboxDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/loader.coffee
 */

(function() {
  var Loader, LoaderDirective, module, sizeFormat, taiga, timeout;

  taiga = this.taiga;

  sizeFormat = this.taiga.sizeFormat;

  timeout = this.taiga.timeout;

  module = angular.module("taigaCommon");

  LoaderDirective = function(tgLoader, $rootscope) {
    var link;
    link = function($scope, $el, $attrs) {
      tgLoader.onStart(function() {
        $(document.body).addClass("loader-active");
        return $el.addClass("active");
      });
      return tgLoader.onEnd(function() {
        $(document.body).removeClass("loader-active");
        return $el.removeClass("active");
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgLoader", ["tgLoader", "$rootScope", LoaderDirective]);

  Loader = function($rootscope) {
    var autoClose, config, lastResponseDate, open, pageLoaded, requestCount, start, startLoadTime;
    config = {
      minTime: 300
    };
    open = false;
    startLoadTime = 0;
    requestCount = 0;
    lastResponseDate = 0;
    pageLoaded = function(force) {
      var diff, endTime, timeoutValue;
      if (force == null) {
        force = false;
      }
      if (startLoadTime) {
        timeoutValue = 0;
        if (!force) {
          endTime = new Date().getTime();
          diff = endTime - startLoadTime;
          if (diff < config.minTime) {
            timeoutValue = config.minTime - diff;
          }
        }
        timeout(timeoutValue, function() {
          $rootscope.$broadcast("loader:end");
          open = false;
          return window.prerenderReady = true;
        });
      }
      startLoadTime = 0;
      requestCount = 0;
      return lastResponseDate = 0;
    };
    autoClose = function() {
      var intervalAuto;
      return intervalAuto = setInterval((function() {
        if (lastResponseDate && requestCount === 0) {
          pageLoaded();
          return clearInterval(intervalAuto);
        }
      }), 50);
    };
    start = function() {
      startLoadTime = new Date().getTime();
      $rootscope.$broadcast("loader:start");
      return open = true;
    };
    return {
      pageLoaded: pageLoaded,
      open: function() {
        return open;
      },
      start: function(auto) {
        if (auto == null) {
          auto = false;
        }
        if (!open) {
          start();
          if (auto) {
            return autoClose();
          }
        }
      },
      onStart: function(fn) {
        return $rootscope.$on("loader:start", fn);
      },
      onEnd: function(fn) {
        return $rootscope.$on("loader:end", fn);
      },
      logRequest: function() {
        return requestCount++;
      },
      logResponse: function() {
        if (requestCount > 0) {
          requestCount--;
        }
        return lastResponseDate = new Date().getTime();
      }
    };
  };

  Loader.$inject = ["$rootScope"];

  module.factory("tgLoader", Loader);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/loading.coffee
 */

(function() {
  var LoadingDirective, TgLoadingService, module,
    slice = [].slice;

  module = angular.module("taigaCommon");

  TgLoadingService = function($compile) {
    var spinner;
    spinner = "<img class='loading-spinner' src='/" + window._version + "/svg/spinner-circle.svg' alt='loading...' />";
    return function() {
      var service;
      service = {
        settings: {
          target: null,
          scope: null,
          classes: [],
          timeout: 0,
          template: null
        },
        target: function(target) {
          service.settings.target = target;
          return service;
        },
        scope: function(scope) {
          service.settings.scope = scope;
          return service;
        },
        template: function(template) {
          service.settings.template = template;
          return service;
        },
        removeClasses: function() {
          var classess;
          classess = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          service.settings.classes = classess;
          return service;
        },
        timeout: function(timeout) {
          service.settings.timeout = timeout;
          return service;
        },
        start: function() {
          var target, timeoutId;
          target = service.settings.target;
          service.settings.classes.map(function(className) {
            return target.removeClass(className);
          });
          if (!target.hasClass('loading') && !service.settings.template) {
            service.settings.template = target.html();
          }
          timeoutId = setTimeout((function() {
            if (!target.hasClass('loading')) {
              target.addClass('loading');
              return target.html(spinner);
            }
          }), service.settings.timeout);
          service.settings.timeoutId = timeoutId;
          return service;
        },
        finish: function() {
          var removeClasses, target, timeoutId;
          target = service.settings.target;
          timeoutId = service.settings.timeoutId;
          if (timeoutId) {
            clearTimeout(timeoutId);
            removeClasses = service.settings.classes;
            removeClasses.map(function(className) {
              return service.settings.target.addClass(className);
            });
            target.html(service.settings.template);
            target.removeClass('loading');
            if (service.settings.scope) {
              $compile(target.contents())(service.settings.scope);
            }
          }
          return service;
        }
      };
      return service;
    };
  };

  TgLoadingService.$inject = ["$compile"];

  module.factory("$tgLoading", TgLoadingService);

  LoadingDirective = function($loading) {
    var link;
    link = function($scope, $el, attr) {
      var currentLoading, template;
      currentLoading = null;
      template = $el.html();
      return $scope.$watch(attr.tgLoading, (function(_this) {
        return function(showLoading) {
          if (showLoading) {
            return currentLoading = $loading().target($el).timeout(100).template(template).scope($scope).start();
          } else if (currentLoading) {
            return currentLoading.finish();
          }
        };
      })(this));
    };
    return {
      priority: 99999,
      link: link
    };
  };

  module.directive("tgLoading", ["$tgLoading", LoadingDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/popovers.coffee
 */

(function() {
  var RelatedTaskStatusDirective, UsStatusDirective, bindOnce, debounce, module, taiga;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  module = angular.module("taigaCommon");

  UsStatusDirective = function($repo, $template) {

    /*
    Print the status of a US and a popover to change it.
    - tg-us-status: The user story
    - on-update: Method call after US is updated
    
    Example:
    
      div.status(tg-us-status="us" on-update="ctrl.loadSprintState()")
        a.us-status(href="", title="Status Name")
    
    NOTE: This directive need 'usStatusById' and 'project'.
     */
    var link, template;
    template = $template.get("common/popover/popover-us-status.html", true);
    link = function($scope, $el, $attrs) {
      var $ctrl, render, us;
      $ctrl = $el.controller();
      render = function(us) {
        var usStatusById, usStatusDom, usStatusDomParent;
        usStatusDomParent = $el.find(".us-status");
        usStatusDom = $el.find(".us-status .us-status-bind");
        usStatusById = $scope.usStatusById;
        if (usStatusById[us.status]) {
          usStatusDom.text(usStatusById[us.status].name);
          return usStatusDomParent.css("color", usStatusById[us.status].color);
        }
      };
      $el.on("click", ".us-status", function(event) {
        event.preventDefault();
        event.stopPropagation();
        return $el.find(".pop-status").popover().open();
      });
      $el.on("click", ".status", debounce(2000, function(event) {
        var target, us;
        event.preventDefault();
        event.stopPropagation();
        target = angular.element(event.currentTarget);
        us = $scope.$eval($attrs.tgUsStatus);
        us.status = target.data("status-id");
        render(us);
        $el.find(".pop-status").popover().close();
        return $scope.$apply(function() {
          return $repo.save(us).then(function() {
            return $scope.$eval($attrs.onUpdate);
          });
        });
      }));
      $scope.$on("userstories:loaded", function() {
        return render($scope.$eval($attrs.tgUsStatus));
      });
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      us = $scope.$eval($attrs.tgUsStatus);
      render(us);
      return bindOnce($scope, "project", function(project) {
        var html;
        html = template({
          "statuses": project.us_statuses
        });
        $el.append(html);
        if ($scope.project.my_permissions.indexOf("modify_us") === -1) {
          $el.unbind("click");
          return $el.find("a").addClass("not-clickable");
        }
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgUsStatus", ["$tgRepo", "$tgTemplate", UsStatusDirective]);

  RelatedTaskStatusDirective = function($repo, $template) {

    /*
    Print the status of a related task and a popover to change it.
    - tg-related-task-status: The related task
    - on-update: Method call after US is updated
    
    Example:
    
      div.status(tg-related-task-status="task" on-update="ctrl.loadSprintState()")
        a.task-status(href="", title="Status Name")
    
    NOTE: This directive need 'taskStatusById' and 'project'.
     */
    var link, selectionTemplate, updateTaskStatus;
    selectionTemplate = $template.get("common/popover/popover-related-task-status.html", true);
    updateTaskStatus = function($el, task, taskStatusById) {
      var taskStatusDom, taskStatusDomParent;
      taskStatusDomParent = $el.find(".us-status");
      taskStatusDom = $el.find(".task-status .task-status-bind");
      if (taskStatusById[task.status]) {
        taskStatusDom.text(taskStatusById[task.status].name);
        return taskStatusDomParent.css('color', taskStatusById[task.status].color);
      }
    };
    link = function($scope, $el, $attrs) {
      var $ctrl, autoSave, notAutoSave, task;
      $ctrl = $el.controller();
      task = $scope.$eval($attrs.tgRelatedTaskStatus);
      notAutoSave = $scope.$eval($attrs.notAutoSave);
      autoSave = !notAutoSave;
      $el.on("click", ".task-status", function(event) {
        event.preventDefault();
        event.stopPropagation();
        return $el.find(".pop-status").popover().open();
      });
      $el.on("click", ".status", debounce(2000, function(event) {
        var target;
        event.preventDefault();
        event.stopPropagation();
        target = angular.element(event.currentTarget);
        task.status = target.data("status-id");
        $el.find(".pop-status").popover().close();
        updateTaskStatus($el, task, $scope.taskStatusById);
        if (autoSave) {
          return $scope.$apply(function() {
            return $repo.save(task).then(function() {
              $scope.$eval($attrs.onUpdate);
              return $scope.$emit("related-tasks:status-changed");
            });
          });
        }
      }));
      $scope.$watch($attrs.tgRelatedTaskStatus, function() {
        task = $scope.$eval($attrs.tgRelatedTaskStatus);
        return updateTaskStatus($el, task, $scope.taskStatusById);
      });
      taiga.bindOnce($scope, "project", function(project) {
        $el.append(selectionTemplate({
          'statuses': project.task_statuses
        }));
        updateTaskStatus($el, task, $scope.taskStatusById);
        if (project.my_permissions.indexOf("modify_task") === -1) {
          $el.unbind("click");
          return $el.find("a").addClass("not-clickable");
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgRelatedTaskStatus", ["$tgRepo", "$tgTemplate", RelatedTaskStatusDirective]);

  $.fn.popover = function() {
    var $el, close, closeAll, closePopover, isVisible, open;
    $el = this;
    isVisible = (function(_this) {
      return function() {
        var docViewBottom, docViewLeft, docViewRight, docViewTop, docViewWidth, elemBottom, elemLeft, elemRight, elemTop, elemWidth;
        $el.css({
          "display": "block",
          "visibility": "hidden"
        });
        docViewTop = $(window).scrollTop();
        docViewBottom = docViewTop + $(window).height();
        docViewWidth = $(window).width();
        docViewRight = docViewWidth;
        docViewLeft = 0;
        elemTop = $el.offset().top;
        elemBottom = elemTop + $el.height();
        elemWidth = $el.width();
        elemLeft = $el.offset().left;
        elemRight = $el.offset().left + elemWidth;
        $el.css({
          "display": "none",
          "visibility": "visible"
        });
        return (elemBottom <= docViewBottom) && (elemTop >= docViewTop) && (elemLeft >= docViewLeft) && (elemRight <= docViewRight);
      };
    })(this);
    closePopover = (function(_this) {
      return function(onClose) {
        if (onClose) {
          onClose.call($el);
        }
        $el.fadeOut(function() {
          return $el.removeClass("active").removeClass("fix");
        });
        return $el.off("popup:close");
      };
    })(this);
    closeAll = (function(_this) {
      return function() {
        return $(".popover.active").each(function() {
          return $(this).trigger("popup:close");
        });
      };
    })(this);
    open = (function(_this) {
      return function(onClose) {
        if ($el.hasClass("active")) {
          return close();
        } else {
          closeAll();
          if (!isVisible()) {
            $el.addClass("fix");
          }
          $el.fadeIn(function() {
            $el.addClass("active");
            $(document.body).off("popover");
            return $(document.body).one("click.popover", function() {
              return closeAll();
            });
          });
          return $el.on("popup:close", function(e) {
            return closePopover(onClose);
          });
        }
      };
    })(this);
    close = (function(_this) {
      return function() {
        return $el.trigger("popup:close");
      };
    })(this);
    return {
      open: open,
      close: close,
      closeAll: closeAll
    };
  };

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/raven-logger.coffee
 */

(function() {
  var ExceptionHandlerFactory, module, taiga;

  taiga = this.taiga;

  module = angular.module("taigaCommon");

  ExceptionHandlerFactory = function($log, config) {
    var ravenConfig;
    this.config = config;
    ravenConfig = this.config.get("ravenConfig", null);
    if (ravenConfig) {
      $log.debug("Using the RavenJS exception handler.");
      Raven.config(ravenConfig).install();
      return function(exception, cause) {
        $log.error.apply($log, arguments);
        return Raven.captureException(exception);
      };
    } else {
      $log.debug("Using the default logging exception handler.");
      return function(exception, cause) {
        return $log.error.apply($log, arguments);
      };
    }
  };

  module.factory("$exceptionHandler", ["$log", "$tgConfig", ExceptionHandlerFactory]);

}).call(this);


/*
 * Copyright (C) 2014-2017 Andrey Antukh <niwi@niwi.nz>
 * Copyright (C) 2014-2017 Jesús Espino Garcia <jespinog@gmail.com>
 * Copyright (C) 2014-2017 David Barragán Merino <bameda@dbarragan.com>
 * Copyright (C) 2014-2017 Alejandro Alonso <alejandro.alonso@kaleidos.net>
 * Copyright (C) 2014-2017 Juan Francisco Alcántara <juanfran.alcantara@kaleidos.net>
 * Copyright (C) 2014-2017 Xavi Julian <xavier.julian@kaleidos.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/sections.coffee
 */

(function() {
  var SectionsService, module,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  module = angular.module("taigaCommon");

  SectionsService = (function(superClass) {
    var SECTIONS;

    extend(SectionsService, superClass);

    SectionsService.$inject = ["$translate", "tgCurrentUserService"];

    SECTIONS = {
      1: {
        id: 1,
        title: 'TIMELINE',
        path: 'timeline',
        enabled: ''
      },
      2: {
        id: 2,
        title: 'EPICS',
        path: 'epics',
        enabled: 'is_epics_activated'
      },
      3: {
        id: 3,
        title: 'BACKLOG',
        path: 'backlog',
        enabled: 'is_backlog_activated'
      },
      4: {
        id: 4,
        title: 'KANBAN',
        path: 'kanban',
        enabled: 'is_kanban_activated'
      },
      5: {
        id: 5,
        title: 'ISSUES',
        path: 'issues',
        enabled: 'is_issues_activated'
      },
      6: {
        id: 6,
        title: 'WIKI',
        path: 'wiki',
        enabled: 'is_wiki_activated'
      }
    };

    function SectionsService(translate, currentUserService) {
      this.translate = translate;
      this.currentUserService = currentUserService;
      SectionsService.__super__.constructor.call(this);
      _.map(SECTIONS, (function(_this) {
        return function(x) {
          return x.title = _this.translate.instant("PROJECT.SECTION." + x.title);
        };
      })(this));
    }

    SectionsService.prototype.list = function() {
      return SECTIONS;
    };

    SectionsService.prototype.getPath = function(projectSlug, sectionId) {
      var defaultHomePage, project, projects, ref, section;
      defaultHomePage = "timeline";
      projects = (ref = this.currentUserService.projects) != null ? ref.get("all") : void 0;
      if (!projects) {
        return defaultHomePage;
      }
      project = projects.find(function(p) {
        return p.get('slug') === projectSlug;
      });
      if (!project) {
        return defaultHomePage;
      }
      if (!sectionId) {
        sectionId = project.get('my_homepage');
      }
      section = _.find(SECTIONS, {
        "id": sectionId
      });
      if (!section || (project != null ? project.get(section.enabled) : void 0) === !true) {
        return defaultHomePage;
      }
      return section.path;
    };

    return SectionsService;

  })(taiga.Service);

  module.service("$tgSections", SectionsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/analytics.coffee
 */

(function() {
  var TagManagerService, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  module = angular.module("taigaCommon");

  TagManagerService = (function(superClass) {
    extend(TagManagerService, superClass);

    TagManagerService.$inject = ["$rootScope", "$log", "$tgConfig", "$window", "$document", "$location"];

    function TagManagerService(rootscope, log, config, win, doc, location) {
      var conf;
      this.rootscope = rootscope;
      this.log = log;
      this.config = config;
      this.win = win;
      this.doc = doc;
      this.location = location;
      this.initialized = false;
      conf = this.config.get("tagManager", {});
      this.accountId = conf.accountId;
    }

    TagManagerService.prototype.initialize = function() {
      if (!this.accountId) {
        this.log.debug("Tag Manager: no acount id provided. Disabling.");
        return;
      }
      this.injectTagManager();
      return this.initialized = true;
    };

    TagManagerService.prototype.injectTagManager = function() {
      var fn;
      fn = (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
              new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
              j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;
              j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;
              f.parentNode.insertBefore(j,f);});
      return fn(window, document, "script", "dataLayer", this.accountId);
    };

    return TagManagerService;

  })(taiga.Service);

  module.service("$tgTagManager", TagManagerService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/tags.coffee
 */

(function() {
  var ColorizeTagsBacklogDirective, LbTagLineDirective, TagsDirective, bindOnce, module, taiga, trim,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  taiga = this.taiga;

  trim = this.taiga.trim;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaCommon");

  TagsDirective = function() {
    var formatter, link, parser;
    formatter = function(v) {
      if (_.isArray(v)) {
        return v.join(", ");
      }
      return "";
    };
    parser = function(v) {
      var result;
      if (!v) {
        return [];
      }
      result = _(v.split(",")).map(function(x) {
        return _.trim(x);
      });
      return result.value();
    };
    link = function($scope, $el, $attrs, $ctrl) {
      $ctrl.$formatters.push(formatter);
      $ctrl.$parsers.push(parser);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      require: "ngModel",
      link: link
    };
  };

  module.directive("tgTags", TagsDirective);

  ColorizeTagsBacklogDirective = function($emojis) {
    var link, template;
    template = _.template("<% _.each(tags, function(tag) { %>\n    <% if (tag[1] !== null) { %>\n    <span class=\"tag\"\n          style=\"border-left: 5px solid <%- tag[1] %>\"\n          title=\"<%- tag[0] %>\">\n          <%= emojify(tag[0]) %>\n    </span>\n    <% } %>\n<% }) %>\n<% _.each(tags, function(tag) { %>\n    <% if (tag[1] === null) { %>\n    <span class=\"tag\"\n          title=\"<%- tag[0] %>\">\n          <%= emojify(tag[0]) %>\n    </span>\n    <% } %>\n<% }) %>");
    link = function($scope, $el, $attrs, $ctrl) {
      var render;
      render = function(tags) {
        var html;
        html = template({
          tags: tags,
          emojify: function(text) {
            return $emojis.replaceEmojiNameByHtmlImgs(_.escape(text));
          }
        });
        return $el.html(html);
      };
      $scope.$watch($attrs.tgColorizeBacklogTags, function(tags) {
        if (tags != null) {
          return render(tags);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgColorizeBacklogTags", ["$tgEmojis", ColorizeTagsBacklogDirective]);

  LbTagLineDirective = function($rs, $template, $compile) {
    var COMMA_KEY, ENTER_KEY, autocomplete, link, templateTags;
    ENTER_KEY = 13;
    COMMA_KEY = 188;
    templateTags = $template.get("common/tag/lb-tag-line-tags.html", true);
    autocomplete = null;
    link = function($scope, $el, $attrs, $model) {
      var addValue, deleteValue, hideSaveButton, renderTags, resetInput, saveInputTag, showSaveButton, withoutColors;
      withoutColors = _.has($attrs, "withoutColors");
      renderTags = function(tags, tagsColors) {
        var color, ctx, html;
        if (tagsColors == null) {
          tagsColors = [];
        }
        color = !withoutColors ? tagsColors[t] : null;
        ctx = {
          tags: _.map(tags, function(t) {
            return {
              name: t,
              style: color ? "border-left: 5px solid " + color : ""
            };
          })
        };
        html = $compile(templateTags(ctx))($scope);
        return $el.find(".tags-container").html(html);
      };
      showSaveButton = function() {
        return $el.find(".save").removeClass("hidden");
      };
      hideSaveButton = function() {
        return $el.find(".save").addClass("hidden");
      };
      resetInput = function() {
        $el.find("input").val("");
        return autocomplete.close();
      };
      addValue = function(value) {
        var tags;
        value = trim(value.toLowerCase());
        if (value.length === 0) {
          return;
        }
        tags = _.clone($model.$modelValue, false);
        if (tags == null) {
          tags = [];
        }
        if (indexOf.call(tags, value) < 0) {
          tags.push(value);
        }
        $scope.$apply(function() {
          return $model.$setViewValue(tags);
        });
        return hideSaveButton();
      };
      deleteValue = function(value) {
        var tags;
        value = trim(value.toLowerCase());
        if (value.length === 0) {
          return;
        }
        tags = _.clone($model.$modelValue, false);
        tags = _.pull(tags, value);
        return $scope.$apply(function() {
          return $model.$setViewValue(tags);
        });
      };
      saveInputTag = function() {
        var value;
        value = $el.find("input").val();
        addValue(value);
        return resetInput();
      };
      $el.on("keypress", "input", function(event) {
        var target;
        target = angular.element(event.currentTarget);
        if (event.keyCode === ENTER_KEY) {
          event.preventDefault();
          return saveInputTag();
        } else if (String.fromCharCode(event.keyCode) === ',') {
          event.preventDefault();
          return saveInputTag();
        } else {
          if (target.val().length) {
            return showSaveButton();
          } else {
            return hideSaveButton();
          }
        }
      });
      $el.on("click", ".save", function(event) {
        event.preventDefault();
        return saveInputTag();
      });
      $el.on("click", ".remove-tag", function(event) {
        var target, value;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        value = target.siblings(".tag-name").text();
        return deleteValue(value);
      });
      bindOnce($scope, "project", function(project) {
        var input;
        input = $el.find("input");
        autocomplete = new Awesomplete(input[0], {
          list: _.keys(project.tags_colors)
        });
        return input.on("awesomplete-selectcomplete", function() {
          addValue(input.val());
          return input.val("");
        });
      });
      $scope.$watch($attrs.ngModel, function(tags) {
        var ref, tagsColors;
        tagsColors = ((ref = $scope.project) != null ? ref.tags_colors : void 0) || [];
        return renderTags(tags, tagsColors);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      require: "ngModel",
      templateUrl: "common/tag/lb-tag-line.html"
    };
  };

  module.directive("tgLbTagLine", ["$tgResources", "$tgTemplate", "$compile", LbTagLineDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2020 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/common/userpilot.coffee
 */

(function() {
  var UserPilotService, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  module = angular.module("taigaCommon");

  UserPilotService = (function(superClass) {
    extend(UserPilotService, superClass);

    UserPilotService.$inject = ["$rootScope", "$window"];

    function UserPilotService(rootScope, win) {
      this.rootScope = rootScope;
      this.win = win;
      this.initialized = false;
      this.identified = false;
    }

    UserPilotService.prototype.initialize = function() {
      this.rootScope.$on('$locationChangeSuccess', (function(_this) {
        return function() {
          if (_this.win.userpilot) {
            return _this.win.userpilot.reload();
          }
        };
      })(this));
      return this.initialize = true;
    };

    UserPilotService.prototype.identify = function(force) {
      var data, id, timestamp, userdata;
      if (force == null) {
        force = false;
      }
      userdata = this.win.localStorage.getItem("userInfo");
      if (this.win.userpilot && ((userdata && !this.identified) || force)) {
        data = JSON.parse(userdata);
        if (data["id"]) {
          this.identified = true;
          id = this.getUserPilotId(data);
          timestamp = Date.now();
          return this.win.userpilot.identify(id, {
            name: data["full_name_display"],
            email: data["email"],
            created_at: timestamp,
            taiga_id: id,
            taiga_username: data["username"],
            taiga_date_joined: data["date_joined"]
          });
        }
      }
    };

    UserPilotService.prototype.getUserPilotId = function(data) {
      var joined;
      joined = new Date(data["date_joined"]);
      if (joined > this.getJoinedLimit(42)) {
        return parseInt(data["id"], 10);
      } else {
        return 1;
      }
    };

    UserPilotService.prototype.getJoinedLimit = function(days) {
      var limit;
      limit = new Date;
      limit.setDate(limit.getDate() - days);
      return limit;
    };

    return UserPilotService;

  })(taiga.Service);

  module.service("$tgUserPilot", UserPilotService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/backlog/lightboxes.coffee
 */

(function() {
  var CreateEditSprint, bindOnce, debounce, module, taiga;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  module = angular.module("taigaBacklog");

  CreateEditSprint = function($repo, $confirm, $rs, $rootscope, lightboxService, $loading, $translate) {
    var link;
    link = function($scope, $el, attrs) {
      var createSprint, form, getLastSprint, hasErrors, remove, resetSprint, submit, ussToAdd;
      hasErrors = false;
      createSprint = true;
      form = null;
      $scope.newSprint = {};
      ussToAdd = null;
      resetSprint = function() {
        if (form) {
          form.reset();
        }
        return $scope.newSprint = {
          project: null,
          name: null,
          estimated_start: null,
          estimated_finish: null
        };
      };
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var broadcastEvent, currentLoading, estimated_end, estimated_start, newSprint, prettyDate, promise, submitButton, target;
          event.preventDefault();
          target = angular.element(event.currentTarget);
          prettyDate = $translate.instant("COMMON.PICKERDATE.FORMAT");
          submitButton = $el.find(".submit-button");
          form = $el.find("form").checksley();
          if (!form.validate()) {
            hasErrors = true;
            $el.find(".last-sprint-name").addClass("disappear");
            return;
          }
          hasErrors = false;
          broadcastEvent = null;
          estimated_start = $('.date-start').val();
          estimated_end = $('.date-end').val();
          if (createSprint) {
            newSprint = angular.copy($scope.newSprint);
            newSprint.estimated_start = moment(estimated_start, prettyDate).format("YYYY-MM-DD");
            newSprint.estimated_finish = moment(estimated_end, prettyDate).format("YYYY-MM-DD");
            promise = $repo.create("milestones", newSprint);
            broadcastEvent = "sprintform:create:success";
          } else {
            newSprint = $scope.newSprint.realClone();
            newSprint.estimated_start = moment(estimated_start, prettyDate).format("YYYY-MM-DD");
            newSprint.estimated_finish = moment(estimated_end, prettyDate).format("YYYY-MM-DD");
            promise = $repo.save(newSprint);
            broadcastEvent = "sprintform:edit:success";
          }
          currentLoading = $loading().target(submitButton).start();
          promise.then(function(data) {
            currentLoading.finish();
            if (createSprint) {
              $scope.sprintsCounter += 1;
            }
            $scope.sprints = _.map($scope.sprints, function(it) {
              if (it.id === data.id) {
                return data;
              } else {
                return it;
              }
            });
            if (broadcastEvent === "sprintform:create:success" && ussToAdd) {
              $rootscope.$broadcast(broadcastEvent, data, ussToAdd);
            } else {
              $rootscope.$broadcast(broadcastEvent, data);
            }
            return lightboxService.close($el);
          });
          return promise.then(null, function(data) {
            currentLoading.finish();
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("light-error", data._error_message);
            } else if (data.__all__) {
              return $confirm.notify("light-error", data.__all__[0]);
            }
          });
        };
      })(this));
      remove = function() {
        var message, title;
        title = $translate.instant("LIGHTBOX.DELETE_SPRINT.TITLE");
        message = $scope.newSprint.name;
        return $confirm.askOnDelete(title, message).then((function(_this) {
          return function(askResponse) {
            var onError, onSuccess;
            onSuccess = function() {
              askResponse.finish();
              $scope.milestonesCounter -= 1;
              lightboxService.close($el);
              return $rootscope.$broadcast("sprintform:remove:success", $scope.newSprint);
            };
            onError = function() {
              askResponse.finish(false);
              return $confirm.notify("error");
            };
            return $repo.remove($scope.newSprint).then(onSuccess, onError);
          };
        })(this));
      };
      getLastSprint = function() {
        var openSprints, sortedSprints;
        openSprints = _.filter($scope.sprints, function(sprint) {
          return !sprint.closed;
        });
        sortedSprints = _.sortBy(openSprints, function(sprint) {
          return moment(sprint.estimated_finish, 'YYYY-MM-DD').format('X');
        });
        return sortedSprints[sortedSprints.length - 1];
      };
      $scope.$on("sprintform:create", function(event, projectId, uss) {
        var estimatedFinish, estimatedStart, lastSprint, lastSprintNameDom, prettyDate, text;
        ussToAdd = uss;
        resetSprint();
        form = $el.find("form").checksley();
        form.reset();
        createSprint = true;
        prettyDate = $translate.instant("COMMON.PICKERDATE.FORMAT");
        $scope.newSprint.project = projectId;
        $scope.newSprint.name = null;
        $scope.newSprint.slug = null;
        lastSprint = getLastSprint();
        estimatedStart = moment();
        if (lastSprint) {
          estimatedStart = moment(lastSprint.estimated_finish);
        } else if ($scope.newSprint.estimated_start) {
          estimatedStart = moment($scope.newSprint.estimated_start);
        }
        $scope.newSprint.estimated_start = estimatedStart.format(prettyDate);
        estimatedFinish = moment().add(2, "weeks");
        if (lastSprint) {
          estimatedFinish = moment(lastSprint.estimated_finish).add(2, "weeks");
        } else if ($scope.newSprint.estimated_finish) {
          estimatedFinish = moment($scope.newSprint.estimated_finish);
        }
        $scope.newSprint.estimated_finish = estimatedFinish.format(prettyDate);
        lastSprintNameDom = $el.find(".last-sprint-name");
        if ((lastSprint != null ? lastSprint.name : void 0) != null) {
          text = $translate.instant("LIGHTBOX.ADD_EDIT_SPRINT.LAST_SPRINT_NAME", {
            lastSprint: lastSprint.name
          });
          lastSprintNameDom.html(text);
        }
        $el.find(".delete-sprint").addClass("hidden");
        text = $translate.instant("LIGHTBOX.ADD_EDIT_SPRINT.TITLE");
        $el.find(".title").text(text);
        text = $translate.instant("COMMON.CREATE");
        $el.find(".button-green").text(text);
        lightboxService.open($el);
        $el.find(".sprint-name").focus();
        return $el.find(".last-sprint-name").removeClass("disappear");
      });
      $scope.$on("sprintform:edit", function(ctx, sprint) {
        var editSprint, prettyDate, save;
        resetSprint();
        createSprint = false;
        prettyDate = $translate.instant("COMMON.PICKERDATE.FORMAT");
        $scope.$apply(function() {
          $scope.newSprint = sprint.realClone();
          $scope.newSprint.estimated_start = moment($scope.newSprint.estimated_start).format(prettyDate);
          return $scope.newSprint.estimated_finish = moment($scope.newSprint.estimated_finish).format(prettyDate);
        });
        $el.find(".delete-sprint").removeClass("hidden");
        editSprint = $translate.instant("BACKLOG.EDIT_SPRINT");
        $el.find(".title").text(editSprint);
        save = $translate.instant("COMMON.SAVE");
        $el.find(".button-green").text(save);
        lightboxService.open($el);
        $el.find(".sprint-name").focus().select();
        return $el.find(".last-sprint-name").addClass("disappear");
      });
      $el.on("keyup", ".sprint-name", function(event) {
        if ($el.find(".sprint-name").val().length > 0 || hasErrors) {
          return $el.find(".last-sprint-name").addClass("disappear");
        } else {
          return $el.find(".last-sprint-name").removeClass("disappear");
        }
      });
      $el.on("submit", "form", submit);
      $el.on("click", ".delete-sprint", function(event) {
        event.preventDefault();
        return remove();
      });
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return resetSprint();
    };
    return {
      link: link
    };
  };

  module.directive("tgLbCreateEditSprint", ["$tgRepo", "$tgConfirm", "$tgResources", "$rootScope", "lightboxService", "$tgLoading", "$translate", CreateEditSprint]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/backlog/main.coffee
 */

(function() {
  var BacklogController, BacklogDirective, BurndownBacklogGraphDirective, TgBacklogProgressBarDirective, ToggleBurndownVisibility, UsPointsDirective, UsRolePointsSelectorDirective, bindMethods, bindOnce, generateHash, groupBy, mixOf, module, scopeDefer, taiga, timeout, toggleText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  toggleText = this.taiga.toggleText;

  scopeDefer = this.taiga.scopeDefer;

  bindOnce = this.taiga.bindOnce;

  groupBy = this.taiga.groupBy;

  timeout = this.taiga.timeout;

  bindMethods = this.taiga.bindMethods;

  generateHash = this.taiga.generateHash;

  module = angular.module("taigaBacklog");

  BacklogController = (function(superClass) {
    extend(BacklogController, superClass);

    BacklogController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "tgAppMetaService", "$tgNavUrls", "$tgEvents", "$tgAnalytics", "$translate", "$tgLoading", "tgResources", "$tgQueueModelTransformation", "tgErrorHandlingService", "$tgStorage", "tgFilterRemoteStorageService", "tgProjectService", "tgLoader"];

    BacklogController.prototype.storeCustomFiltersName = 'backlog-custom-filters';

    BacklogController.prototype.storeFiltersName = 'backlog-filters';

    BacklogController.prototype.backlogOrder = {};

    BacklogController.prototype.milestonesOrder = {};

    function BacklogController(scope1, rootscope, repo, confirm, rs, params1, q, location, appMetaService, navUrls, events, analytics, translate, loading, rs2, modelTransform, errorHandlingService, storage, filterRemoteStorageService, projectService, tgLoader) {
      var promise;
      this.scope = scope1;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params1;
      this.q = q;
      this.location = location;
      this.appMetaService = appMetaService;
      this.navUrls = navUrls;
      this.events = events;
      this.analytics = analytics;
      this.translate = translate;
      this.loading = loading;
      this.rs2 = rs2;
      this.modelTransform = modelTransform;
      this.errorHandlingService = errorHandlingService;
      this.storage = storage;
      this.filterRemoteStorageService = filterRemoteStorageService;
      this.projectService = projectService;
      this.tgLoader = tgLoader;
      bindMethods(this);
      this.backlogOrder = {};
      this.milestonesOrder = {};
      this.page = 1;
      this.disablePagination = false;
      this.firstLoadComplete = false;
      this.scope.userstories = [];
      if (this.applyStoredFilters(this.params.pslug, "backlog-filters")) {
        return;
      }
      this.scope.sectionName = this.translate.instant("BACKLOG.SECTION_NAME");
      this.showTags = false;
      this.activeFilters = false;
      this.scope.showGraphPlaceholder = null;
      this.displayVelocity = false;
      this.initializeEventHandlers();
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          _this.firstLoadComplete = true;
          title = _this.translate.instant("BACKLOG.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.translate.instant("BACKLOG.PAGE_DESCRIPTION", {
            projectName: _this.scope.project.name,
            projectDescription: _this.scope.project.description
          });
          _this.appMetaService.setAll(title, description);
          if (_this.rs.userstories.getShowTags(_this.scope.projectId)) {
            _this.showTags = true;
            return _this.scope.$broadcast("showTags", _this.showTags);
          }
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    BacklogController.prototype.filtersReloadContent = function() {
      return this.loadUserstories(true);
    };

    BacklogController.prototype.initializeEventHandlers = function() {
      this.scope.$on("usform:bulk:success", (function(_this) {
        return function() {
          _this.loadUserstories(true);
          _this.loadProjectStats();
          _this.confirm.notify("success");
          return _this.analytics.trackEvent("userstory", "create", "bulk create userstory on backlog", 1);
        };
      })(this));
      this.scope.$on("sprintform:create:success", (function(_this) {
        return function(e, data, ussToMove) {
          _this.loadSprints().then(function() {
            return _this.scope.$broadcast("sprintform:create:success:callback", ussToMove);
          });
          _this.loadProjectStats();
          _this.confirm.notify("success");
          return _this.analytics.trackEvent("sprint", "create", "create sprint on backlog", 1);
        };
      })(this));
      this.scope.$on("usform:new:success", (function(_this) {
        return function() {
          _this.loadUserstories(true);
          _this.loadProjectStats();
          _this.rootscope.$broadcast("filters:update");
          return _this.analytics.trackEvent("userstory", "create", "create userstory on backlog", 1);
        };
      })(this));
      this.scope.$on("sprintform:edit:success", (function(_this) {
        return function() {
          return _this.loadProjectStats();
        };
      })(this));
      this.scope.$on("sprintform:remove:success", (function(_this) {
        return function(event, sprint) {
          _this.loadSprints();
          _this.loadProjectStats();
          _this.loadUserstories(true);
          if (sprint.closed) {
            _this.loadClosedSprints();
          }
          return _this.rootscope.$broadcast("filters:update");
        };
      })(this));
      this.scope.$on("usform:edit:success", (function(_this) {
        return function(event, data) {
          var index;
          index = _.findIndex(_this.scope.userstories, function(us) {
            return us.id === data.id;
          });
          _this.scope.userstories[index] = data;
          return _this.rootscope.$broadcast("filters:update");
        };
      })(this));
      this.scope.$on("filters:update", (function(_this) {
        return function() {
          var milestone;
          return _this.generateFilters(milestone = "null");
        };
      })(this));
      this.scope.$on("sprint:us:move", this.moveUs);
      this.scope.$on("sprint:us:moved", (function(_this) {
        return function() {
          _this.loadSprints();
          _this.loadProjectStats();
          return _this.rootscope.$broadcast("filters:update");
        };
      })(this));
      this.scope.$on("backlog:load-closed-sprints", this.loadClosedSprints);
      return this.scope.$on("backlog:unload-closed-sprints", this.unloadClosedSprints);
    };

    BacklogController.prototype.initializeSubscription = function() {
      var routingKey1, routingKey2;
      routingKey1 = "changes.project." + this.scope.projectId + ".userstories";
      this.events.subscribe(this.scope, routingKey1, (function(_this) {
        return function(message) {
          _this.loadAllPaginatedUserstories();
          return _this.loadSprints();
        };
      })(this));
      routingKey2 = "changes.project." + this.scope.projectId + ".milestones";
      return this.events.subscribe(this.scope, routingKey2, (function(_this) {
        return function(message) {
          return _this.loadSprints();
        };
      })(this));
    };

    BacklogController.prototype.toggleShowTags = function() {
      return this.scope.$apply((function(_this) {
        return function() {
          _this.showTags = !_this.showTags;
          return _this.rs.userstories.storeShowTags(_this.scope.projectId, _this.showTags);
        };
      })(this));
    };

    BacklogController.prototype.toggleActiveFilters = function() {
      return this.activeFilters = !this.activeFilters;
    };

    BacklogController.prototype.toggleVelocityForecasting = function() {
      this.displayVelocity = !this.displayVelocity;
      if (!this.displayVelocity) {
        this.scope.visibleUserStories = _.map(this.scope.userstories, function(it) {
          return it.ref;
        });
      } else {
        this.scope.visibleUserStories = _.map(this.forecastedStories, function(it) {
          return it.ref;
        });
      }
      return scopeDefer(this.scope, (function(_this) {
        return function() {
          return _this.scope.$broadcast("userstories:loaded");
        };
      })(this));
    };

    BacklogController.prototype.loadProjectStats = function() {
      return this.rs.projects.stats(this.scope.projectId).then((function(_this) {
        return function(stats) {
          var totalPoints;
          _this.scope.stats = stats;
          totalPoints = stats.total_points ? stats.total_points : stats.defined_points;
          if (totalPoints) {
            _this.scope.stats.completedPercentage = Math.round(100 * stats.closed_points / totalPoints);
          } else {
            _this.scope.stats.completedPercentage = 0;
          }
          _this.scope.showGraphPlaceholder = !((stats.total_points != null) && (stats.total_milestones != null));
          _this.calculateForecasting();
          return stats;
        };
      })(this));
    };

    BacklogController.prototype.setMilestonesOrder = function(sprints) {
      var it, j, len, results, sprint;
      results = [];
      for (j = 0, len = sprints.length; j < len; j++) {
        sprint = sprints[j];
        this.milestonesOrder[sprint.id] = {};
        results.push((function() {
          var l, len1, ref1, results1;
          ref1 = sprint.user_stories;
          results1 = [];
          for (l = 0, len1 = ref1.length; l < len1; l++) {
            it = ref1[l];
            results1.push(this.milestonesOrder[sprint.id][it.id] = it.sprint_order);
          }
          return results1;
        }).call(this));
      }
      return results;
    };

    BacklogController.prototype.unloadClosedSprints = function() {
      return this.scope.$apply((function(_this) {
        return function() {
          _this.scope.closedSprints = [];
          return _this.rootscope.$broadcast("closed-sprints:reloaded", []);
        };
      })(this));
    };

    BacklogController.prototype.loadClosedSprints = function() {
      var params;
      params = {
        closed: true
      };
      return this.rs.sprints.list(this.scope.projectId, params).then((function(_this) {
        return function(result) {
          var j, len, sprint, sprints;
          sprints = result.milestones;
          _this.setMilestonesOrder(sprints);
          _this.scope.totalClosedMilestones = result.closed;
          for (j = 0, len = sprints.length; j < len; j++) {
            sprint = sprints[j];
            sprint.user_stories = _.sortBy(sprint.user_stories, "sprint_order");
          }
          _this.scope.closedSprints = sprints;
          _this.scope.closedSprintsById = groupBy(sprints, function(x) {
            return x.id;
          });
          _this.rootscope.$broadcast("closed-sprints:reloaded", sprints);
          return sprints;
        };
      })(this));
    };

    BacklogController.prototype.loadSprints = function() {
      var params;
      params = {
        closed: false
      };
      return this.rs.sprints.list(this.scope.projectId, params).then((function(_this) {
        return function(result) {
          var j, len, sprint, sprints;
          sprints = result.milestones;
          _this.setMilestonesOrder(sprints);
          _this.scope.totalMilestones = sprints;
          _this.scope.totalClosedMilestones = result.closed;
          _this.scope.totalOpenMilestones = result.open;
          _this.scope.totalMilestones = _this.scope.totalOpenMilestones + _this.scope.totalClosedMilestones;
          for (j = 0, len = sprints.length; j < len; j++) {
            sprint = sprints[j];
            sprint.user_stories = _.sortBy(sprint.user_stories, "sprint_order");
          }
          _this.scope.sprints = sprints;
          if (!_this.scope.closedSprints) {
            _this.scope.closedSprints = [];
          }
          _this.scope.sprintsCounter = sprints.length;
          _this.scope.sprintsById = groupBy(sprints, function(x) {
            return x.id;
          });
          _this.rootscope.$broadcast("sprints:loaded", sprints);
          _this.scope.currentSprint = _this.findCurrentSprint();
          return sprints;
        };
      })(this));
    };

    BacklogController.prototype.openSprints = function() {
      return _.filter(this.scope.sprints, (function(_this) {
        return function(sprint) {
          return !sprint.closed;
        };
      })(this)).reverse();
    };

    BacklogController.prototype.loadAllPaginatedUserstories = function() {
      var page;
      page = this.page;
      return this.loadUserstories(true, this.scope.userstories.length).then((function(_this) {
        return function() {
          return _this.page = page;
        };
      })(this));
    };

    BacklogController.prototype.loadUserstories = function(resetPagination, pageSize) {
      var params, promise;
      if (resetPagination == null) {
        resetPagination = false;
      }
      if (!this.scope.projectId) {
        return null;
      }
      this.loadingUserstories = true;
      this.disablePagination = true;
      params = _.clone(this.location.search());
      this.rs.userstories.storeQueryParams(this.scope.projectId, params);
      if (resetPagination) {
        this.page = 1;
      }
      params.page = this.page;
      promise = this.rs.userstories.listUnassigned(this.scope.projectId, params, pageSize);
      return promise.then((function(_this) {
        return function(result) {
          var header, it, j, len, ref1, userstories;
          userstories = result[0];
          header = result[1];
          if (resetPagination) {
            _this.scope.userstories = [];
          }
          _this.scope.userstories = _this.scope.userstories.concat(_.sortBy(userstories, "backlog_order"));
          _this.scope.visibleUserStories = _.map(_this.scope.userstories, function(it) {
            return it.ref;
          });
          ref1 = _this.scope.userstories;
          for (j = 0, len = ref1.length; j < len; j++) {
            it = ref1[j];
            _this.backlogOrder[it.id] = it.backlog_order;
          }
          _this.loadingUserstories = false;
          if (header('x-pagination-next')) {
            _this.disablePagination = false;
            _this.page++;
          }
          _this.rootscope.$broadcast("backlog:userstories:loaded");
          scopeDefer(_this.scope, function() {
            _this.scope.$broadcast("userstories:loaded");
            return _this.tgLoader.pageLoaded();
          });
          return userstories;
        };
      })(this));
    };

    BacklogController.prototype.loadBacklog = function() {
      return this.q.all([this.loadProjectStats(), this.loadSprints(), this.loadUserstories()]).then(this.calculateForecasting);
    };

    BacklogController.prototype.calculateForecasting = function() {
      var backlog_points_sum, current_sum, j, len, ref1, results, stats, total_points, us;
      stats = this.scope.stats;
      total_points = stats.total_points;
      current_sum = stats.assigned_points;
      backlog_points_sum = 0;
      this.forecastedStories = [];
      ref1 = this.scope.userstories;
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        us = ref1[j];
        current_sum += us.total_points;
        backlog_points_sum += us.total_points;
        this.forecastedStories.push(us);
        if (stats.speed > 0 && backlog_points_sum > stats.speed) {
          break;
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    BacklogController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      if (!project.is_backlog_activated) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.closedMilestones = !!project.total_closed_milestones;
      this.scope.$emit('project:loaded', project);
      this.scope.points = _.sortBy(project.points, "order");
      this.scope.pointsById = groupBy(project.points, function(x) {
        return x.id;
      });
      this.scope.usStatusById = groupBy(project.us_statuses, function(x) {
        return x.id;
      });
      this.scope.usStatusList = _.sortBy(project.us_statuses, "id");
      return project;
    };

    BacklogController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      this.initializeSubscription();
      return this.loadBacklog().then((function(_this) {
        return function() {
          var milestone;
          return _this.generateFilters(milestone = "null");
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.scope.$emit("backlog:loaded");
        };
      })(this));
    };

    BacklogController.prototype.prepareBulkUpdateData = function(uses, field) {
      if (field == null) {
        field = "backlog_order";
      }
      return _.map(uses, function(x) {
        return {
          "us_id": x.id,
          "order": x[field]
        };
      });
    };

    BacklogController.prototype.moveUs = function(ctx, usList, newUsIndex, newSprintId) {
      var afterDestination, beforeDestination, currentSprintId, data, it, j, key, l, len, len1, len2, len3, len4, len5, len6, len7, list, m, modifiedUs, n, newSprint, o, oldSprintId, options, orderField, orderList, p, previous, previousWithTheSameOrder, project, promise, q, r, ref1, ref2, setNextOrders, setOrders, setPreviousOrders, sprint, startIndex, us;
      oldSprintId = usList[0].milestone;
      project = usList[0].project;
      if (oldSprintId) {
        sprint = this.scope.sprintsById[oldSprintId] || this.scope.closedSprintsById[oldSprintId];
      }
      if (newSprintId) {
        newSprint = this.scope.sprintsById[newSprintId] || this.scope.closedSprintsById[newSprintId];
      }
      currentSprintId = newSprintId !== oldSprintId ? newSprintId : oldSprintId;
      orderList = null;
      orderField = "";
      if (newSprintId !== oldSprintId) {
        if (newSprintId === null) {
          for (key = j = 0, len = usList.length; j < len; key = ++j) {
            us = usList[key];
            _.remove(sprint.user_stories, function(it) {
              return it.id === us.id;
            });
          }
          orderField = "backlog_order";
          orderList = this.backlogOrder;
          beforeDestination = _.slice(this.scope.userstories, 0, newUsIndex);
          afterDestination = _.slice(this.scope.userstories, newUsIndex);
          this.scope.userstories = this.scope.userstories.concat(usList);
        } else {
          for (l = 0, len1 = usList.length; l < len1; l++) {
            us = usList[l];
            _.remove(this.scope.userstories, function(it) {
              return it.id === us.id;
            });
          }
          orderField = "sprint_order";
          orderList = this.milestonesOrder[newSprint.id];
          beforeDestination = _.slice(newSprint.user_stories, 0, newUsIndex);
          afterDestination = _.slice(newSprint.user_stories, newUsIndex);
          newSprint.user_stories = newSprint.user_stories.concat(usList);
        }
      } else {
        if (oldSprintId === null) {
          orderField = "backlog_order";
          orderList = this.backlogOrder;
          list = _.filter(this.scope.userstories, function(listIt) {
            return !_.find(usList, function(moveIt) {
              return listIt.id === moveIt.id;
            });
          });
          beforeDestination = _.slice(list, 0, newUsIndex);
          afterDestination = _.slice(list, newUsIndex);
        } else {
          orderField = "sprint_order";
          orderList = this.milestonesOrder[sprint.id];
          list = _.filter(newSprint.user_stories, function(listIt) {
            return !_.find(usList, function(moveIt) {
              return listIt.id === moveIt.id;
            });
          });
          beforeDestination = _.slice(list, 0, newUsIndex);
          afterDestination = _.slice(list, newUsIndex);
        }
      }
      previous = beforeDestination[beforeDestination.length - 1];
      setPreviousOrders = [];
      if (!previous) {
        startIndex = 0;
      } else if (previous) {
        startIndex = orderList[previous.id] + 1;
        previousWithTheSameOrder = _.filter(beforeDestination, function(it) {
          return it[orderField] === orderList[previous.id];
        });
        if (previousWithTheSameOrder.length > 1) {
          setPreviousOrders = _.map(previousWithTheSameOrder, function(it) {
            return {
              us_id: it.id,
              order: orderList[it.id]
            };
          });
        }
      }
      modifiedUs = [];
      for (key = m = 0, len2 = usList.length; m < len2; key = ++m) {
        us = usList[key];
        us.milestone = currentSprintId;
        us[orderField] = startIndex + key;
        orderList[us.id] = us[orderField];
        modifiedUs.push({
          us_id: us.id,
          order: us[orderField]
        });
      }
      startIndex = orderList[usList[usList.length - 1].id];
      for (key = n = 0, len3 = afterDestination.length; n < len3; key = ++n) {
        it = afterDestination[key];
        orderList[it.id] = startIndex + key + 1;
      }
      setNextOrders = _.map(afterDestination, (function(_this) {
        return function(it) {
          return {
            us_id: it.id,
            order: orderList[it.id]
          };
        };
      })(this));
      this.scope.userstories = _.sortBy(this.scope.userstories, (function(_this) {
        return function(it) {
          return _this.backlogOrder[it.id];
        };
      })(this));
      this.scope.visibleUserStories = _.map(this.scope.userstories, function(it) {
        return it.ref;
      });
      ref1 = this.scope.sprints;
      for (o = 0, len4 = ref1.length; o < len4; o++) {
        sprint = ref1[o];
        sprint.user_stories = _.sortBy(sprint.user_stories, (function(_this) {
          return function(it) {
            return _this.milestonesOrder[sprint.id][it.id];
          };
        })(this));
      }
      ref2 = this.scope.closedSprints;
      for (p = 0, len5 = ref2.length; p < len5; p++) {
        sprint = ref2[p];
        sprint.user_stories = _.sortBy(sprint.user_stories, (function(_this) {
          return function(it) {
            return _this.milestonesOrder[sprint.id][it.id];
          };
        })(this));
      }
      if (usList.length > 1 && (newSprintId !== oldSprintId)) {
        data = modifiedUs.concat(setPreviousOrders, setNextOrders);
        promise = this.rs.userstories.bulkUpdateMilestone(project, newSprintId, data);
      } else if (usList.length > 1) {
        data = modifiedUs.concat(setPreviousOrders, setNextOrders);
        promise = this.rs.userstories.bulkUpdateBacklogOrder(project, data);
      } else {
        setOrders = {};
        for (q = 0, len6 = setPreviousOrders.length; q < len6; q++) {
          it = setPreviousOrders[q];
          setOrders[it.us_id] = it.order;
        }
        for (r = 0, len7 = setNextOrders.length; r < len7; r++) {
          it = setNextOrders[r];
          setOrders[it.us_id] = it.order;
        }
        options = {
          headers: {
            "set-orders": JSON.stringify(setOrders)
          }
        };
        promise = this.repo.save(usList[0], true, {}, options, true);
      }
      promise.then((function(_this) {
        return function() {
          _this.rootscope.$broadcast("sprint:us:moved");
          if (_this.scope.closedSprintsById && _this.scope.closedSprintsById[oldSprintId]) {
            return _this.rootscope.$broadcast("backlog:load-closed-sprints");
          }
        };
      })(this));
      return promise;
    };

    BacklogController.prototype.updateUserStoryStatus = function() {
      return this.generateFilters().then((function(_this) {
        return function() {
          _this.rootscope.$broadcast("filters:update");
          _this.loadProjectStats();
          if (_this.isFilterDataTypeSelected('status')) {
            return _this.filtersReloadContent();
          }
        };
      })(this));
    };

    BacklogController.prototype.editUserStory = function(projectId, ref, $event) {
      var currentLoading, target;
      target = $($event.target);
      currentLoading = this.loading().target(target).removeClasses("edit-story").timeout(200).start();
      return this.rs.userstories.getByRef(projectId, ref).then((function(_this) {
        return function(us) {
          return _this.rs2.attachments.list("us", us.id, projectId).then(function(attachments) {
            _this.rootscope.$broadcast("genericform:edit", {
              'objType': 'us',
              'obj': us,
              'attachments': attachments.toJS()
            });
            return currentLoading.finish();
          });
        };
      })(this));
    };

    BacklogController.prototype.deleteUserStory = function(us) {
      var message, title;
      title = this.translate.instant("US.TITLE_DELETE_ACTION");
      message = us.subject;
      return this.confirm.askOnDelete(title, message).then((function(_this) {
        return function(askResponse) {
          var promise;
          _this.scope.userstories = _.without(_this.scope.userstories, us);
          promise = _this.repo.remove(us);
          promise.then(function() {
            askResponse.finish();
            return _this.q.all([_this.loadProjectStats(), _this.loadSprints()]);
          });
          return promise.then(null, function() {
            askResponse.finish(false);
            return _this.confirm.notify("error");
          });
        };
      })(this));
    };

    BacklogController.prototype.addNewUs = function(type) {
      switch (type) {
        case "standard":
          return this.rootscope.$broadcast("genericform:new", {
            'objType': 'us',
            'project': this.scope.project
          });
        case "bulk":
          return this.rootscope.$broadcast("usform:bulk", this.scope.projectId, this.scope.project.default_us_status);
      }
    };

    BacklogController.prototype.addNewSprint = function() {
      return this.rootscope.$broadcast("sprintform:create", this.scope.projectId);
    };

    BacklogController.prototype.findCurrentSprint = function() {
      var currentDate;
      currentDate = new Date().getTime();
      return _.find(this.scope.sprints, function(sprint) {
        var end, start;
        start = moment(sprint.estimated_start, 'YYYY-MM-DD').format('x');
        end = moment(sprint.estimated_finish, 'YYYY-MM-DD').format('x');
        return currentDate >= start && currentDate <= end;
      });
    };

    return BacklogController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin, taiga.UsFiltersMixin));

  module.controller("BacklogController", BacklogController);

  BacklogDirective = function($repo, $rootscope, $translate, $rs) {
    var doomLineTemplate, link, linkDoomLine, linkFilters, linkToolbar, openFilterInit, showHideFilter, showHideTags;
    doomLineTemplate = _.template("<div class=\"doom-line\"><span><%- text %></span></div>");
    linkDoomLine = function($scope, $el, $attrs, $ctrl) {
      var addDoomLineDom, getUsItems, reloadDoomLine, removeDoomlineDom;
      reloadDoomLine = function() {
        var current_sum, domElement, i, j, len, ref1, results, stats, total_points, us;
        if ($scope.displayVelocity) {
          removeDoomlineDom();
        }
        if (($scope.stats != null) && ($scope.stats.total_points != null) && $scope.stats.total_points !== 0 && ($scope.displayVelocity == null)) {
          removeDoomlineDom();
          stats = $scope.stats;
          total_points = stats.total_points;
          current_sum = stats.assigned_points;
          if (!$scope.userstories) {
            return;
          }
          ref1 = $scope.userstories;
          results = [];
          for (i = j = 0, len = ref1.length; j < len; i = ++j) {
            us = ref1[i];
            current_sum += us.total_points;
            if (current_sum > total_points) {
              domElement = $el.find('.backlog-table-body .us-item-row')[i];
              addDoomLineDom(domElement);
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
      removeDoomlineDom = function() {
        return $el.find(".doom-line").remove();
      };
      addDoomLineDom = function(element) {
        var text;
        text = $translate.instant("BACKLOG.DOOMLINE");
        return $(element).before(doomLineTemplate({
          "text": text
        }));
      };
      getUsItems = function() {
        var rowElements;
        rowElements = $el.find('.backlog-table-body .us-item-row');
        return _.map(rowElements, function(x) {
          return angular.element(x);
        });
      };
      $scope.$on("userstories:loaded", reloadDoomLine);
      $scope.$on("userstories:forecast", removeDoomlineDom);
      return $scope.$watch("stats", reloadDoomLine);
    };
    linkToolbar = function($scope, $el, $attrs, $ctrl) {
      var checkSelected, getUsToMove, lastChecked, moveToCurrentSprint, moveToLatestSprint, moveUssToSprint, shiftPressed;
      getUsToMove = function() {
        var ussDom;
        ussDom = $el.find(".backlog-table-body input:checkbox:checked");
        return _.map(ussDom, function(item) {
          var itemScope;
          item = $(item).closest('.tg-scope');
          itemScope = item.scope();
          itemScope.us.milestone = $scope.sprints[0].id;
          return itemScope.us;
        });
      };
      moveUssToSprint = function(selectedUss, sprint) {
        var data, extraPoints, totalExtraPoints, ussCurrent;
        ussCurrent = _($scope.userstories);
        $scope.userstories = ussCurrent.without.apply(ussCurrent, selectedUss).value();
        extraPoints = _.map(selectedUss, function(v, k) {
          return v.total_points;
        });
        totalExtraPoints = _.reduce(extraPoints, function(acc, num) {
          return acc + num;
        });
        sprint.user_stories = _.union(sprint.user_stories, selectedUss);
        sprint.total_points += totalExtraPoints;
        data = _.map(selectedUss, function(us) {
          return {
            us_id: us.id,
            order: us.sprint_order
          };
        });
        $rs.userstories.bulkUpdateMilestone($scope.project.id, $scope.sprints[0].id, data).then((function(_this) {
          return function() {
            $ctrl.loadSprints();
            $ctrl.loadProjectStats();
            $ctrl.toggleVelocityForecasting();
            return $ctrl.calculateForecasting();
          };
        })(this));
        return $el.find(".move-to-sprint").hide();
      };
      moveToCurrentSprint = function(selectedUss) {
        return moveUssToSprint(selectedUss, $scope.currentSprint);
      };
      moveToLatestSprint = function(selectedUss) {
        return moveUssToSprint(selectedUss, $scope.sprints[0]);
      };
      $scope.$on("sprintform:create:success:callback", function(e, ussToMove) {
        if (ussToMove) {
          return _.partial(moveToCurrentSprint, ussToMove)();
        }
      });
      shiftPressed = false;
      lastChecked = null;
      checkSelected = function(target) {
        var moveToSprintDom, selectedUsDom;
        lastChecked = target.closest(".us-item-row");
        target.closest('.us-item-row').toggleClass('ui-multisortable-multiple');
        moveToSprintDom = $el.find(".move-to-sprint");
        selectedUsDom = $el.find(".backlog-table-body input:checkbox:checked");
        if (selectedUsDom.length > 0 && $scope.sprints.length > 0) {
          return moveToSprintDom.show();
        } else {
          return moveToSprintDom.hide();
        }
      };
      $(window).on("keydown.shift-pressed keyup.shift-pressed", function(event) {
        shiftPressed = !!event.shiftKey;
        return true;
      });
      $el.on("change", ".backlog-table-body input:checkbox", function(event) {
        var current, elements, nextAll, prevAll, target;
        if (lastChecked && shiftPressed) {
          elements = [];
          current = $(event.currentTarget).closest(".us-item-row");
          nextAll = lastChecked.nextAll();
          prevAll = lastChecked.prevAll();
          if (_.some(nextAll, function(next) {
            return next === current[0];
          })) {
            elements = lastChecked.nextUntil(current);
          } else if (_.some(prevAll, function(prev) {
            return prev === current[0];
          })) {
            elements = lastChecked.prevUntil(current);
          }
          _.map(elements, function(elm) {
            var input;
            input = $(elm).find("input:checkbox");
            input.prop('checked', true);
            return checkSelected(input);
          });
        }
        target = angular.element(event.currentTarget);
        target.closest(".us-item-row").toggleClass('is-checked');
        return checkSelected(target);
      });
      $el.on("click", "#move-to-latest-sprint", (function(_this) {
        return function(event) {
          var ussToMove;
          ussToMove = getUsToMove();
          return $scope.$apply(_.partial(moveToLatestSprint, ussToMove));
        };
      })(this));
      $el.on("click", "#move-to-current-sprint", (function(_this) {
        return function(event) {
          var ussToMove;
          ussToMove = getUsToMove();
          return $scope.$apply(_.partial(moveToCurrentSprint, ussToMove));
        };
      })(this));
      $el.on("click", "#show-tags", function(event) {
        event.preventDefault();
        $ctrl.toggleShowTags();
        return showHideTags($ctrl);
      });
      return $el.on("click", ".forecasting-add-sprint", function(event) {
        var ussToMove, ussToMoveList;
        ussToMoveList = $ctrl.forecastedStories;
        if ($scope.currentSprint) {
          ussToMove = _.map(ussToMoveList, function(us, index) {
            us.milestone = $scope.currentSprint.id;
            us.order = index;
            return us;
          });
          return $scope.$apply(_.partial(moveToCurrentSprint, ussToMove));
        } else {
          ussToMove = _.map(ussToMoveList, function(us, index) {
            us.order = index;
            return us;
          });
          return $rootscope.$broadcast("sprintform:create", $scope.projectId, ussToMove);
        }
      });
    };
    showHideTags = function($ctrl) {
      var elm, text;
      elm = angular.element("#show-tags");
      if ($ctrl.showTags) {
        elm.addClass("active");
        text = $translate.instant("BACKLOG.TAGS.HIDE");
        return elm.text(text);
      } else {
        elm.removeClass("active");
        text = $translate.instant("BACKLOG.TAGS.SHOW");
        return elm.text(text);
      }
    };
    openFilterInit = function($scope, $el, $ctrl) {
      var sidebar;
      sidebar = $el.find("sidebar.backlog-filter");
      sidebar.addClass("active");
      return $ctrl.activeFilters = true;
    };
    showHideFilter = function($scope, $el, $ctrl) {
      var hideText, showText, sidebar, target;
      sidebar = $el.find("sidebar.backlog-filter");
      sidebar.one("transitionend", function() {
        return timeout(150, function() {
          $rootscope.$broadcast("resize");
          return $('.burndown').css("visibility", "visible");
        });
      });
      target = angular.element("#show-filters-button");
      $('.burndown').css("visibility", "hidden");
      sidebar.toggleClass("active");
      target.toggleClass("active");
      hideText = $translate.instant("BACKLOG.FILTERS.HIDE");
      showText = $translate.instant("BACKLOG.FILTERS.SHOW");
      toggleText(target, [hideText, showText]);
      return $ctrl.toggleActiveFilters();
    };
    linkFilters = function($scope, $el, $attrs, $ctrl) {
      $scope.filtersSearch = {};
      return $el.on("click", "#show-filters-button", function(event) {
        event.preventDefault();
        return $scope.$apply(function() {
          return showHideFilter($scope, $el, $ctrl);
        });
      });
    };
    link = function($scope, $el, $attrs, $rootscope) {
      var $ctrl, filters;
      $ctrl = $el.controller();
      linkToolbar($scope, $el, $attrs, $ctrl);
      linkFilters($scope, $el, $attrs, $ctrl);
      linkDoomLine($scope, $el, $attrs, $ctrl);
      filters = $ctrl.location.search();
      if (filters.status || filters.tags || filters.q || filters.assigned_to || filters.owner) {
        openFilterInit($scope, $el, $ctrl);
      }
      $scope.$on("showTags", function() {
        return showHideTags($ctrl);
      });
      return $scope.$on("$destroy", function() {
        $el.off();
        return $(window).off(".shift-pressed");
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgBacklog", ["$tgRepo", "$rootScope", "$translate", "$tgResources", BacklogDirective]);

  UsRolePointsSelectorDirective = function($rootscope, $template, $compile, $translate) {
    var link, selectionTemplate;
    selectionTemplate = $template.get("backlog/us-role-points-popover.html", true);
    link = function($scope, $el, $attrs) {
      bindOnce($scope, "project", function(project) {
        var numberOfRoles, roles;
        roles = _.filter(project.roles, "computable");
        numberOfRoles = _.size(roles);
        if (numberOfRoles > 1) {
          return $el.append($compile(selectionTemplate({
            "roles": roles
          }))($scope));
        } else {
          $el.find(".icon-arrow-down").remove();
          return $el.find(".header-points").addClass("not-clickable");
        }
      });
      $scope.$on("uspoints:select", function(ctx, roleId, roleName) {
        $el.find(".popover").popover().close();
        return $el.find(".header-points").html(roleName + "/<span>Total</span>");
      });
      $scope.$on("uspoints:clear-selection", function(ctx, roleId) {
        var text;
        $el.find(".popover").popover().close();
        text = $translate.instant("COMMON.FIELDS.POINTS");
        return $el.find(".header-points").text(text);
      });
      $el.on("click", function(event) {
        var target;
        target = angular.element(event.target);
        if (target.is("span") || target.is("div")) {
          event.stopPropagation();
        }
        return $el.find(".popover").popover().open();
      });
      $el.on("click", ".clear-selection", function(event) {
        event.preventDefault();
        event.stopPropagation();
        return $rootscope.$broadcast("uspoints:clear-selection");
      });
      $el.on("click", ".role", function(event) {
        var rolScope, target;
        event.preventDefault();
        event.stopPropagation();
        target = angular.element(event.currentTarget);
        rolScope = target.scope();
        return $rootscope.$broadcast("uspoints:select", target.data("role-id"), target.text());
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgUsRolePointsSelector", ["$rootScope", "$tgTemplate", "$compile", "$translate", UsRolePointsSelectorDirective]);

  UsPointsDirective = function($tgEstimationsService, $repo, $tgTemplate) {
    var link, rolesTemplate;
    rolesTemplate = $tgTemplate.get("common/estimation/us-points-roles-popover.html", true);
    link = function($scope, $el, $attrs) {
      var $ctrl, bindClickElements, estimationProcess, filteringRoleId, renderRolesSelector, selectedRoleId, updatingSelectedRoleId;
      $ctrl = $el.controller();
      updatingSelectedRoleId = null;
      selectedRoleId = null;
      filteringRoleId = null;
      estimationProcess = null;
      $scope.$on("uspoints:select", function(ctx, roleId, roleName) {
        var us;
        us = $scope.$eval($attrs.tgBacklogUsPoints);
        selectedRoleId = roleId;
        return estimationProcess.render();
      });
      $scope.$on("uspoints:clear-selection", function(ctx) {
        var us;
        us = $scope.$eval($attrs.tgBacklogUsPoints);
        selectedRoleId = null;
        return estimationProcess.render();
      });
      $scope.$watch($attrs.tgBacklogUsPoints, function(us) {
        var roles;
        if (us) {
          estimationProcess = $tgEstimationsService.create($el, us, $scope.project);
          roles = estimationProcess.calculateRoles();
          if (roles.length === 0) {
            $el.find(".icon-arrow-bottom").remove();
            $el.find("a.us-points").addClass("not-clickable");
          } else if (roles.length === 1) {
            selectedRoleId = _.keys(us.points)[0];
          }
          if (estimationProcess.isEditable) {
            bindClickElements();
          }
          estimationProcess.onSelectedPointForRole = function(roleId, pointId, points) {
            us.points = points;
            estimationProcess.render();
            return this.save(roleId, pointId).then(function() {
              return $ctrl.loadProjectStats();
            });
          };
          estimationProcess.render = function() {
            var ctx, html, mainTemplate, pointId, pointObj, template, text, title, totalPoints;
            totalPoints = this.calculateTotalPoints();
            if ((selectedRoleId == null) || roles.length === 1) {
              text = totalPoints;
              title = totalPoints;
            } else {
              pointId = this.us.points[selectedRoleId];
              pointObj = this.pointsById[pointId];
              text = pointObj.name + " / <span>" + totalPoints + "</span>";
              title = pointObj.name + " / " + totalPoints;
            }
            ctx = {
              totalPoints: totalPoints,
              roles: this.calculateRoles(),
              editable: this.isEditable,
              text: text,
              title: title
            };
            mainTemplate = "common/estimation/us-estimation-total.html";
            template = $tgTemplate.get(mainTemplate, true);
            html = template(ctx);
            return this.$el.html(html);
          };
          return estimationProcess.render();
        }
      });
      renderRolesSelector = function() {
        var html, roles;
        roles = estimationProcess.calculateRoles();
        html = rolesTemplate({
          "roles": roles
        });
        $el.append(html);
        return $el.find(".pop-role").popover().open(function() {
          return $(this).remove();
        });
      };
      bindClickElements = function() {
        $el.on("click", "a.us-points", function(event) {
          var us;
          event.preventDefault();
          event.stopPropagation();
          us = $scope.$eval($attrs.tgBacklogUsPoints);
          updatingSelectedRoleId = selectedRoleId;
          if (selectedRoleId != null) {
            return estimationProcess.renderPointsSelector(selectedRoleId);
          } else {
            return renderRolesSelector();
          }
        });
        return $el.on("click", ".role", function(event) {
          var popRolesDom, target, us;
          event.preventDefault();
          event.stopPropagation();
          target = angular.element(event.currentTarget);
          us = $scope.$eval($attrs.tgBacklogUsPoints);
          updatingSelectedRoleId = target.data("role-id");
          popRolesDom = $el.find(".pop-role");
          popRolesDom.find("a").removeClass("active");
          popRolesDom.find("a[data-role-id='" + updatingSelectedRoleId + "']").addClass("active");
          return estimationProcess.renderPointsSelector(updatingSelectedRoleId);
        });
      };
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgBacklogUsPoints", ["$tgEstimationsService", "$tgRepo", "$tgTemplate", UsPointsDirective]);

  ToggleBurndownVisibility = function($storage) {
    var hide, link, show;
    hide = function() {
      $(".js-burndown-graph").removeClass("shown");
      $(".js-toggle-burndown-visibility-button").removeClass("active");
      return $(".js-burndown-graph").removeClass("open");
    };
    show = function(firstLoad) {
      $(".js-toggle-burndown-visibility-button").addClass("active");
      if (firstLoad) {
        return $(".js-burndown-graph").addClass("shown");
      } else {
        return $(".js-burndown-graph").addClass("open");
      }
    };
    link = function($scope, $el, $attrs) {
      var firstLoad, hash, toggleGraph;
      firstLoad = true;
      hash = generateHash(["is-burndown-grpahs-collapsed"]);
      $scope.isBurndownGraphCollapsed = $storage.get(hash) || false;
      toggleGraph = function() {
        if ($scope.isBurndownGraphCollapsed) {
          hide(firstLoad);
        } else {
          show(firstLoad);
        }
        return firstLoad = false;
      };
      $scope.$watch("showGraphPlaceholder", function() {
        if ($scope.showGraphPlaceholder != null) {
          $scope.isBurndownGraphCollapsed = $scope.isBurndownGraphCollapsed || $scope.showGraphPlaceholder;
          return toggleGraph();
        }
      });
      $el.on("click", ".js-toggle-burndown-visibility-button", function() {
        $scope.isBurndownGraphCollapsed = !$scope.isBurndownGraphCollapsed;
        $storage.set(hash, $scope.isBurndownGraphCollapsed);
        return toggleGraph();
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgToggleBurndownVisibility", ["$tgStorage", ToggleBurndownVisibility]);

  BurndownBacklogGraphDirective = function($translate) {
    var link, redrawChart;
    redrawChart = function(element, dataToDraw) {
      var client_increment_line, colors, data, evolution_line, j, milestonesRange, optimal_line, options, ref1, results, team_increment_line, width, zero_line;
      width = element.width();
      element.height(width / 6);
      milestonesRange = (function() {
        results = [];
        for (var j = 0, ref1 = dataToDraw.milestones.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; 0 <= ref1 ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this);
      data = [];
      zero_line = _.map(dataToDraw.milestones, function(ml) {
        return 0;
      });
      data.push({
        data: _.zip(milestonesRange, zero_line),
        lines: {
          fillColor: "rgba(0,0,0,0)"
        },
        points: {
          show: false
        }
      });
      optimal_line = _.map(dataToDraw.milestones, function(ml) {
        return ml.optimal;
      });
      data.push({
        data: _.zip(milestonesRange, optimal_line),
        lines: {
          fillColor: "rgba(120,120,120,0.2)"
        }
      });
      evolution_line = _.filter(_.map(dataToDraw.milestones, function(ml) {
        return ml.evolution;
      }), function(evolution) {
        return evolution != null;
      });
      data.push({
        data: _.zip(milestonesRange, evolution_line),
        lines: {
          fillColor: "rgba(102,153,51,0.3)"
        }
      });
      client_increment_line = _.map(dataToDraw.milestones, function(ml) {
        return -ml["team-increment"] - ml["client-increment"];
      });
      data.push({
        data: _.zip(milestonesRange, client_increment_line),
        lines: {
          fillColor: "rgba(255,51,51,0.3)"
        }
      });
      team_increment_line = _.map(dataToDraw.milestones, function(ml) {
        return -ml["team-increment"];
      });
      data.push({
        data: _.zip(milestonesRange, team_increment_line),
        lines: {
          fillColor: "rgba(153,51,51,0.3)"
        }
      });
      colors = ["rgba(0,0,0,1)", "rgba(120,120,120,0.2)", "rgba(102,153,51,1)", "rgba(153,51,51,1)", "rgba(255,51,51,1)"];
      options = {
        grid: {
          borderWidth: {
            top: 0,
            right: 1,
            left: 0,
            bottom: 0
          },
          borderColor: "#ccc",
          hoverable: true
        },
        xaxis: {
          ticks: dataToDraw.milestones.length,
          axisLabel: $translate.instant("BACKLOG.CHART.XAXIS_LABEL"),
          axisLabelUseCanvas: true,
          axisLabelFontSizePixels: 12,
          axisLabelFontFamily: "Verdana, Arial, Helvetica, Tahoma, sans-serif",
          axisLabelPadding: 5,
          tickFormatter: function(val, axis) {
            return "";
          }
        },
        yaxis: {
          axisLabel: $translate.instant("BACKLOG.CHART.YAXIS_LABEL"),
          axisLabelUseCanvas: true,
          axisLabelFontSizePixels: 12,
          axisLabelFontFamily: "Verdana, Arial, Helvetica, Tahoma, sans-serif",
          axisLabelPadding: 5
        },
        series: {
          shadowSize: 0,
          lines: {
            show: true,
            fill: true
          },
          points: {
            show: true,
            fill: true,
            radius: 4,
            lineWidth: 2
          }
        },
        colors: colors,
        tooltip: true,
        tooltipOpts: {
          content: function(label, xval, yval, flotItem) {
            var ctx;
            if (flotItem.seriesIndex === 1) {
              ctx = {
                sprintName: dataToDraw.milestones[xval].name,
                value: Math.abs(yval)
              };
              return $translate.instant("BACKLOG.CHART.OPTIMAL", ctx);
            } else if (flotItem.seriesIndex === 2) {
              ctx = {
                sprintName: dataToDraw.milestones[xval].name,
                value: Math.abs(yval)
              };
              return $translate.instant("BACKLOG.CHART.REAL", ctx);
            } else if (flotItem.seriesIndex === 3) {
              ctx = {
                sprintName: dataToDraw.milestones[xval].name,
                value: Math.abs(yval)
              };
              return $translate.instant("BACKLOG.CHART.INCREMENT_CLIENT", ctx);
            } else {
              ctx = {
                sprintName: dataToDraw.milestones[xval].name,
                value: Math.abs(yval)
              };
              return $translate.instant("BACKLOG.CHART.INCREMENT_TEAM", ctx);
            }
          }
        }
      };
      element.empty();
      return element.plot(data, options).data("plot");
    };
    link = function($scope, $el, $attrs) {
      var element;
      element = angular.element($el);
      $scope.$watch("stats", function(value) {
        if ($scope.stats != null) {
          redrawChart(element, $scope.stats);
          return $scope.$on("resize", function() {
            return redrawChart(element, $scope.stats);
          });
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgBurndownBacklogGraph", ["$translate", BurndownBacklogGraphDirective]);

  TgBacklogProgressBarDirective = function($template, $compile) {
    var adjustPercentaje, link, render, template;
    template = $template.get("backlog/progress-bar.html", true);
    render = function(scope, el, projectPointsPercentaje, closedPointsPercentaje) {
      var html;
      html = template({
        projectPointsPercentaje: projectPointsPercentaje,
        closedPointsPercentaje: closedPointsPercentaje
      });
      html = $compile(html)(scope);
      return el.html(html);
    };
    adjustPercentaje = function(percentage) {
      var adjusted;
      adjusted = _.max([0, percentage]);
      adjusted = _.min([100, adjusted]);
      return Math.round(adjusted);
    };
    link = function($scope, $el, $attrs) {
      var element;
      element = angular.element($el);
      $scope.$watch($attrs.tgBacklogProgressBar, function(stats) {
        var closedPoints, closedPointsPercentaje, definedPoints, projectPointsPercentaje, totalPoints;
        if (stats != null) {
          totalPoints = stats.total_points ? stats.total_points : stats.defined_points;
          definedPoints = stats.defined_points;
          closedPoints = stats.closed_points;
          if (definedPoints > totalPoints) {
            projectPointsPercentaje = totalPoints * 100 / definedPoints;
            closedPointsPercentaje = closedPoints * 100 / definedPoints;
          } else {
            projectPointsPercentaje = 100;
            closedPointsPercentaje = closedPoints * 100 / totalPoints;
          }
          projectPointsPercentaje = adjustPercentaje(projectPointsPercentaje - 3);
          closedPointsPercentaje = adjustPercentaje(closedPointsPercentaje - 3);
          return render($scope, $el, projectPointsPercentaje, closedPointsPercentaje);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgBacklogProgressBar", ["$tgTemplate", "$compile", TgBacklogProgressBarDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/backlog/sortable.coffee
 */

(function() {
  var BacklogSortableDirective, bindOnce, deleteElement, module, taiga;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaBacklog");

  deleteElement = function(el) {
    $(el).scope().$destroy();
    $(el).off();
    return $(el).remove();
  };

  BacklogSortableDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, "project", function(project) {
        var drake, initIsBacklog, scroll;
        if (!(project.my_permissions.indexOf("modify_us") > -1)) {
          return;
        }
        initIsBacklog = false;
        drake = dragula([$el[0], $('.js-empty-backlog')[0]], {
          copySortSource: false,
          copy: false,
          isContainer: function(el) {
            return el.classList.contains('sprint-table');
          },
          moves: function(item) {
            if (!$(item).hasClass('row')) {
              return false;
            }
            return true;
          }
        });
        drake.on('drag', function(item, container) {
          var isChecked, parent;
          parent = $(item).parent();
          initIsBacklog = parent.hasClass('backlog-table-body');
          $(document.body).addClass("drag-active");
          isChecked = $(item).find("input[type='checkbox']").is(":checked");
          return window.dragMultiple.start(item, container);
        });
        drake.on('cloned', function(item) {
          return $(item).addClass('multiple-drag-mirror');
        });
        drake.on('dragend', function(item) {
          var dragMultipleItems, firstElement, index, isBacklog, parent, ref, sameContainer, sprint, usList;
          $('.doom-line').remove();
          parent = $(item).parent();
          isBacklog = parent.hasClass('backlog-table-body') || parent.hasClass('js-empty-backlog');
          if (initIsBacklog || isBacklog) {
            sameContainer = initIsBacklog === isBacklog;
          } else {
            sameContainer = parent && $(item).scope().sprint.id === parent.scope().sprint.id;
          }
          dragMultipleItems = window.dragMultiple.stop();
          $(document.body).removeClass("drag-active");
          sprint = null;
          firstElement = dragMultipleItems.length ? dragMultipleItems[0] : item;
          if (isBacklog) {
            index = $(firstElement).index(".backlog-table-body .row");
          } else {
            index = $(firstElement).index();
            sprint = (ref = parent.scope()) != null ? ref.sprint.id : void 0;
          }
          if (!sameContainer) {
            if (dragMultipleItems.length) {
              usList = _.map(dragMultipleItems, function(item) {
                return item = $(item).scope().us;
              });
            } else if ($(item).scope()) {
              usList = [$(item).scope().us];
            }
            if (dragMultipleItems.length) {
              _.each(dragMultipleItems, function(item) {
                return deleteElement(item);
              });
            } else {
              deleteElement(item);
            }
          } else {
            if (dragMultipleItems.length) {
              usList = _.map(dragMultipleItems, function(item) {
                return item = $(item).scope().us;
              });
            } else if ($(item).scope()) {
              usList = [$(item).scope().us];
            }
          }
          return $scope.$emit("sprint:us:move", usList, index, sprint);
        });
        scroll = autoScroll([window], {
          margin: 20,
          pixels: 30,
          scrollWhenOutside: true,
          autoScroll: function() {
            return this.down && drake.dragging;
          }
        });
        return $scope.$on("$destroy", function() {
          $el.off();
          return drake.destroy();
        });
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgBacklogSortable", BacklogSortableDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/backlog/sprints.coffee
 */

(function() {
  var BacklogSprintDirective, BacklogSprintHeaderDirective, ToggleExcludeClosedSprintsVisualization, module, taiga;

  taiga = this.taiga;

  module = angular.module("taigaBacklog");

  BacklogSprintDirective = function($repo, $rootscope) {
    var link, slideOptions, sprintTableMinHeight, toggleSprint;
    sprintTableMinHeight = 50;
    slideOptions = {
      duration: 500,
      easing: 'linear'
    };
    toggleSprint = (function(_this) {
      return function($el) {
        var sprintArrow, sprintTable;
        sprintTable = $el.find(".sprint-table");
        sprintArrow = $el.find(".compact-sprint");
        sprintArrow.toggleClass('active');
        return sprintTable.toggleClass('open');
      };
    })(this);
    link = function($scope, $el, $attrs) {
      $scope.$watch($attrs.tgBacklogSprint, function(sprint) {
        sprint = $scope.$eval($attrs.tgBacklogSprint);
        if (sprint.closed) {
          return $el.addClass("sprint-closed");
        } else {
          return toggleSprint($el);
        }
      });
      $el.on("click", ".sprint-name > .compact-sprint", function(event) {
        event.preventDefault();
        toggleSprint($el);
        return $el.find(".sprint-table").slideToggle(slideOptions);
      });
      $el.on("click", ".edit-sprint", function(event) {
        var sprint;
        event.preventDefault();
        sprint = $scope.$eval($attrs.tgBacklogSprint);
        return $rootscope.$broadcast("sprintform:edit", sprint);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgBacklogSprint", ["$tgRepo", "$rootScope", BacklogSprintDirective]);

  BacklogSprintHeaderDirective = function($navUrls, $template, $compile, $translate) {
    var link, template;
    template = $template.get("backlog/sprint-header.html");
    link = function($scope, $el, $attrs, $model) {
      var isEditable, isVisible, prettyDate, render;
      prettyDate = $translate.instant("BACKLOG.SPRINTS.DATE");
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_milestone") !== -1;
      };
      isVisible = function() {
        return $scope.project.my_permissions.indexOf("view_milestones") !== -1;
      };
      render = function(sprint) {
        var compiledTemplate, ctx, estimatedDateRange, finish, start, taskboardUrl, templateScope;
        taskboardUrl = $navUrls.resolve("project-taskboard", {
          project: $scope.project.slug,
          sprint: sprint.slug
        });
        start = moment(sprint.estimated_start).format(prettyDate);
        finish = moment(sprint.estimated_finish).format(prettyDate);
        estimatedDateRange = start + "-" + finish;
        ctx = {
          name: sprint.name,
          taskboardUrl: taskboardUrl,
          estimatedDateRange: estimatedDateRange,
          closedPoints: sprint.closed_points || 0,
          totalPoints: sprint.total_points || 0,
          isVisible: isVisible(),
          isEditable: isEditable()
        };
        templateScope = $scope.$new();
        _.assign(templateScope, ctx);
        compiledTemplate = $compile(template)(templateScope);
        return $el.html(compiledTemplate);
      };
      $scope.$watch("sprint", function(sprint) {
        return render(sprint);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA"
    };
  };

  module.directive("tgBacklogSprintHeader", ["$tgNavUrls", "$tgTemplate", "$compile", "$translate", BacklogSprintHeaderDirective]);

  ToggleExcludeClosedSprintsVisualization = function($rootscope, $loading, $translate) {
    var excludeClosedSprints, link;
    excludeClosedSprints = true;
    link = function($scope, $el, $attrs) {
      var currentLoading, loadingElm;
      loadingElm = $("<div>");
      $el.after(loadingElm);
      currentLoading = null;
      $el.on("click", function(event) {
        event.preventDefault();
        excludeClosedSprints = !excludeClosedSprints;
        currentLoading = $loading().target(loadingElm).start();
        if (excludeClosedSprints) {
          return $rootscope.$broadcast("backlog:unload-closed-sprints");
        } else {
          return $rootscope.$broadcast("backlog:load-closed-sprints");
        }
      });
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return $scope.$on("closed-sprints:reloaded", function(ctx, sprints) {
        var key, text;
        if (currentLoading) {
          currentLoading.finish();
        }
        if (sprints.length > 0) {
          key = "BACKLOG.SPRINTS.ACTION_HIDE_CLOSED_SPRINTS";
        } else {
          key = "BACKLOG.SPRINTS.ACTION_SHOW_CLOSED_SPRINTS";
        }
        text = $translate.instant(key);
        return $el.find(".text").text(text);
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgBacklogToggleClosedSprintsVisualization", ["$rootScope", "$tgLoading", "$translate", ToggleExcludeClosedSprintsVisualization]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/taskboard/charts.coffee
 */

(function() {
  var SprintGraphDirective, bindOnce, groupBy, mixOf, module, scopeDefer, taiga, timeout, toggleText;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  toggleText = this.taiga.toggleText;

  scopeDefer = this.taiga.scopeDefer;

  bindOnce = this.taiga.bindOnce;

  groupBy = this.taiga.groupBy;

  timeout = this.taiga.timeout;

  module = angular.module("taigaTaskboard");

  SprintGraphDirective = function($translate) {
    var link, redrawChart;
    redrawChart = function(element, dataToDraw) {
      var data, days, options, width;
      width = element.width();
      element.height(240);
      days = _.map(dataToDraw, function(x) {
        return moment.utc(x.day);
      });
      data = [];
      data.unshift({
        data: _.zip(days, _.map(dataToDraw, function(d) {
          return d.optimal_points;
        })),
        lines: {
          fillColor: "rgba(120,120,120,0.2)"
        }
      });
      data.unshift({
        data: _.zip(days, _.map(dataToDraw, function(d) {
          return d.open_points;
        })),
        lines: {
          fillColor: "rgba(102,153,51,0.3)"
        }
      });
      options = {
        grid: {
          borderWidth: {
            top: 0,
            right: 1,
            left: 0,
            bottom: 0
          },
          borderColor: '#ccc',
          hoverable: true
        },
        xaxis: {
          tickSize: [1, "day"],
          min: days[0],
          max: _.last(days),
          mode: "time",
          daysNames: days,
          axisLabel: $translate.instant("TASKBOARD.CHARTS.XAXIS_LABEL"),
          axisLabelUseCanvas: true,
          axisLabelFontSizePixels: 12,
          axisLabelFontFamily: 'Verdana, Arial, Helvetica, Tahoma, sans-serif',
          axisLabelPadding: 5
        },
        yaxis: {
          min: 0,
          axisLabel: $translate.instant("TASKBOARD.CHARTS.YAXIS_LABEL"),
          axisLabelUseCanvas: true,
          axisLabelFontSizePixels: 12,
          axisLabelFontFamily: 'Verdana, Arial, Helvetica, Tahoma, sans-serif',
          axisLabelPadding: 5
        },
        series: {
          shadowSize: 0,
          lines: {
            show: true,
            fill: true
          },
          points: {
            show: true,
            fill: true,
            radius: 4,
            lineWidth: 2
          }
        },
        colors: ["rgba(102,153,51,1)", "rgba(120,120,120,0.2)"],
        tooltip: true,
        tooltipOpts: {
          content: function(label, xval, yval, flotItem) {
            var formattedDate, roundedValue;
            formattedDate = moment(xval).format($translate.instant("TASKBOARD.CHARTS.DATE"));
            roundedValue = Math.round(yval);
            if (flotItem.seriesIndex === 1) {
              return $translate.instant("TASKBOARD.CHARTS.OPTIMAL", {
                formattedDate: formattedDate,
                roundedValue: roundedValue
              });
            } else {
              return $translate.instant("TASKBOARD.CHARTS.REAL", {
                formattedDate: formattedDate,
                roundedValue: roundedValue
              });
            }
          }
        }
      };
      element.empty();
      return element.plot(data, options).data("plot");
    };
    link = function($scope, $el, $attrs) {
      var element;
      element = angular.element($el);
      $scope.$on("resize", function() {
        if ($scope.stats) {
          return redrawChart(element, $scope.stats.days);
        }
      });
      $scope.$on("taskboard:graph:toggle-visibility", function() {
        $el.parent().toggleClass('open');
        return timeout(100, function() {
          if ($scope.stats) {
            return redrawChart(element, $scope.stats.days);
          }
        });
      });
      $scope.$watch('stats', function(value) {
        if ($scope.stats == null) {
          return;
        }
        return redrawChart(element, $scope.stats.days);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgSprintGraph", ["$translate", SprintGraphDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/taskboard/lightboxes.coffee
 */

(function() {
  var CreateBulkTasksDirective, bindOnce, debounce, module, taiga, trim;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  trim = this.taiga.trim;

  module = angular.module("taigaTaskboard");

  CreateBulkTasksDirective = function($repo, $rs, $rootscope, $loading, lightboxService, $model) {
    var link;
    link = function($scope, $el, attrs) {
      var submit, submitButton;
      $scope.form = {
        data: "",
        usId: null
      };
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, data, form, projectId, promise, sprintId, usId;
          event.preventDefault();
          form = $el.find("form").checksley();
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          data = $scope.form.data;
          projectId = $scope.projectId;
          sprintId = $scope.form.sprintId;
          usId = $scope.form.usId;
          promise = $rs.tasks.bulkCreate(projectId, sprintId, usId, data);
          promise.then(function(result) {
            result = _.map(result, (function(_this) {
              return function(x) {
                return $model.make_model('tasks', x);
              };
            })(this));
            currentLoading.finish();
            $rootscope.$broadcast("taskform:bulk:success", result);
            return lightboxService.close($el);
          });
          return promise.then(null, function() {
            return currentLoading.finish();
          });
        };
      })(this));
      $scope.$on("taskform:bulk", function(ctx, sprintId, usId) {
        lightboxService.open($el);
        return $scope.form = {
          data: "",
          sprintId: sprintId,
          usId: usId
        };
      });
      submitButton = $el.find(".submit-button");
      $el.on("submit", "form", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgLbCreateBulkTasks", ["$tgRepo", "$tgResources", "$rootScope", "$tgLoading", "lightboxService", "$tgModel", CreateBulkTasksDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/taskboard/main.coffee
 */

(function() {
  var TaskboardController, TaskboardDirective, TaskboardSquishColumnDirective, bindMethods, bindOnce, debounceLeading, groupBy, mixOf, module, scopeDefer, taiga, timeout, toggleText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  toggleText = this.taiga.toggleText;

  mixOf = this.taiga.mixOf;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  scopeDefer = this.taiga.scopeDefer;

  timeout = this.taiga.timeout;

  bindMethods = this.taiga.bindMethods;

  debounceLeading = this.taiga.debounceLeading;

  module = angular.module("taigaTaskboard");

  TaskboardController = (function(superClass) {
    extend(TaskboardController, superClass);

    TaskboardController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "tgResources", "$routeParams", "$q", "tgAppMetaService", "$tgLocation", "$tgNavUrls", "$tgEvents", "$tgAnalytics", "$translate", "tgErrorHandlingService", "tgTaskboardTasks", "tgTaskboardIssues", "$tgStorage", "tgFilterRemoteStorageService", "tgLightboxFactory"];

    TaskboardController.prototype.excludePrefix = "exclude_";

    TaskboardController.prototype.filterCategories = ["tags", "status", "assigned_to", "owner", "role"];

    function TaskboardController(scope, rootscope, repo, confirm, rs1, rs2, params1, q1, appMetaService, location, navUrls, events, analytics, translate, errorHandlingService, taskboardTasksService, taskboardIssuesService, storage, filterRemoteStorageService, lightboxFactory) {
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs1;
      this.rs2 = rs2;
      this.params = params1;
      this.q = q1;
      this.appMetaService = appMetaService;
      this.location = location;
      this.navUrls = navUrls;
      this.events = events;
      this.analytics = analytics;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.taskboardTasksService = taskboardTasksService;
      this.taskboardIssuesService = taskboardIssuesService;
      this.storage = storage;
      this.filterRemoteStorageService = filterRemoteStorageService;
      this.lightboxFactory = lightboxFactory;
      bindMethods(this);
      this.taskboardTasksService.reset();
      this.scope.userstories = [];
      this.openFilter = false;
      if (this.applyStoredFilters(this.params.pslug, "tasks-filters")) {
        return;
      }
      this.scope.sectionName = this.translate.instant("TASKBOARD.SECTION_NAME");
      this.initializeEventHandlers();
      taiga.defineImmutableProperty(this.scope, "usTasks", (function(_this) {
        return function() {
          return _this.taskboardTasksService.usTasks;
        };
      })(this));
      taiga.defineImmutableProperty(this.scope, "milestoneIssues", (function(_this) {
        return function() {
          return _this.taskboardIssuesService.milestoneIssues;
        };
      })(this));
    }

    TaskboardController.prototype.firstLoad = function() {
      var promise;
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          return _this._setMeta();
        };
      })(this));
      return promise.then(null, this.onInitialDataError.bind(this));
    };

    TaskboardController.prototype.setZoom = function(zoomLevel, zoom) {
      var previousZoomLevel;
      if (this.zoomLevel === zoomLevel) {
        return null;
      }
      this.isFirstLoad = !this.zoomLevel;
      previousZoomLevel = this.zoomLevel;
      this.zoomLevel = zoomLevel;
      this.zoom = zoom;
      if (this.isFirstLoad) {
        this.firstLoad().then((function(_this) {
          return function() {
            _this.isFirstLoad = false;
            return _this.taskboardTasksService.resetFolds();
          };
        })(this));
      } else if (this.zoomLevel > 1 && previousZoomLevel <= 1) {
        this.zoomLoading = true;
        this.q.all([this.loadTasks(), this.loadIssues()]).then((function(_this) {
          return function() {
            _this.zoomLoading = false;
            return _this.taskboardTasksService.resetFolds();
          };
        })(this));
      }
      if (this.zoomLevel === '0') {
        return this.rootscope.$broadcast("sprint:zoom0");
      }
    };

    TaskboardController.prototype.changeQ = function(q) {
      this.replaceFilter("q", q);
      this.loadTasks();
      return this.generateFilters();
    };

    TaskboardController.prototype.removeFilter = function(filter) {
      this.unselectFilter(filter.dataType, filter.id, false, filter.mode);
      this.loadTasks();
      return this.generateFilters();
    };

    TaskboardController.prototype.addFilter = function(newFilter) {
      this.selectFilter(newFilter.category.dataType, newFilter.filter.id, false, newFilter.mode);
      this.loadTasks();
      return this.generateFilters();
    };

    TaskboardController.prototype.selectCustomFilter = function(customFilter) {
      this.replaceAllFilters(customFilter.filter);
      this.loadTasks();
      return this.generateFilters();
    };

    TaskboardController.prototype.removeCustomFilter = function(customFilter) {
      return this.filterRemoteStorageService.getFilters(this.scope.projectId, 'tasks-custom-filters').then((function(_this) {
        return function(userFilters) {
          delete userFilters[customFilter.id];
          return _this.filterRemoteStorageService.storeFilters(_this.scope.projectId, userFilters, 'tasks-custom-filters').then(_this.generateFilters);
        };
      })(this));
    };

    TaskboardController.prototype.isFilterDataTypeSelected = function(filterDataType) {
      var filter, i, len, ref;
      ref = this.selectedFilters;
      for (i = 0, len = ref.length; i < len; i++) {
        filter = ref[i];
        if (filter['dataType'] === filterDataType) {
          return true;
        }
      }
      return false;
    };

    TaskboardController.prototype.saveCustomFilter = function(name) {
      var excludeKey, filters, i, key, len, ref, urlfilters;
      filters = {};
      urlfilters = this.location.search();
      ref = this.filterCategories;
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        excludeKey = this.excludePrefix.concat(key);
        filters[key] = urlfilters[key];
        filters[excludeKey] = urlfilters[excludeKey];
      }
      return this.filterRemoteStorageService.getFilters(this.scope.projectId, 'tasks-custom-filters').then((function(_this) {
        return function(userFilters) {
          userFilters[name] = filters;
          return _this.filterRemoteStorageService.storeFilters(_this.scope.projectId, userFilters, 'tasks-custom-filters').then(_this.generateFilters);
        };
      })(this));
    };

    TaskboardController.prototype.generateFilters = function() {
      var excludeKey, i, key, len, loadFilters, ref, urlfilters;
      this.storeFilters(this.params.pslug, this.location.search(), "tasks-filters");
      urlfilters = this.location.search();
      loadFilters = {};
      loadFilters.project = this.scope.projectId;
      loadFilters.milestone = this.scope.sprintId;
      loadFilters.q = urlfilters.q;
      ref = this.filterCategories;
      for (i = 0, len = ref.length; i < len; i++) {
        key = ref[i];
        excludeKey = this.excludePrefix.concat(key);
        loadFilters[key] = urlfilters[key];
        loadFilters[excludeKey] = urlfilters[excludeKey];
      }
      return this.q.all([this.rs.tasks.filtersData(loadFilters), this.filterRemoteStorageService.getFilters(this.scope.projectId, 'tasks-custom-filters')]).then((function(_this) {
        return function(result) {
          var customFiltersRaw, data, dataCollection, j, len1, ref1, selected, tagsWithAtLeastOneElement;
          data = result[0];
          customFiltersRaw = result[1];
          dataCollection = {};
          dataCollection.status = _.map(data.statuses, function(it) {
            it.id = it.id.toString();
            return it;
          });
          dataCollection.tags = _.map(data.tags, function(it) {
            it.id = it.name;
            return it;
          });
          tagsWithAtLeastOneElement = _.filter(dataCollection.tags, function(tag) {
            return tag.count > 0;
          });
          dataCollection.assigned_to = _.map(data.assigned_to, function(it) {
            if (it.id) {
              it.id = it.id.toString();
            } else {
              it.id = "null";
            }
            it.name = it.full_name || "Unassigned";
            return it;
          });
          dataCollection.role = _.map(data.roles, function(it) {
            if (it.id) {
              it.id = it.id.toString();
            } else {
              it.id = "null";
            }
            it.name = it.name || "Unassigned";
            return it;
          });
          dataCollection.owner = _.map(data.owners, function(it) {
            it.id = it.id.toString();
            it.name = it.full_name;
            return it;
          });
          _this.selectedFilters = [];
          ref1 = _this.filterCategories;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            key = ref1[j];
            excludeKey = _this.excludePrefix.concat(key);
            if (loadFilters[key]) {
              selected = _this.formatSelectedFilters(key, dataCollection[key], loadFilters[key]);
              _this.selectedFilters = _this.selectedFilters.concat(selected);
            }
            if (loadFilters[excludeKey]) {
              selected = _this.formatSelectedFilters(key, dataCollection[key], loadFilters[excludeKey], "exclude");
              _this.selectedFilters = _this.selectedFilters.concat(selected);
            }
          }
          _this.filterQ = loadFilters.q;
          _this.filters = [
            {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.STATUS"),
              dataType: "status",
              content: dataCollection.status
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.TAGS"),
              dataType: "tags",
              content: dataCollection.tags,
              hideEmpty: true,
              totalTaggedElements: tagsWithAtLeastOneElement.length
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.ASSIGNED_TO"),
              dataType: "assigned_to",
              content: dataCollection.assigned_to
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.ROLE"),
              dataType: "role",
              content: dataCollection.role
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.CREATED_BY"),
              dataType: "owner",
              content: dataCollection.owner
            }
          ];
          _this.customFilters = [];
          return _.forOwn(customFiltersRaw, function(value, key) {
            return _this.customFilters.push({
              id: key,
              name: key,
              filter: value
            });
          });
        };
      })(this));
    };

    TaskboardController.prototype._setMeta = function() {
      var description, prettyDate, title;
      prettyDate = this.translate.instant("BACKLOG.SPRINTS.DATE");
      title = this.translate.instant("TASKBOARD.PAGE_TITLE", {
        projectName: this.scope.project.name,
        sprintName: this.scope.sprint.name
      });
      description = this.translate.instant("TASKBOARD.PAGE_DESCRIPTION", {
        projectName: this.scope.project.name,
        sprintName: this.scope.sprint.name,
        startDate: moment(this.scope.sprint.estimated_start).format(prettyDate),
        endDate: moment(this.scope.sprint.estimated_finish).format(prettyDate),
        completedPercentage: this.scope.stats.completedPercentage || "0",
        completedPoints: this.scope.stats.completedPointsSum || "--",
        totalPoints: this.scope.stats.totalPointsSum || "--",
        openTasks: this.scope.stats.openTasks || "--",
        totalTasks: this.scope.stats.total_tasks || "--"
      });
      return this.appMetaService.setAll(title, description);
    };

    TaskboardController.prototype.initializeEventHandlers = function() {
      this.scope.$on("taskform:bulk:success", (function(_this) {
        return function(event, tasks) {
          _this.refreshTagsColors().then(function() {
            return _this.taskboardTasksService.add(tasks);
          });
          return _this.analytics.trackEvent("task", "create", "bulk create task on taskboard", 1);
        };
      })(this));
      this.scope.$on("taskform:new:success", (function(_this) {
        return function(event, task) {
          _this.refreshTagsColors().then(function() {
            return _this.taskboardTasksService.add(task);
          });
          return _this.analytics.trackEvent("task", "create", "create task on taskboard", 1);
        };
      })(this));
      this.scope.$on("taskform:edit:success", (function(_this) {
        return function(event, task) {
          return _this.refreshTagsColors().then(function() {
            return _this.taskboardTasksService.replaceModel(task);
          });
        };
      })(this));
      this.scope.$on("issueform:new:success", (function(_this) {
        return function(event, issue) {
          _this.refreshTagsColors().then(function() {
            return _this.taskboardIssuesService.add(issue);
          });
          return _this.analytics.trackEvent("issue", "create", "create issue on taskboard", 1);
        };
      })(this));
      this.scope.$on("issueform:add:success", (function(_this) {
        return function(event, issue) {
          return _this.refreshTagsColors().then(function() {
            return _this.taskboardIssuesService.add(issue);
          });
        };
      })(this));
      this.scope.$on("issueform:edit:success", (function(_this) {
        return function(event, issue) {
          return _this.refreshTagsColors().then(function() {
            return _this.taskboardIssuesService.replaceModel(issue);
          });
        };
      })(this));
      this.scope.$on("taskboard:task:deleted", (function(_this) {
        return function(event, task) {
          return _this.loadTasks();
        };
      })(this));
      this.scope.$on("taskboard:issue:deleted", (function(_this) {
        return function(event, issue) {
          return _this.loadIssues();
        };
      })(this));
      this.scope.$on("taskboard:task:move", this.taskMove);
      this.scope.$on("assigned-to:added", this.onAssignedToChanged);
      return this.scope.$on("taskboard:items:move", (function(_this) {
        return function(event, itemsMoved) {
          if (itemsMoved.uss) {
            return _this.firstLoad();
          } else {
            if (itemsMoved.tasks) {
              _this.loadTasks();
            }
            if (itemsMoved.issues) {
              return _this.loadIssues();
            }
          }
        };
      })(this));
    };

    TaskboardController.prototype.onAssignedToChanged = function(ctx, userid, model) {
      if (model.getName() === 'tasks') {
        model.assigned_to = userid;
        this.taskboardTasksService.replaceModel(model);
        this.repo.save(model).then((function(_this) {
          return function() {
            _this.generateFilters();
            if (_this.isFilterDataTypeSelected('assigned_to') || _this.isFilterDataTypeSelected('role')) {
              return _this.loadTasks();
            }
          };
        })(this));
      }
      if (model.getName() === 'issues') {
        model.assigned_to = userid;
        this.taskboardIssuesService.replaceModel(model);
        return this.repo.save(model).then((function(_this) {
          return function() {
            _this.generateFilters();
            if (_this.isFilterDataTypeSelected('assigned_to') || _this.isFilterDataTypeSelected('role')) {
              return _this.loadIssues();
            }
          };
        })(this));
      }
    };

    TaskboardController.prototype.initializeSubscription = function() {
      var routingKey, routingKey1;
      routingKey = "changes.project." + this.scope.projectId + ".tasks";
      this.events.subscribe(this.scope, routingKey, debounceLeading(500, (function(_this) {
        return function(message) {
          return _this.loadTaskboard();
        };
      })(this)));
      routingKey = "changes.project." + this.scope.projectId + ".issues";
      this.events.subscribe(this.scope, routingKey, debounceLeading(500, (function(_this) {
        return function(message) {
          return _this.loadIssues();
        };
      })(this)));
      routingKey1 = "changes.project." + this.scope.projectId + ".userstories";
      return this.events.subscribe(this.scope, routingKey1, (function(_this) {
        return function(message) {
          _this.refreshTagsColors();
          _this.loadSprintStats();
          return _this.loadSprint();
        };
      })(this));
    };

    TaskboardController.prototype.loadProject = function() {
      return this.rs.projects.get(this.scope.projectId).then((function(_this) {
        return function(project) {
          if (!project.is_backlog_activated) {
            _this.errorHandlingService.permissionDenied();
          }
          _this.scope.project = project;
          _this.scope.pointsList = _.sortBy(project.points, "order");
          _this.scope.pointsById = groupBy(project.points, function(e) {
            return e.id;
          });
          _this.scope.roleById = groupBy(project.roles, function(e) {
            return e.id;
          });
          _this.scope.taskStatusList = _.sortBy(project.task_statuses, "order");
          _this.scope.usStatusList = _.sortBy(project.us_statuses, "order");
          _this.scope.usStatusById = groupBy(project.us_statuses, function(e) {
            return e.id;
          });
          _this.scope.issueStatusById = groupBy(project.issue_statuses, function(e) {
            return e.id;
          });
          _this.scope.$emit('project:loaded', project);
          _this.fillUsersAndRoles(project.members, project.roles);
          return project;
        };
      })(this));
    };

    TaskboardController.prototype.loadSprintStats = function() {
      return this.rs.sprints.stats(this.scope.projectId, this.scope.sprintId).then((function(_this) {
        return function(stats) {
          var completedPointsSum, remainingPointsSum, remainingTasks, totalPointsSum;
          totalPointsSum = _.reduce(_.values(stats.total_points), (function(res, n) {
            return res + n;
          }), 0);
          completedPointsSum = _.reduce(_.values(stats.completed_points), (function(res, n) {
            return res + n;
          }), 0);
          remainingPointsSum = totalPointsSum - completedPointsSum;
          remainingTasks = stats.total_tasks - stats.completed_tasks;
          _this.scope.stats = stats;
          _this.scope.stats.totalPointsSum = totalPointsSum;
          _this.scope.stats.completedPointsSum = completedPointsSum;
          _this.scope.stats.remainingPointsSum = remainingPointsSum;
          _this.scope.stats.remainingTasks = remainingTasks;
          if (stats.totalPointsSum) {
            _this.scope.stats.completedPercentage = Math.round(100 * stats.completedPointsSum / stats.totalPointsSum);
          } else {
            _this.scope.stats.completedPercentage = 0;
          }
          _this.scope.stats.openTasks = stats.total_tasks - stats.completed_tasks;
          return stats;
        };
      })(this));
    };

    TaskboardController.prototype.refreshTagsColors = function() {
      return this.rs.projects.tagsColors(this.scope.projectId).then((function(_this) {
        return function(tags_colors) {
          return _this.scope.project.tags_colors = tags_colors._attrs;
        };
      })(this));
    };

    TaskboardController.prototype.loadSprint = function() {
      return this.rs.sprints.get(this.scope.projectId, this.scope.sprintId).then((function(_this) {
        return function(sprint) {
          _this.scope.sprint = sprint;
          _this.scope.userstories = _.sortBy(sprint.user_stories, "sprint_order");
          _this.taskboardTasksService.setUserstories(_this.scope.userstories);
          _this.rootscope.$broadcast("taskboard:userstories:loaded", _this.scope.userstories);
          return sprint;
        };
      })(this));
    };

    TaskboardController.prototype.loadIssues = function() {
      var params;
      params = {};
      if (this.zoomLevel > 1) {
        params.include_attachments = 1;
      }
      params = _.merge(params, this.location.search());
      return this.rs.issues.listInProject(this.scope.projectId, this.scope.sprintId, params).then((function(_this) {
        return function(issues) {
          _this.taskboardIssuesService.init(_this.scope.project, _this.scope.usersById, _this.scope.issueStatusById);
          _this.taskboardIssuesService.set(issues);
          return _this.scope.taskBoardLoading = false;
        };
      })(this));
    };

    TaskboardController.prototype.loadTasks = function() {
      var params;
      params = {};
      if (this.zoomLevel > 1) {
        params.include_attachments = 1;
      }
      params = _.merge(params, this.location.search());
      return this.rs.tasks.list(this.scope.projectId, this.scope.sprintId, null, params).then((function(_this) {
        return function(tasks) {
          _this.taskboardTasksService.init(_this.scope.project, _this.scope.usersById);
          return _this.taskboardTasksService.set(tasks);
        };
      })(this));
    };

    TaskboardController.prototype.loadTaskboard = function() {
      return this.q.all([
        this.refreshTagsColors(), this.loadSprintStats(), this.loadSprint().then((function(_this) {
          return function() {
            _this.loadTasks();
            return _this.loadIssues();
          };
        })(this))
      ]);
    };

    TaskboardController.prototype.loadInitialData = function() {
      var params, promise;
      params = {
        pslug: this.params.pslug,
        sslug: this.params.sslug
      };
      promise = this.repo.resolve(params).then((function(_this) {
        return function(data) {
          _this.scope.projectId = data.project;
          _this.scope.sprintId = data.milestone;
          _this.initializeSubscription();
          return data;
        };
      })(this));
      return promise.then((function(_this) {
        return function() {
          return _this.loadProject();
        };
      })(this)).then((function(_this) {
        return function() {
          _this.generateFilters();
          return _this.loadTaskboard().then(function() {
            return _this.setRolePoints();
          });
        };
      })(this));
    };

    TaskboardController.prototype.showPlaceHolder = function(statusId, usId) {
      if (!this.taskboardTasksService.tasksRaw.length) {
        if (this.scope.taskStatusList[0].id === statusId && (!this.scope.userstories.length || this.scope.userstories[0].id === usId)) {
          return true;
        }
      }
      return false;
    };

    TaskboardController.prototype.editTask = function(id) {
      var task;
      task = this.taskboardTasksService.getTask(id);
      task = task.set('loading-edit', true);
      this.taskboardTasksService.replace(task);
      return this.rs.tasks.getByRef(task.getIn(['model', 'project']), task.getIn(['model', 'ref'])).then((function(_this) {
        return function(editingTask) {
          return _this.rs2.attachments.list("task", task.get('id'), task.getIn(['model', 'project'])).then(function(attachments) {
            _this.rootscope.$broadcast("genericform:edit", {
              'objType': 'task',
              'obj': editingTask,
              'project': _this.scope.project,
              'sprintId': _this.scope.sprintId,
              'attachments': attachments.toJS()
            });
            task = task.set('loading-edit', false);
            return _this.taskboardTasksService.replace(task);
          });
        };
      })(this));
    };

    TaskboardController.prototype.editIssue = function(id) {
      var issue;
      issue = this.taskboardIssuesService.getIssue(id);
      issue = issue.set('loading-edit', true);
      return this.rs.issues.getByRef(issue.getIn(['model', 'project']), issue.getIn(['model', 'ref'])).then((function(_this) {
        return function(editingIssue) {
          return _this.rs2.attachments.list("issue", issue.get('id'), issue.getIn(['model', 'project'])).then(function(attachments) {
            _this.rootscope.$broadcast("genericform:edit", {
              'objType': 'issue',
              'obj': editingIssue,
              'project': _this.scope.project,
              'sprintId': _this.scope.sprintId,
              'attachments': attachments.toJS()
            });
            return issue = issue.set('loading-edit', false);
          });
        };
      })(this));
    };

    TaskboardController.prototype.deleteTask = function(id) {
      var task;
      task = this.taskboardTasksService.getTask(id);
      task = task.set('loading-delete', true);
      return this.rs.tasks.getByRef(task.getIn(['model', 'project']), task.getIn(['model', 'ref'])).then((function(_this) {
        return function(deletingTask) {
          var message, title;
          task = task.set('loading-delete', false);
          title = _this.translate.instant("TASK.TITLE_DELETE_ACTION");
          message = deletingTask.subject;
          return _this.confirm.askOnDelete(title, message).then(function(askResponse) {
            var promise;
            promise = _this.repo.remove(deletingTask);
            promise.then(function() {
              _this.scope.$broadcast("taskboard:task:deleted");
              return askResponse.finish();
            });
            return promise.then(null, function() {
              askResponse.finish(false);
              return this.confirm.notify("error");
            });
          });
        };
      })(this));
    };

    TaskboardController.prototype.deleteIssue = function(id) {
      var issue;
      issue = this.taskboardIssuesService.getIssue(id);
      issue = issue.set('loading-delete', true);
      return this.rs.issues.getByRef(issue.getIn(['model', 'project']), issue.getIn(['model', 'ref'])).then((function(_this) {
        return function(deletingIssue) {
          var message, title;
          issue = issue.set('loading-delete', false);
          title = _this.translate.instant("ISSUES.ACTION_DELETE");
          message = deletingIssue.subject;
          return _this.confirm.askOnDelete(title, message).then(function(askResponse) {
            var promise;
            promise = _this.repo.remove(deletingIssue);
            promise.then(function() {
              _this.scope.$broadcast("taskboard:issue:deleted");
              return askResponse.finish();
            });
            return promise.then(null, function() {
              askResponse.finish(false);
              return this.confirm.notify("error");
            });
          });
        };
      })(this));
    };

    TaskboardController.prototype.removeIssueFromSprint = function(id) {
      var issue;
      issue = this.taskboardIssuesService.getIssue(id);
      issue = issue.set('loading-delete', true);
      return this.rs.issues.getByRef(issue.getIn(['model', 'project']), issue.getIn(['model', 'ref'])).then((function(_this) {
        return function(removingIssue) {
          var message, title;
          issue = issue.set('loading-delete', false);
          title = _this.translate.instant("ISSUES.CONFIRM_DETACH_FROM_SPRINT.TITLE");
          message = _this.translate.instant("ISSUES.CONFIRM_DETACH_FROM_SPRINT.MESSAGE");
          message = _this.translate.instant("ISSUES.CONFIRM_DETACH_FROM_SPRINT.MESSAGE", {
            sprintName: _this.scope.sprint.name
          });
          return _this.confirm.ask(title, null, message).then(function(askResponse) {
            var promise;
            removingIssue.milestone = null;
            promise = _this.repo.save(removingIssue);
            promise.then(function() {
              _this.taskboardIssuesService.remove(removingIssue);
              return askResponse.finish();
            });
            return promise.then(null, function() {
              askResponse.finish(false);
              return this.confirm.notify("error");
            });
          });
        };
      })(this));
    };

    TaskboardController.prototype.taskMove = function(ctx, task, oldStatusId, usId, statusId, order) {
      var moveUpdateData, options, params, promise;
      this.scope.movingTask = true;
      task = this.taskboardTasksService.getTaskModel(task.get('id'));
      moveUpdateData = this.taskboardTasksService.move(task.id, usId, statusId, order);
      params = {
        status__is_archived: false,
        include_attachments: true
      };
      options = {
        headers: {
          "set-orders": JSON.stringify(moveUpdateData.set_orders)
        }
      };
      return promise = this.repo.save(task, true, params, options, true).then((function(_this) {
        return function(result) {
          var headers;
          if (result[0] && result[0].user_story) {
            _this.reloadUserStory(result[0].user_story);
          }
          _this.scope.movingTask = false;
          headers = result[1];
          if (headers && headers['taiga-info-order-updated']) {
            order = JSON.parse(headers['taiga-info-order-updated']);
            _this.taskboardTasksService.assignOrders(order);
          }
          _this.loadSprintStats();
          _this.generateFilters();
          if (_this.isFilterDataTypeSelected('status')) {
            return _this.loadTasks();
          }
        };
      })(this));
    };

    TaskboardController.prototype.reloadUserStory = function(userStoryId) {
      return this.rs.userstories.get(this.scope.project.id, userStoryId).then((function(_this) {
        return function(us) {
          return _this.scope.userstories = _.map(_this.scope.userstories, function(x) {
            if (x.id === us.id) {
              return us;
            } else {
              return x;
            }
          });
        };
      })(this));
    };

    TaskboardController.prototype.addNewTask = function(type, us) {
      switch (type) {
        case "standard":
          return this.rootscope.$broadcast("genericform:new", {
            'objType': 'task',
            'project': this.scope.project,
            'sprintId': this.scope.sprintId,
            'usId': us != null ? us.id : void 0
          });
        case "bulk":
          return this.rootscope.$broadcast("taskform:bulk", this.scope.sprintId, us != null ? us.id : void 0);
      }
    };

    TaskboardController.prototype.addNewIssue = function(type, us) {
      switch (type) {
        case "standard":
          return this.rootscope.$broadcast("genericform:new-or-existing", {
            objType: 'issue',
            project: this.scope.project,
            sprintId: this.scope.sprintId,
            relatedField: 'milestone',
            relatedObjectId: this.scope.sprintId,
            targetName: this.scope.sprint.name
          });
        case "standard":
          return this.rootscope.$broadcast("taskform:new", this.scope.sprintId, us != null ? us.id : void 0);
        case "bulk":
          return this.rootscope.$broadcast("issueform:bulk", this.scope.projectId, this.scope.sprintId);
      }
    };

    TaskboardController.prototype.toggleFold = function(id, modelName) {
      if (modelName === 'issues') {
        return this.taskboardIssuesService.toggleFold(id);
      } else if (modelName === 'tasks') {
        return this.taskboardTasksService.toggleFold(id);
      }
    };

    TaskboardController.prototype.openUsersSelection = function(item) {
      var onClose;
      onClose = (function(_this) {
        return function(assignedUsers) {
          var userId;
          userId = assignedUsers.pop() || null;
          if (item.getName() === 'tasks') {
            item.assigned_to = userId;
            _this.taskboardTasksService.replaceModel(item);
            _this.repo.save(item).then(function() {
              _this.generateFilters();
              if (_this.isFilterDataTypeSelected('assigned_to') || _this.isFilterDataTypeSelected('role')) {
                return _this.loadTasks();
              }
            });
          }
          if (item.getName() === 'issues') {
            item.assigned_to = userId;
            _this.taskboardIssuesService.replaceModel(item);
            return _this.repo.save(item).then(function() {
              _this.generateFilters();
              if (_this.isFilterDataTypeSelected('assigned_to') || _this.isFilterDataTypeSelected('role')) {
                return _this.loadIssues();
              }
            });
          }
        };
      })(this);
      return this.lightboxFactory.create('tg-lb-select-user', {
        "class": "lightbox lightbox-select-user"
      }, {
        "currentUsers": [item.assigned_to],
        "activeUsers": this.scope.activeUsers,
        "onClose": onClose,
        "single": true,
        "lbTitle": this.translate.instant("COMMON.ASSIGNED_USERS.ADD")
      });
    };

    TaskboardController.prototype.changeTaskAssignedTo = function(id) {
      var task;
      task = this.taskboardTasksService.getTaskModel(id);
      return this.openUsersSelection(task);
    };

    TaskboardController.prototype.changeIssueAssignedTo = function(id) {
      var issue;
      issue = this.taskboardIssuesService.getIssueModel(id);
      return this.openUsersSelection(issue);
    };

    TaskboardController.prototype.setRolePoints = function() {
      var computableRoles, getPoint, getRole, pointsByRole;
      computableRoles = _.filter(this.scope.project.roles, "computable");
      getRole = (function(_this) {
        return function(roleId) {
          roleId = parseInt(roleId, 10);
          return _.find(computableRoles, function(role) {
            return role.id === roleId;
          });
        };
      })(this);
      getPoint = (function(_this) {
        return function(pointId) {
          var poitnId;
          poitnId = parseInt(pointId, 10);
          return _.find(_this.scope.project.points, function(point) {
            return point.id === pointId;
          });
        };
      })(this);
      pointsByRole = _.reduce(this.scope.userstories, (function(_this) {
        return function(result, us, key) {
          _.forOwn(us.points, function(pointId, roleId) {
            var point, role;
            role = getRole(roleId);
            point = getPoint(pointId);
            if (!result[role.id]) {
              result[role.id] = role;
              result[role.id].points = 0;
            }
            return result[role.id].points += point.value;
          });
          return result;
        };
      })(this), {});
      return this.scope.pointsByRole = Object.keys(pointsByRole).map(function(key) {
        return pointsByRole[key];
      });
    };

    return TaskboardController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  module.controller("TaskboardController", TaskboardController);

  TaskboardDirective = function($rootscope) {
    var link;
    link = function($scope, $el, $attrs) {
      var $ctrl, tableBodyDom;
      $ctrl = $el.controller();
      $el.on("click", ".toggle-analytics-visibility", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        target.toggleClass('active');
        return $rootscope.$broadcast("taskboard:graph:toggle-visibility");
      });
      tableBodyDom = $el.find(".taskboard-table-body");
      tableBodyDom.on("scroll", function(event) {
        var tableHeaderDom, target;
        target = angular.element(event.currentTarget);
        tableHeaderDom = $el.find(".taskboard-table-header .taskboard-table-inner");
        return tableHeaderDom.css("left", -1 * target.scrollLeft());
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgTaskboard", ["$rootScope", TaskboardDirective]);

  TaskboardSquishColumnDirective = function(rs) {
    var avatarWidth, link, maxColumnWidth;
    avatarWidth = 40;
    maxColumnWidth = 300;
    link = function($scope, $el, $attrs) {
      var getCeilWidth, recalculateStatusColumnWidth, recalculateTaskboardWidth, refreshTaskboardTableWidth, setStatusColumnWidth;
      $scope.$on("sprint:zoom0", (function(_this) {
        return function() {
          return recalculateTaskboardWidth();
        };
      })(this));
      $scope.$on("sprint:task:moved", (function(_this) {
        return function() {
          return recalculateTaskboardWidth();
        };
      })(this));
      $scope.$watch("usTasks", function() {
        if ($scope.project) {
          $scope.statusesFolded = rs.tasks.getStatusColumnModes($scope.project.id);
          $scope.usFolded = rs.tasks.getUsRowModes($scope.project.id, $scope.sprintId);
          return recalculateTaskboardWidth();
        }
      });
      $scope.foldStatus = function(status) {
        $scope.statusesFolded[status.id] = !!!$scope.statusesFolded[status.id];
        rs.tasks.storeStatusColumnModes($scope.projectId, $scope.statusesFolded);
        return recalculateTaskboardWidth();
      };
      $scope.foldUs = function(rowId) {
        $scope.usFolded[rowId] = !!!$scope.usFolded[rowId];
        rs.tasks.storeUsRowModes($scope.projectId, $scope.sprintId, $scope.usFolded);
        return recalculateTaskboardWidth();
      };
      getCeilWidth = (function(_this) {
        return function(usId, statusId) {
          var tasks, tasksMatrixSize, width;
          if (usId) {
            tasks = $scope.usTasks.getIn([usId.toString(), statusId.toString()]).size;
          } else {
            tasks = $scope.usTasks.getIn(['null', statusId.toString()]).size;
          }
          if ($scope.statusesFolded[statusId]) {
            if (tasks && $scope.usFolded[usId]) {
              tasksMatrixSize = Math.round(Math.sqrt(tasks));
              width = avatarWidth * tasksMatrixSize;
            } else {
              width = avatarWidth;
            }
            return width;
          }
          return 0;
        };
      })(this);
      setStatusColumnWidth = (function(_this) {
        return function(statusId, width) {
          var column;
          column = $el.find(".squish-status-" + statusId);
          if (width) {
            return column.css('max-width', width);
          } else {
            if ($scope.ctrl.zoomLevel === '0') {
              return column.css("max-width", 148);
            } else {
              return column.css("max-width", maxColumnWidth);
            }
          }
        };
      })(this);
      refreshTaskboardTableWidth = (function(_this) {
        return function() {
          var columnWidths, columns, issueCardMaxWidth, issuesBoxWidth, totalWidth;
          columnWidths = [];
          columns = $el.find(".task-colum-name");
          columnWidths = _.map(columns, function(column) {
            return $(column).outerWidth(true);
          });
          totalWidth = _.reduce(columnWidths, function(total, width) {
            return total + width;
          });
          $el.find('.taskboard-table-inner').css("width", totalWidth);
          issuesBoxWidth = $el.find('.issues-row .taskboard-row-title-box').outerWidth(true);
          $el.find('.issues-row').css("width", totalWidth - columnWidths.pop());
          issueCardMaxWidth = $scope.ctrl.zoomLevel === '0' ? 128 : 280;
          return $el.find('.issues-row .taskboard-cards-box .card').css("max-width", issueCardMaxWidth);
        };
      })(this);
      recalculateStatusColumnWidth = (function(_this) {
        return function(statusId) {
          var statusFoldedWidth;
          statusFoldedWidth = getCeilWidth(null, statusId);
          _.forEach($scope.userstories, function(us) {
            var width;
            width = getCeilWidth(us.id, statusId);
            if (width > statusFoldedWidth) {
              return statusFoldedWidth = width;
            }
          });
          return setStatusColumnWidth(statusId, statusFoldedWidth);
        };
      })(this);
      return recalculateTaskboardWidth = (function(_this) {
        return function() {
          _.forEach($scope.taskStatusList, function(status) {
            return recalculateStatusColumnWidth(status.id);
          });
          refreshTaskboardTableWidth();
        };
      })(this);
    };
    return {
      link: link
    };
  };

  module.directive("tgTaskboardSquishColumn", ["$tgResources", TaskboardSquishColumnDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/taskboard/sortable.coffee
 */

(function() {
  var TaskboardSortableDirective, bindOnce, groupBy, mixOf, module, scopeDefer, taiga, toggleText;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  toggleText = this.taiga.toggleText;

  scopeDefer = this.taiga.scopeDefer;

  bindOnce = this.taiga.bindOnce;

  groupBy = this.taiga.groupBy;

  module = angular.module("taigaBacklog");

  TaskboardSortableDirective = function($repo, $rs, $rootscope, $translate) {
    var link;
    link = function($scope, $el, $attrs) {
      var unwatch;
      return unwatch = $scope.$watch("usTasks", function(usTasks) {
        var containers, deleteElement, drake, filterError, itemEl, newParentScope, oldParentScope, scroll, tdom;
        if (!usTasks || !usTasks.size) {
          return;
        }
        unwatch();
        if (!($scope.project.my_permissions.indexOf("modify_task") > -1)) {
          return;
        }
        oldParentScope = null;
        newParentScope = null;
        itemEl = null;
        tdom = $el;
        filterError = function() {
          var text;
          text = $translate.instant("BACKLOG.SORTABLE_FILTER_ERROR");
          return $tgConfirm.notify("error", text);
        };
        deleteElement = function(itemEl) {
          itemEl.scope().$destroy();
          itemEl.off();
          return itemEl.remove();
        };
        containers = _.map($el.find('.taskboard-column'), function(item) {
          return item;
        });
        drake = dragula(containers, {
          copySortSource: false,
          copy: false,
          accepts: function(el, target) {
            return !$(target).hasClass('taskboard-row-title-box');
          },
          moves: function(item) {
            return $(item).is('tg-card');
          }
        });
        drake.on('drag', function(item) {
          oldParentScope = $(item).parent().scope();
          if ($el.hasClass("active-filters")) {
            filterError();
            setTimeout((function() {
              return drake.cancel(true);
            }), 0);
            return false;
          }
        });
        drake.on('dragend', function(item) {
          var itemIndex, itemTask, newStatusId, newUsId, oldStatusId, oldUsId, parentEl;
          parentEl = $(item).parent();
          itemEl = $(item);
          itemTask = itemEl.scope().task;
          itemIndex = itemEl.index();
          newParentScope = parentEl.scope();
          oldUsId = oldParentScope.us ? oldParentScope.us.id : null;
          oldStatusId = oldParentScope.st.id;
          newUsId = newParentScope.us ? newParentScope.us.id : null;
          newStatusId = newParentScope.st.id;
          if (newStatusId !== oldStatusId || newUsId !== oldUsId) {
            deleteElement(itemEl);
          }
          return $scope.$apply(function() {
            return $rootscope.$broadcast("taskboard:task:move", itemTask, itemTask.getIn(['model', 'status']), newUsId, newStatusId, itemIndex);
          });
        });
        scroll = autoScroll([$('.taskboard-table-body')[0]], {
          margin: 100,
          pixels: 30,
          scrollWhenOutside: true,
          autoScroll: function() {
            return this.down && drake.dragging;
          }
        });
        return $scope.$on("$destroy", function() {
          $el.off();
          return drake.destroy();
        });
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgTaskboardSortable", ["$tgRepo", "$tgResources", "$rootScope", "$translate", TaskboardSortableDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/taskboard/taskboard-issues.coffee
 */

(function() {
  var TaskboardIssuesService, groupBy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  groupBy = this.taiga.groupBy;

  TaskboardIssuesService = (function(superClass) {
    extend(TaskboardIssuesService, superClass);

    TaskboardIssuesService.$inject = [];

    function TaskboardIssuesService() {
      this.reset();
    }

    TaskboardIssuesService.prototype.reset = function() {
      this.foldStatusChanged = {};
      return this.issuesRaw = [];
    };

    TaskboardIssuesService.prototype.init = function(project, usersById, issueStatusById) {
      this.issueStatusById = issueStatusById;
      this.project = project;
      return this.usersById = usersById;
    };

    TaskboardIssuesService.prototype.resetFolds = function() {
      this.foldStatusChanged = {};
      return this.refresh();
    };

    TaskboardIssuesService.prototype.toggleFold = function(issueId) {
      this.foldStatusChanged[issueId] = !this.foldStatusChanged[issueId];
      return this.refresh();
    };

    TaskboardIssuesService.prototype.add = function(issue) {
      this.issuesRaw = this.issuesRaw.concat(issue);
      return this.refresh();
    };

    TaskboardIssuesService.prototype.remove = function(issue) {
      var item, key, ref;
      ref = this.issuesRaw;
      for (key in ref) {
        item = ref[key];
        if (issue.id === item.id) {
          this.issuesRaw.splice(key, 1);
          this.refresh();
          return;
        }
      }
    };

    TaskboardIssuesService.prototype.set = function(issues) {
      this.issuesRaw = issues;
      return this.refresh();
    };

    TaskboardIssuesService.prototype.getIssue = function(id) {
      return this.milestoneIssues.find(function(issue) {
        return issue.get('id') === id;
      });
    };

    TaskboardIssuesService.prototype.getIssueModel = function(id) {
      return _.find(this.issuesRaw, function(issue) {
        return issue.id === id;
      });
    };

    TaskboardIssuesService.prototype.replaceModel = function(issue) {
      this.issuesRaw = _.map(this.issuesRaw, function(item) {
        if (issue.id === item.id) {
          return issue;
        } else {
          return item;
        }
      });
      return this.refresh();
    };

    TaskboardIssuesService.prototype.refresh = function() {
      var i, issue, issueModel, issues, len, ref;
      issues = [];
      ref = this.issuesRaw;
      for (i = 0, len = ref.length; i < len; i++) {
        issueModel = ref[i];
        issue = {};
        issue.foldStatusChanged = this.foldStatusChanged[issueModel.id];
        issue.model = issueModel.getAttrs();
        issue.modelName = issueModel.getName();
        issue.id = issueModel.id;
        issue.status = this.issueStatusById[issueModel.status];
        issue.images = _.filter(issue.model.attachments, function(it) {
          return !!it.thumbnail_card_url;
        });
        issue.assigned_to = this.usersById[issueModel.assigned_to];
        issue.colorized_tags = _.map(issue.model.tags, function(tag) {
          return {
            name: tag[0],
            color: tag[1]
          };
        });
        issues.push(issue);
      }
      return this.milestoneIssues = Immutable.fromJS(issues);
    };

    return TaskboardIssuesService;

  })(taiga.Service);

  angular.module("taigaKanban").service("tgTaskboardIssues", TaskboardIssuesService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/taskboard/taskboard-tasks.coffee
 */

(function() {
  var TaskboardTasksService, groupBy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  groupBy = this.taiga.groupBy;

  TaskboardTasksService = (function(superClass) {
    extend(TaskboardTasksService, superClass);

    TaskboardTasksService.$inject = [];

    function TaskboardTasksService() {
      this.reset();
    }

    TaskboardTasksService.prototype.reset = function() {
      this.tasksRaw = [];
      this.foldStatusChanged = {};
      return this.usTasks = Immutable.Map();
    };

    TaskboardTasksService.prototype.init = function(project, usersById) {
      this.project = project;
      return this.usersById = usersById;
    };

    TaskboardTasksService.prototype.resetFolds = function() {
      this.foldStatusChanged = {};
      return this.refresh();
    };

    TaskboardTasksService.prototype.toggleFold = function(taskId) {
      this.foldStatusChanged[taskId] = !this.foldStatusChanged[taskId];
      return this.refresh();
    };

    TaskboardTasksService.prototype.add = function(task) {
      this.tasksRaw = this.tasksRaw.concat(task);
      return this.refresh();
    };

    TaskboardTasksService.prototype.set = function(tasks) {
      this.tasksRaw = tasks;
      this.refreshRawOrder();
      return this.refresh();
    };

    TaskboardTasksService.prototype.setUserstories = function(userstories) {
      return this.userstories = userstories;
    };

    TaskboardTasksService.prototype.refreshRawOrder = function() {
      var i, len, ref, results, task;
      this.order = {};
      ref = this.tasksRaw;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        task = ref[i];
        results.push(this.order[task.id] = task.taskboard_order);
      }
      return results;
    };

    TaskboardTasksService.prototype.assignOrders = function(order) {
      order = _.invert(order);
      this.order = _.assign(this.order, order);
      return this.refresh();
    };

    TaskboardTasksService.prototype.getTask = function(id) {
      var findedTask;
      findedTask = null;
      this.usTasks.forEach(function(us) {
        us.forEach(function(status) {
          findedTask = status.find(function(task) {
            return task.get('id') === id;
          });
          if (findedTask) {
            return false;
          }
        });
        if (findedTask) {
          return false;
        }
      });
      return findedTask;
    };

    TaskboardTasksService.prototype.replace = function(task) {
      return this.usTasks = this.usTasks.map(function(us) {
        return us.map(function(status) {
          var findedIndex;
          findedIndex = status.findIndex(function(usItem) {
            return usItem.get('id') === us.get('id');
          });
          if (findedIndex !== -1) {
            status = status.set(findedIndex, task);
          }
          return status;
        });
      });
    };

    TaskboardTasksService.prototype.getTaskModel = function(id) {
      return _.find(this.tasksRaw, function(task) {
        return task.id === id;
      });
    };

    TaskboardTasksService.prototype.replaceModel = function(task) {
      this.tasksRaw = _.map(this.tasksRaw, function(it) {
        if (task.id === it.id) {
          return task;
        } else {
          return it;
        }
      });
      return this.refresh();
    };

    TaskboardTasksService.prototype.move = function(id, usId, statusId, index) {
      var afterDestination, beforeDestination, i, it, j, key, len, len1, previous, previousWithTheSameOrder, setOrders, taksWithoutMoved, task, taskByUsStatus;
      task = this.getTaskModel(id);
      taskByUsStatus = _.filter(this.tasksRaw, (function(_this) {
        return function(task) {
          return task.status === statusId && task.user_story === usId;
        };
      })(this));
      taskByUsStatus = _.sortBy(taskByUsStatus, (function(_this) {
        return function(it) {
          return _this.order[it.id];
        };
      })(this));
      taksWithoutMoved = _.filter(taskByUsStatus, (function(_this) {
        return function(it) {
          return it.id !== id;
        };
      })(this));
      beforeDestination = _.slice(taksWithoutMoved, 0, index);
      afterDestination = _.slice(taksWithoutMoved, index);
      setOrders = {};
      previous = beforeDestination[beforeDestination.length - 1];
      previousWithTheSameOrder = _.filter(beforeDestination, (function(_this) {
        return function(it) {
          return _this.order[it.id] === _this.order[previous.id];
        };
      })(this));
      if (previousWithTheSameOrder.length > 1) {
        for (i = 0, len = previousWithTheSameOrder.length; i < len; i++) {
          it = previousWithTheSameOrder[i];
          setOrders[it.id] = this.order[it.id];
        }
      }
      if (!previous) {
        this.order[task.id] = 0;
      } else if (previous) {
        this.order[task.id] = this.order[previous.id] + 1;
      }
      for (key = j = 0, len1 = afterDestination.length; j < len1; key = ++j) {
        it = afterDestination[key];
        this.order[it.id] = this.order[task.id] + key + 1;
      }
      task.status = statusId;
      task.user_story = usId;
      task.taskboard_order = this.order[task.id];
      this.refresh();
      return {
        "task_id": task.id,
        "order": this.order[task.id],
        "set_orders": setOrders
      };
    };

    TaskboardTasksService.prototype.refresh = function() {
      var i, j, k, len, len1, len2, model, ref, status, task, taskModel, taskStatusList, tasks, us, usTasks;
      if (!this.project) {
        return;
      }
      this.tasksRaw = _.sortBy(this.tasksRaw, (function(_this) {
        return function(it) {
          return _this.order[it.id];
        };
      })(this));
      tasks = this.tasksRaw;
      taskStatusList = _.sortBy(this.project.task_statuses, "order");
      usTasks = {};
      ref = _.union(this.userstories, [
        {
          id: null
        }
      ]);
      for (i = 0, len = ref.length; i < len; i++) {
        us = ref[i];
        usTasks[us.id] = {};
        for (j = 0, len1 = taskStatusList.length; j < len1; j++) {
          status = taskStatusList[j];
          usTasks[us.id][status.id] = [];
        }
      }
      for (k = 0, len2 = tasks.length; k < len2; k++) {
        taskModel = tasks[k];
        if ((usTasks[taskModel.user_story] != null) && (usTasks[taskModel.user_story][taskModel.status] != null)) {
          task = {};
          model = taskModel.getAttrs();
          task.foldStatusChanged = this.foldStatusChanged[taskModel.id];
          task.model = model;
          task.images = _.filter(model.attachments, function(it) {
            return !!it.thumbnail_card_url;
          });
          task.id = taskModel.id;
          task.assigned_to = this.usersById[taskModel.assigned_to];
          task.colorized_tags = _.map(task.model.tags, (function(_this) {
            return function(tag) {
              return {
                name: tag[0],
                color: tag[1]
              };
            };
          })(this));
          usTasks[taskModel.user_story][taskModel.status].push(task);
        }
      }
      return this.usTasks = Immutable.fromJS(usTasks);
    };

    return TaskboardTasksService;

  })(taiga.Service);

  angular.module("taigaKanban").service("tgTaskboardTasks", TaskboardTasksService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/kanban/kanban-usertories.coffee
 */

(function() {
  var KanbanUserstoriesService, groupBy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  groupBy = this.taiga.groupBy;

  KanbanUserstoriesService = (function(superClass) {
    extend(KanbanUserstoriesService, superClass);

    KanbanUserstoriesService.$inject = [];

    function KanbanUserstoriesService() {
      this.reset();
    }

    KanbanUserstoriesService.prototype.reset = function() {
      this.userstoriesRaw = [];
      this.archivedStatus = [];
      this.statusHide = [];
      this.foldStatusChanged = {};
      return this.usByStatus = Immutable.Map();
    };

    KanbanUserstoriesService.prototype.init = function(project, usersById) {
      this.project = project;
      return this.usersById = usersById;
    };

    KanbanUserstoriesService.prototype.resetFolds = function() {
      return this.foldStatusChanged = {};
    };

    KanbanUserstoriesService.prototype.toggleFold = function(usId) {
      this.foldStatusChanged[usId] = !this.foldStatusChanged[usId];
      return this.refreshUserStory(usId);
    };

    KanbanUserstoriesService.prototype.set = function(userstories) {
      this.userstoriesRaw = userstories;
      this.refreshRawOrder();
      return this.refresh();
    };

    KanbanUserstoriesService.prototype.add = function(us) {
      this.userstoriesRaw = this.userstoriesRaw.concat(us);
      this.refreshRawOrder();
      return this.refresh();
    };

    KanbanUserstoriesService.prototype.addArchivedStatus = function(statusId) {
      return this.archivedStatus.push(statusId);
    };

    KanbanUserstoriesService.prototype.isUsInArchivedHiddenStatus = function(usId) {
      var us;
      us = this.getUsModel(usId);
      return this.archivedStatus.indexOf(us != null ? us.status : void 0) !== -1 && this.statusHide.indexOf(us != null ? us.status : void 0) !== -1;
    };

    KanbanUserstoriesService.prototype.hideStatus = function(statusId) {
      this.deleteStatus(statusId);
      return this.statusHide.push(statusId);
    };

    KanbanUserstoriesService.prototype.showStatus = function(statusId) {
      return _.remove(this.statusHide, function(it) {
        return it === statusId;
      });
    };

    KanbanUserstoriesService.prototype.getStatus = function(statusId) {
      return _.filter(this.userstoriesRaw, function(us) {
        return us.status === statusId;
      });
    };

    KanbanUserstoriesService.prototype.deleteStatus = function(statusId) {
      var toDelete;
      toDelete = _.filter(this.userstoriesRaw, function(us) {
        return us.status === statusId;
      });
      toDelete = _.map(function(it) {
        return it.id;
      });
      this.archived = _.difference(this.archived, toDelete);
      this.userstoriesRaw = _.filter(this.userstoriesRaw, function(us) {
        return us.status !== statusId;
      });
      return this.refresh();
    };

    KanbanUserstoriesService.prototype.refreshRawOrder = function() {
      var i, it, len, ref, results;
      this.order = {};
      ref = this.userstoriesRaw;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        it = ref[i];
        results.push(this.order[it.id] = it.kanban_order);
      }
      return results;
    };

    KanbanUserstoriesService.prototype.assignOrders = function(order) {
      this.order = _.assign(this.order, order);
      return this.refresh();
    };

    KanbanUserstoriesService.prototype.move = function(usList, statusId, index) {
      var afterDestination, beforeDestination, i, initialLength, isArchivedHiddenStatus, it, j, k, key, l, len, len1, len2, len3, modifiedUs, previous, previousWithTheSameOrder, setNextOrders, setOrders, setPreviousOrders, startIndex, us, usByStatus, usByStatusWithoutMoved;
      initialLength = usList.length;
      usByStatus = _.filter(this.userstoriesRaw, (function(_this) {
        return function(it) {
          return it.status === statusId;
        };
      })(this));
      usByStatus = _.sortBy(usByStatus, (function(_this) {
        return function(it) {
          return _this.order[it.id];
        };
      })(this));
      usByStatusWithoutMoved = _.filter(usByStatus, function(listIt) {
        return !_.find(usList, function(moveIt) {
          return listIt.id === moveIt.id;
        });
      });
      beforeDestination = _.slice(usByStatusWithoutMoved, 0, index);
      afterDestination = _.slice(usByStatusWithoutMoved, index);
      setOrders = {};
      previous = beforeDestination[beforeDestination.length - 1];
      previousWithTheSameOrder = _.filter(beforeDestination, (function(_this) {
        return function(it) {
          return _this.order[it.id] === _this.order[previous.id];
        };
      })(this));
      if (previousWithTheSameOrder.length > 1) {
        for (i = 0, len = previousWithTheSameOrder.length; i < len; i++) {
          it = previousWithTheSameOrder[i];
          setOrders[it.id] = this.order[it.id];
        }
      }
      modifiedUs = [];
      setPreviousOrders = [];
      setNextOrders = [];
      isArchivedHiddenStatus = this.archivedStatus.indexOf(statusId) !== -1 && this.statusHide.indexOf(statusId) !== -1;
      if (isArchivedHiddenStatus) {
        startIndex = new Date().getTime();
      } else if (!previous) {
        startIndex = 0;
        for (key = j = 0, len1 = afterDestination.length; j < len1; key = ++j) {
          it = afterDestination[key];
          this.order[it.id] = key + initialLength + 1;
          it.kanban_order = this.order[it.id];
        }
        setNextOrders = _.map(afterDestination, (function(_this) {
          return function(it) {
            return {
              us_id: it.id,
              order: _this.order[it.id]
            };
          };
        })(this));
      } else if (previous) {
        startIndex = this.order[previous.id] + 1;
        previousWithTheSameOrder = _.filter(beforeDestination, (function(_this) {
          return function(it) {
            return it.kanban_order === _this.order[previous.id];
          };
        })(this));
        for (key = k = 0, len2 = afterDestination.length; k < len2; key = ++k) {
          it = afterDestination[key];
          this.order[it.id] = this.order[previous.id] + key + initialLength + 1;
          it.kanban_order = this.order[it.id];
        }
        setNextOrders = _.map(afterDestination, (function(_this) {
          return function(it) {
            return {
              us_id: it.id,
              order: _this.order[it.id]
            };
          };
        })(this));
        if (previousWithTheSameOrder.length > 1) {
          setPreviousOrders = _.map(previousWithTheSameOrder, (function(_this) {
            return function(it) {
              return {
                us_id: it.id,
                order: _this.order[it.id]
              };
            };
          })(this));
        }
      }
      for (key = l = 0, len3 = usList.length; l < len3; key = ++l) {
        us = usList[key];
        us.status = statusId;
        us.kanban_order = startIndex + key;
        this.order[us.id] = us.kanban_order;
        modifiedUs.push({
          us_id: us.id,
          order: us.kanban_order
        });
      }
      this.refresh();
      return {
        bulkOrders: modifiedUs.concat(setPreviousOrders, setNextOrders),
        usList: modifiedUs,
        set_orders: setOrders
      };
    };

    KanbanUserstoriesService.prototype.moveToEnd = function(id, statusId) {
      var us;
      us = this.getUsModel(id);
      this.order[us.id] = -1;
      us.status = statusId;
      us.kanban_order = this.order[us.id];
      this.refresh();
      return {
        "us_id": us.id,
        "order": -1
      };
    };

    KanbanUserstoriesService.prototype.replace = function(us) {
      return this.usByStatus = this.usByStatus.map(function(status) {
        var findedIndex;
        findedIndex = status.findIndex(function(usItem) {
          return usItem.get('id') === us.get('id');
        });
        if (findedIndex !== -1) {
          status = status.set(findedIndex, us);
        }
        return status;
      });
    };

    KanbanUserstoriesService.prototype.replaceModel = function(us) {
      this.userstoriesRaw = _.map(this.userstoriesRaw, function(usItem) {
        if (us.id === usItem.id) {
          return us;
        } else {
          return usItem;
        }
      });
      return this.refresh();
    };

    KanbanUserstoriesService.prototype.getUs = function(id) {
      var findedUs;
      findedUs = null;
      this.usByStatus.forEach(function(status) {
        findedUs = status.find(function(us) {
          return us.get('id') === id;
        });
        if (findedUs) {
          return false;
        }
      });
      return findedUs;
    };

    KanbanUserstoriesService.prototype.getUsModel = function(id) {
      return _.find(this.userstoriesRaw, function(us) {
        return us.id === id;
      });
    };

    KanbanUserstoriesService.prototype.refreshUserStory = function(usId) {
      var collection, index, us, usModel;
      usModel = this.getUsModel(usId);
      collection = this.usByStatus.toJS();
      index = _.findIndex(collection[usModel.status], (function(_this) {
        return function(x) {
          return x.id === usId;
        };
      })(this));
      us = this.retrieveUserStoryData(usModel);
      collection[usModel.status][index] = us;
      return this.usByStatus = Immutable.fromJS(collection);
    };

    KanbanUserstoriesService.prototype.retrieveUserStoryData = function(usModel) {
      var model, us;
      us = {};
      model = usModel.getAttrs();
      us.foldStatusChanged = this.foldStatusChanged[usModel.id];
      us.model = model;
      us.images = _.filter(model.attachments, function(it) {
        return !!it.thumbnail_card_url;
      });
      us.id = usModel.id;
      us.assigned_to = this.usersById[usModel.assigned_to];
      us.assigned_users = [];
      usModel.assigned_users.forEach((function(_this) {
        return function(assignedUserId) {
          var assignedUserData;
          assignedUserData = _this.usersById[assignedUserId];
          return us.assigned_users.push(assignedUserData);
        };
      })(this));
      us.colorized_tags = _.map(us.model.tags, (function(_this) {
        return function(tag) {
          return {
            name: tag[0],
            color: tag[1]
          };
        };
      })(this));
      return us;
    };

    KanbanUserstoriesService.prototype.refresh = function() {
      var collection, key, ref, us, usModel;
      this.userstoriesRaw = _.sortBy(this.userstoriesRaw, (function(_this) {
        return function(it) {
          return _this.order[it.id];
        };
      })(this));
      collection = {};
      ref = this.userstoriesRaw;
      for (key in ref) {
        usModel = ref[key];
        us = this.retrieveUserStoryData(usModel);
        if (!collection[us.model.status]) {
          collection[us.model.status] = [];
        }
        collection[us.model.status].push(us);
      }
      return this.usByStatus = Immutable.fromJS(collection);
    };

    return KanbanUserstoriesService;

  })(taiga.Service);

  angular.module("taigaKanban").service("tgKanbanUserstories", KanbanUserstoriesService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/kanban/main.coffee
 */

(function() {
  var KanbanArchivedStatusHeaderDirective, KanbanArchivedStatusIntroDirective, KanbanController, KanbanDirective, KanbanSquishColumnDirective, KanbanWipLimitDirective, bindMethods, bindOnce, debounceLeading, groupBy, mixOf, module, scopeDefer, taiga, timeout, toggleText,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  toggleText = this.taiga.toggleText;

  scopeDefer = this.taiga.scopeDefer;

  bindOnce = this.taiga.bindOnce;

  groupBy = this.taiga.groupBy;

  timeout = this.taiga.timeout;

  bindMethods = this.taiga.bindMethods;

  debounceLeading = this.taiga.debounceLeading;

  module = angular.module("taigaKanban");

  KanbanController = (function(superClass) {
    extend(KanbanController, superClass);

    KanbanController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "tgResources", "$routeParams", "$q", "$tgLocation", "tgAppMetaService", "$tgNavUrls", "$tgEvents", "$tgAnalytics", "$translate", "tgErrorHandlingService", "$tgModel", "tgKanbanUserstories", "$tgStorage", "tgFilterRemoteStorageService", "tgProjectService", "tgLightboxFactory", "tgLoader", "$timeout"];

    KanbanController.prototype.storeCustomFiltersName = 'kanban-custom-filters';

    KanbanController.prototype.storeFiltersName = 'kanban-filters';

    function KanbanController(scope, rootscope, repo, confirm, rs1, rs2, params1, q, location, appMetaService, navUrls, events, analytics, translate, errorHandlingService, model, kanbanUserstoriesService1, storage, filterRemoteStorageService, projectService1, lightboxFactory, tgLoader, timeout1) {
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs1;
      this.rs2 = rs2;
      this.params = params1;
      this.q = q;
      this.location = location;
      this.appMetaService = appMetaService;
      this.navUrls = navUrls;
      this.events = events;
      this.analytics = analytics;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.model = model;
      this.kanbanUserstoriesService = kanbanUserstoriesService1;
      this.storage = storage;
      this.filterRemoteStorageService = filterRemoteStorageService;
      this.projectService = projectService1;
      this.lightboxFactory = lightboxFactory;
      this.tgLoader = tgLoader;
      this.timeout = timeout1;
      this.renderUserStories = bind(this.renderUserStories, this);
      this.changeUsAssignedUsers = bind(this.changeUsAssignedUsers, this);
      bindMethods(this);
      this.kanbanUserstoriesService.reset();
      this.openFilter = false;
      this.selectedUss = {};
      if (this.applyStoredFilters(this.params.pslug, "kanban-filters")) {
        return;
      }
      this.scope.sectionName = this.translate.instant("KANBAN.SECTION_NAME");
      this.initializeEventHandlers();
      taiga.defineImmutableProperty(this.scope, "usByStatus", (function(_this) {
        return function() {
          return _this.kanbanUserstoriesService.usByStatus;
        };
      })(this));
    }

    KanbanController.prototype.cleanSelectedUss = function() {
      var key, results;
      results = [];
      for (key in this.selectedUss) {
        results.push(this.selectedUss[key] = false);
      }
      return results;
    };

    KanbanController.prototype.toggleSelectedUs = function(usId) {
      return this.selectedUss[usId] = !this.selectedUss[usId];
    };

    KanbanController.prototype.firstLoad = function() {
      var promise;
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("KANBAN.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.translate.instant("KANBAN.PAGE_DESCRIPTION", {
            projectName: _this.scope.project.name,
            projectDescription: _this.scope.project.description
          });
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      return promise.then(null, this.onInitialDataError.bind(this));
    };

    KanbanController.prototype.setZoom = function(zoomLevel, zoom) {
      var previousZoomLevel;
      if (this.zoomLevel === zoomLevel) {
        return null;
      }
      this.isFirstLoad = !this.zoomLevel;
      previousZoomLevel = this.zoomLevel;
      this.zoomLevel = zoomLevel;
      this.zoom = zoom;
      if (this.isFirstLoad) {
        return this.firstLoad().then((function(_this) {
          return function() {
            _this.isFirstLoad = false;
            return _this.kanbanUserstoriesService.resetFolds();
          };
        })(this));
      } else if (this.zoomLevel > 2 && previousZoomLevel <= 2) {
        this.zoomLoading = true;
        return this.loadUserstories().then((function(_this) {
          return function() {
            _this.zoomLoading = false;
            return _this.kanbanUserstoriesService.resetFolds();
          };
        })(this));
      }
    };

    KanbanController.prototype.filtersReloadContent = function() {
      return this.loadUserstories().then((function(_this) {
        return function() {
          var i, len, openArchived, results, statusId;
          openArchived = _.difference(_this.kanbanUserstoriesService.archivedStatus, _this.kanbanUserstoriesService.statusHide);
          if (openArchived.length) {
            results = [];
            for (i = 0, len = openArchived.length; i < len; i++) {
              statusId = openArchived[i];
              results.push(_this.loadUserStoriesForStatus({}, statusId));
            }
            return results;
          }
        };
      })(this));
    };

    KanbanController.prototype.initializeEventHandlers = function() {
      this.scope.$on("usform:new:success", (function(_this) {
        return function(event, us) {
          _this.refreshTagsColors().then(function() {
            return _this.kanbanUserstoriesService.add(us);
          });
          return _this.analytics.trackEvent("userstory", "create", "create userstory on kanban", 1);
        };
      })(this));
      this.scope.$on("usform:bulk:success", (function(_this) {
        return function(event, uss) {
          _this.confirm.notify("success");
          _this.refreshTagsColors().then(function() {
            return _this.kanbanUserstoriesService.add(uss);
          });
          return _this.analytics.trackEvent("userstory", "create", "bulk create userstory on kanban", 1);
        };
      })(this));
      this.scope.$on("usform:edit:success", (function(_this) {
        return function(event, us) {
          return _this.refreshTagsColors().then(function() {
            return _this.kanbanUserstoriesService.replaceModel(us);
          });
        };
      })(this));
      this.scope.$on("kanban:us:deleted", (function(_this) {
        return function(event, us) {
          return _this.filtersReloadContent();
        };
      })(this));
      this.scope.$on("kanban:us:move", this.moveUs);
      this.scope.$on("kanban:show-userstories-for-status", this.loadUserStoriesForStatus);
      return this.scope.$on("kanban:hide-userstories-for-status", this.hideUserStoriesForStatus);
    };

    KanbanController.prototype.addNewUs = function(type, statusId) {
      switch (type) {
        case "standard":
          return this.rootscope.$broadcast("genericform:new", {
            'objType': 'us',
            'project': this.scope.project,
            'statusId': statusId
          });
        case "bulk":
          return this.rootscope.$broadcast("usform:bulk", this.scope.projectId, statusId);
      }
    };

    KanbanController.prototype.editUs = function(id) {
      var us;
      us = this.kanbanUserstoriesService.getUs(id);
      us = us.set('loading-edit', true);
      this.kanbanUserstoriesService.replace(us);
      return this.rs.userstories.getByRef(us.getIn(['model', 'project']), us.getIn(['model', 'ref'])).then((function(_this) {
        return function(editingUserStory) {
          _this.rs2.attachments.list("us", us.get('id'), us.getIn(['model', 'project'])).then(function(attachments) {
            return _this.rootscope.$broadcast("genericform:edit", {
              'objType': 'us',
              'obj': editingUserStory,
              'statusList': _this.scope.usStatusList,
              'attachments': attachments.toJS()
            });
          });
          us = us.set('loading-edit', false);
          return _this.kanbanUserstoriesService.replace(us);
        };
      })(this));
    };

    KanbanController.prototype.deleteUs = function(id) {
      var us;
      us = this.kanbanUserstoriesService.getUs(id);
      us = us.set('loading-delete', true);
      return this.rs.userstories.getByRef(us.getIn(['model', 'project']), us.getIn(['model', 'ref'])).then((function(_this) {
        return function(deletingUserStory) {
          var message, title;
          us = us.set('loading-delete', false);
          title = _this.translate.instant("US.TITLE_DELETE_ACTION");
          message = deletingUserStory.subject;
          return _this.confirm.askOnDelete(title, message).then(function(askResponse) {
            var promise;
            promise = _this.repo.remove(deletingUserStory);
            promise.then(function() {
              _this.scope.$broadcast("kanban:us:deleted");
              return askResponse.finish();
            });
            return promise.then(null, function() {
              askResponse.finish(false);
              return this.confirm.notify("error");
            });
          });
        };
      })(this));
    };

    KanbanController.prototype.showPlaceHolder = function(statusId) {
      if (this.scope.usStatusList[0].id === statusId && !this.kanbanUserstoriesService.userstoriesRaw.length) {
        return true;
      }
      return false;
    };

    KanbanController.prototype.toggleFold = function(id) {
      return this.kanbanUserstoriesService.toggleFold(id);
    };

    KanbanController.prototype.isUsInArchivedHiddenStatus = function(usId) {
      return this.kanbanUserstoriesService.isUsInArchivedHiddenStatus(usId);
    };

    KanbanController.prototype.changeUsAssignedUsers = function(id) {
      var item, onClose;
      item = this.kanbanUserstoriesService.getUsModel(id);
      onClose = (function(_this) {
        return function(assignedUsersIds) {
          var ref;
          item.assigned_users = assignedUsersIds;
          if ((ref = item.assigned_to, indexOf.call(assignedUsersIds, ref) < 0) && assignedUsersIds.length > 0) {
            item.assigned_to = assignedUsersIds[0];
          }
          if (assignedUsersIds.length === 0) {
            item.assigned_to = null;
          }
          _this.kanbanUserstoriesService.replaceModel(item);
          return _this.repo.save(item).then(function() {
            _this.generateFilters();
            if (_this.isFilterDataTypeSelected('assigned_users') || _this.isFilterDataTypeSelected('role')) {
              return _this.filtersReloadContent();
            }
          });
        };
      })(this);
      return this.lightboxFactory.create('tg-lb-select-user', {
        "class": "lightbox lightbox-select-user"
      }, {
        "currentUsers": _.compact(_.union(item.assigned_users, [item.assigned_to])),
        "activeUsers": this.scope.activeUsers,
        "onClose": onClose,
        "lbTitle": this.translate.instant("COMMON.ASSIGNED_USERS.ADD")
      });
    };

    KanbanController.prototype.refreshTagsColors = function() {
      return this.rs.projects.tagsColors(this.scope.projectId).then((function(_this) {
        return function(tags_colors) {
          return _this.scope.project.tags_colors = tags_colors._attrs;
        };
      })(this));
    };

    KanbanController.prototype.renderBatch = function() {
      this.rendered = _.concat(this.rendered, _.take(this.queue, this.batchSize));
      this.queue = _.drop(this.queue, this.batchSize);
      this.kanbanUserstoriesService.set(this.rendered);
      this.scope.$broadcast("redraw:wip");
      if (this.queue.length > 0) {
        return this.timeout(this.renderBatch);
      } else {
        return scopeDefer(this.scope, (function(_this) {
          return function() {
            _this.rootscope.$broadcast("kanban:userstories:loaded", _this.rendered);
            return _this.scope.$broadcast("userstories:loaded", _this.rendered);
          };
        })(this));
      }
    };

    KanbanController.prototype.renderUserStories = function(userstories) {
      var userstoriesMap;
      userstories = _.sortBy(userstories, 'kanban_order');
      userstoriesMap = _.groupBy(userstories, 'status');
      this.rendered = [];
      this.queue = [];
      this.batchSize = 0;
      while (this.queue.length < userstories.length) {
        _.each(this.scope.project.us_statuses, (function(_this) {
          return function(x) {
            var ref;
            if (((ref = userstoriesMap[x.id]) != null ? ref.length : void 0) > 0) {
              _this.queue = _.concat(_this.queue, _.take(userstoriesMap[x.id], 3));
              return userstoriesMap[x.id] = _.drop(userstoriesMap[x.id], 3);
            }
          };
        })(this));
        if (!this.batchSize) {
          this.batchSize = this.queue.length;
        }
      }
      return this.timeout(this.renderBatch);
    };

    KanbanController.prototype.loadUserstories = function() {
      var params, promise;
      params = {
        status__is_archived: false
      };
      if (this.zoomLevel > 2) {
        params.include_attachments = 1;
        params.include_tasks = 1;
      }
      params = _.merge(params, this.location.search());
      promise = this.rs.userstories.listAll(this.scope.projectId, params).then((function(_this) {
        return function(userstories) {
          _this.kanbanUserstoriesService.init(_this.scope.project, _this.scope.usersById);
          _this.tgLoader.pageLoaded();
          _this.renderUserStories(userstories);
          return userstories;
        };
      })(this));
      return promise;
    };

    KanbanController.prototype.loadUserStoriesForStatus = function(ctx, statusId) {
      var filteredStatus, params;
      filteredStatus = this.location.search().status;
      if (filteredStatus) {
        filteredStatus = filteredStatus.split(",").map(function(it) {
          return parseInt(it, 10);
        });
        if (filteredStatus.indexOf(statusId) === -1) {
          return;
        }
      }
      params = {
        status: statusId,
        include_attachments: true,
        include_tasks: true
      };
      params = _.merge(params, this.location.search());
      return this.rs.userstories.listAll(this.scope.projectId, params).then((function(_this) {
        return function(userstories) {
          _this.scope.$broadcast("kanban:shown-userstories-for-status", statusId, userstories);
          return userstories;
        };
      })(this));
    };

    KanbanController.prototype.hideUserStoriesForStatus = function(ctx, statusId) {
      return this.scope.$broadcast("kanban:hidden-userstories-for-status", statusId);
    };

    KanbanController.prototype.loadKanban = function() {
      return this.q.all([this.refreshTagsColors(), this.loadUserstories()]);
    };

    KanbanController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      if (!project.is_kanban_activated) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.projectId = project.id;
      this.scope.points = _.sortBy(project.points, "order");
      this.scope.pointsById = groupBy(project.points, function(x) {
        return x.id;
      });
      this.scope.usStatusById = groupBy(project.us_statuses, function(x) {
        return x.id;
      });
      this.scope.usStatusList = _.sortBy(project.us_statuses, "order");
      this.scope.$emit("project:loaded", project);
      return project;
    };

    KanbanController.prototype.initializeSubscription = function() {
      var randomTimeout, routingKey1;
      routingKey1 = "changes.project." + this.scope.projectId + ".userstories";
      randomTimeout = taiga.randomInt(700, 1000);
      return this.events.subscribe(this.scope, routingKey1, debounceLeading(randomTimeout, (function(_this) {
        return function(message) {
          return _this.loadUserstories();
        };
      })(this)));
    };

    KanbanController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      this.initializeSubscription();
      this.loadKanban();
      return this.generateFilters();
    };

    KanbanController.prototype.prepareBulkUpdateData = function(uses, field) {
      if (field == null) {
        field = "kanban_order";
      }
      return _.map(uses, function(x) {
        return {
          "us_id": x.id,
          "order": x[field]
        };
      });
    };

    KanbanController.prototype.moveUs = function(ctx, usList, newStatusId, index) {
      var data, promise;
      this.cleanSelectedUss();
      usList = _.map(usList, (function(_this) {
        return function(us) {
          return _this.kanbanUserstoriesService.getUsModel(us.id);
        };
      })(this));
      this.rootscope.$broadcast("kanban:userstories:loaded", usList, newStatusId, index);
      data = this.kanbanUserstoriesService.move(usList, newStatusId, index);
      promise = this.rs.userstories.bulkUpdateKanbanOrder(this.scope.projectId, newStatusId, data.bulkOrders);
      return promise.then((function(_this) {
        return function() {
          var options, params, promises;
          options = {
            headers: {
              "set-orders": JSON.stringify(data.setOrders)
            }
          };
          params = {
            include_attachments: true,
            include_tasks: true
          };
          promises = _.map(usList, function(us) {
            return _this.repo.save(us, true, params, options, true);
          });
          promise = _this.q.all(promises);
          return promise.then(function(result) {
            var headers, order;
            headers = result[1];
            if (headers && headers['taiga-info-order-updated']) {
              order = JSON.parse(headers['taiga-info-order-updated']);
              _this.kanbanUserstoriesService.assignOrders(order);
            }
            _this.scope.$broadcast("redraw:wip");
            _this.generateFilters();
            if (_this.isFilterDataTypeSelected('status')) {
              _this.filtersReloadContent();
            }
            return promise;
          });
        };
      })(this));
    };

    return KanbanController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin, taiga.UsFiltersMixin));

  module.controller("KanbanController", KanbanController);

  KanbanDirective = function($repo, $rootscope) {
    var link;
    link = function($scope, $el, $attrs) {
      var tableBodyDom;
      tableBodyDom = $el.find(".kanban-table-body");
      tableBodyDom.on("scroll", function(event) {
        var tableHeaderDom, target;
        target = angular.element(event.currentTarget);
        tableHeaderDom = $el.find(".kanban-table-header .kanban-table-inner");
        return tableHeaderDom.css("left", -1 * target.scrollLeft());
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgKanban", ["$tgRepo", "$rootScope", KanbanDirective]);

  KanbanArchivedStatusHeaderDirective = function($rootscope, $translate, kanbanUserstoriesService) {
    var hideArchivedText, link, showArchivedText;
    showArchivedText = $translate.instant("KANBAN.ACTION_SHOW_ARCHIVED");
    hideArchivedText = $translate.instant("KANBAN.ACTION_HIDE_ARCHIVED");
    link = function($scope, $el, $attrs) {
      var hidden, status;
      status = $scope.$eval($attrs.tgKanbanArchivedStatusHeader);
      hidden = true;
      kanbanUserstoriesService.addArchivedStatus(status.id);
      kanbanUserstoriesService.hideStatus(status.id);
      $scope["class"] = "icon-watch";
      $scope.title = showArchivedText;
      $el.on("click", function(event) {
        hidden = !hidden;
        return $scope.$apply(function() {
          if (hidden) {
            $scope["class"] = "icon-watch";
            $scope.title = showArchivedText;
            $rootscope.$broadcast("kanban:hide-userstories-for-status", status.id);
            return kanbanUserstoriesService.hideStatus(status.id);
          } else {
            $scope["class"] = "icon-unwatch";
            $scope.title = hideArchivedText;
            $rootscope.$broadcast("kanban:show-userstories-for-status", status.id);
            return kanbanUserstoriesService.showStatus(status.id);
          }
        });
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgKanbanArchivedStatusHeader", ["$rootScope", "$translate", "tgKanbanUserstories", KanbanArchivedStatusHeaderDirective]);

  KanbanArchivedStatusIntroDirective = function($translate, kanbanUserstoriesService) {
    var link, userStories;
    userStories = [];
    link = function($scope, $el, $attrs) {
      var hiddenUserStoriexText, status, updateIntroText;
      hiddenUserStoriexText = $translate.instant("KANBAN.HIDDEN_USER_STORIES");
      status = $scope.$eval($attrs.tgKanbanArchivedStatusIntro);
      $el.text(hiddenUserStoriexText);
      updateIntroText = function(hasArchived) {
        if (hasArchived) {
          return $el.text("");
        } else {
          return $el.text(hiddenUserStoriexText);
        }
      };
      $scope.$on("kanban:us:move", function(ctx, itemUs, oldStatusId, newStatusId, itemIndex) {
        var hasArchived;
        hasArchived = !!kanbanUserstoriesService.getStatus(newStatusId).length;
        return updateIntroText(hasArchived);
      });
      $scope.$on("kanban:shown-userstories-for-status", function(ctx, statusId, userStoriesLoaded) {
        var hasArchived;
        if (statusId === status.id) {
          kanbanUserstoriesService.deleteStatus(statusId);
          kanbanUserstoriesService.add(userStoriesLoaded);
          hasArchived = !!kanbanUserstoriesService.getStatus(statusId).length;
          return updateIntroText(hasArchived);
        }
      });
      $scope.$on("kanban:hidden-userstories-for-status", function(ctx, statusId) {
        if (statusId === status.id) {
          return updateIntroText(false);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgKanbanArchivedStatusIntro", ["$translate", "tgKanbanUserstories", KanbanArchivedStatusIntroDirective]);

  KanbanSquishColumnDirective = function(rs, projectService) {
    var link;
    link = function($scope, $el, $attrs) {
      var unwatch, updateTableWidth;
      $scope.foldStatus = function(status) {
        $scope.folds[status.id] = !!!$scope.folds[status.id];
        rs.kanban.storeStatusColumnModes($scope.projectId, $scope.folds);
        updateTableWidth();
      };
      updateTableWidth = function() {
        var columnWidths, totalWidth;
        columnWidths = _.map($scope.usStatusList, function(status) {
          if ($scope.folds[status.id]) {
            return 40;
          } else {
            return 310;
          }
        });
        totalWidth = _.reduce(columnWidths, function(total, width) {
          return total + width;
        });
        return $el.find('.kanban-table-inner').css("width", totalWidth);
      };
      return unwatch = $scope.$watch('usByStatus', function(usByStatus) {
        if (usByStatus != null ? usByStatus.size : void 0) {
          $scope.folds = rs.kanban.getStatusColumnModes(projectService.project.get('id'));
          updateTableWidth();
          return unwatch();
        }
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgKanbanSquishColumn", ["$tgResources", "tgProjectService", KanbanSquishColumnDirective]);

  KanbanWipLimitDirective = function($timeout) {
    var link;
    link = function($scope, $el, $attrs) {
      var redrawWipLimit, status;
      status = $scope.$eval($attrs.tgKanbanWipLimit);
      redrawWipLimit = (function(_this) {
        return function() {
          $el.find(".kanban-wip-limit").remove();
          return $timeout(function() {
            var element;
            element = $el.find("tg-card")[status.wip_limit];
            if (element) {
              return angular.element(element).before("<div class='kanban-wip-limit'></div>");
            }
          });
        };
      })(this);
      if (status && !status.is_archived) {
        $scope.$on("redraw:wip", redrawWipLimit);
        $scope.$on("kanban:us:move", redrawWipLimit);
        $scope.$on("usform:new:success", redrawWipLimit);
        $scope.$on("usform:bulk:success", redrawWipLimit);
      }
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgKanbanWipLimit", ["$timeout", KanbanWipLimitDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/kanban/sortable.coffee
 */

(function() {
  var KanbanSortableDirective, bindOnce, groupBy, mixOf, module, scopeDefer, taiga, timeout, toggleText;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  toggleText = this.taiga.toggleText;

  scopeDefer = this.taiga.scopeDefer;

  bindOnce = this.taiga.bindOnce;

  groupBy = this.taiga.groupBy;

  timeout = this.taiga.timeout;

  module = angular.module("taigaKanban");

  KanbanSortableDirective = function($repo, $rs, $rootscope) {
    var link;
    link = function($scope, $el, $attrs) {
      var unwatch;
      return unwatch = $scope.$watch("usByStatus", function(usByStatus) {
        var containers, deleteElement, drake, itemEl, newParentScope, scroll, tdom;
        if (!usByStatus || !usByStatus.size) {
          return;
        }
        unwatch();
        if (!($scope.project.my_permissions.indexOf("modify_us") > -1)) {
          return;
        }
        newParentScope = null;
        itemEl = null;
        tdom = $el;
        deleteElement = function(itemEl) {
          itemEl.scope().$destroy();
          itemEl.off();
          return itemEl.remove();
        };
        containers = _.map($el.find('.taskboard-column'), function(item) {
          return item;
        });
        drake = dragula(containers, {
          copySortSource: false,
          copy: false,
          moves: function(item) {
            return $(item).is('tg-card');
          }
        });
        drake.on('drag', function(item) {
          return window.dragMultiple.start(item, containers);
        });
        drake.on('cloned', function(item, dropTarget) {
          return $(item).addClass('multiple-drag-mirror');
        });
        drake.on('dragend', function(item) {
          var dragMultipleItems, finalUsList, firstElement, index, newStatus, newStatusId, parentEl, usList;
          parentEl = $(item).parent();
          newParentScope = parentEl.scope();
          newStatusId = newParentScope.s.id;
          dragMultipleItems = window.dragMultiple.stop();
          if (!dragMultipleItems.length) {
            dragMultipleItems = [item];
          }
          firstElement = dragMultipleItems[0];
          index = $(parentEl).find('tg-card').index(firstElement);
          newStatus = newParentScope.s.id;
          usList = _.map(dragMultipleItems, function(item) {
            return $(item).scope().us;
          });
          finalUsList = _.map(usList, function(item) {
            return {
              id: item.get('id'),
              oldStatusId: item.getIn(['model', 'status'])
            };
          });
          return $scope.$apply(function() {
            _.each(usList, (function(_this) {
              return function(item, key) {
                var oldStatus, sameContainer;
                oldStatus = item.getIn(['model', 'status']);
                sameContainer = newStatus === oldStatus;
                if (!sameContainer) {
                  itemEl = $(dragMultipleItems[key]);
                  return deleteElement(itemEl);
                }
              };
            })(this));
            return $rootscope.$broadcast("kanban:us:move", finalUsList, newStatus, index);
          });
        });
        scroll = autoScroll(containers, {
          margin: 100,
          pixels: 30,
          scrollWhenOutside: true,
          autoScroll: function() {
            return this.down && drake.dragging;
          }
        });
        return $scope.$on("$destroy", function() {
          $el.off();
          return drake.destroy();
        });
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgKanbanSortable", ["$tgRepo", "$tgResources", "$rootScope", KanbanSortableDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/epics/detail.coffee
 */

(function() {
  var EpicDetailController, EpicStatusButtonDirective, EpicStatusDisplayDirective, bindMethods, bindOnce, groupBy, joinStr, mixOf, module, taiga, toString,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  toString = this.taiga.toString;

  joinStr = this.taiga.joinStr;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  bindMethods = this.taiga.bindMethods;

  module = angular.module("taigaEpics");

  EpicDetailController = (function(superClass) {
    extend(EpicDetailController, superClass);

    EpicDetailController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "tgResources", "$routeParams", "$q", "$tgLocation", "$log", "tgAppMetaService", "$tgAnalytics", "$tgNavUrls", "$translate", "$tgQueueModelTransformation", "tgErrorHandlingService", "tgProjectService"];

    function EpicDetailController(scope, rootscope, repo, confirm, rs, rs2, params, q, location, log, appMetaService, analytics, navUrls, translate, modelTransform, errorHandlingService, projectService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.rs2 = rs2;
      this.params = params;
      this.q = q;
      this.location = location;
      this.log = log;
      this.appMetaService = appMetaService;
      this.analytics = analytics;
      this.navUrls = navUrls;
      this.translate = translate;
      this.modelTransform = modelTransform;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService;
      bindMethods(this);
      this.scope.epicRef = this.params.epicref;
      this.scope.sectionName = this.translate.instant("EPIC.SECTION_NAME");
      this.initializeEventHandlers();
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          _this._setMeta();
          return _this.initializeOnDeleteGoToUrl();
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    EpicDetailController.prototype._setMeta = function() {
      var description, ref, title;
      title = this.translate.instant("EPIC.PAGE_TITLE", {
        epicRef: "#" + this.scope.epic.ref,
        epicSubject: this.scope.epic.subject,
        projectName: this.scope.project.name
      });
      description = this.translate.instant("EPIC.PAGE_DESCRIPTION", {
        epicStatus: ((ref = this.scope.statusById[this.scope.epic.status]) != null ? ref.name : void 0) || "--",
        epicDescription: angular.element(this.scope.epic.description_html || "").text()
      });
      return this.appMetaService.setAll(title, description);
    };

    EpicDetailController.prototype.initializeEventHandlers = function() {
      this.scope.$on("attachment:create", (function(_this) {
        return function() {
          return _this.analytics.trackEvent("attachment", "create", "create attachment on epic", 1);
        };
      })(this));
      this.scope.$on("comment:new", (function(_this) {
        return function() {
          return _this.loadEpic();
        };
      })(this));
      return this.scope.$on("custom-attributes-values:edit", (function(_this) {
        return function() {
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this));
    };

    EpicDetailController.prototype.initializeOnDeleteGoToUrl = function() {
      var ctx;
      ctx = {
        project: this.scope.project.slug
      };
      return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project-epics", ctx);
    };

    EpicDetailController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.immutableProject = this.projectService.project;
      this.scope.$emit('project:loaded', project);
      this.scope.statusList = project.epic_statuses;
      this.scope.statusById = groupBy(project.epic_statuses, function(x) {
        return x.id;
      });
      return project;
    };

    EpicDetailController.prototype.loadEpic = function() {
      return this.rs.epics.getByRef(this.scope.projectId, this.params.epicref).then((function(_this) {
        return function(epic) {
          var ctx, ref, ref1;
          _this.scope.epic = epic;
          _this.scope.immutableEpic = Immutable.fromJS(epic._attrs);
          _this.scope.epicId = epic.id;
          _this.scope.commentModel = epic;
          _this.modelTransform.setObject(_this.scope, 'epic');
          if (((ref = _this.scope.epic.neighbors.previous) != null ? ref.ref : void 0) != null) {
            ctx = {
              project: _this.scope.project.slug,
              ref: _this.scope.epic.neighbors.previous.ref
            };
            _this.scope.previousUrl = _this.navUrls.resolve("project-epics-detail", ctx);
          }
          if (((ref1 = _this.scope.epic.neighbors.next) != null ? ref1.ref : void 0) != null) {
            ctx = {
              project: _this.scope.project.slug,
              ref: _this.scope.epic.neighbors.next.ref
            };
            return _this.scope.nextUrl = _this.navUrls.resolve("project-epics-detail", ctx);
          }
        };
      })(this));
    };

    EpicDetailController.prototype.loadUserstories = function() {
      return this.rs2.userstories.listInEpic(this.scope.epicId).then((function(_this) {
        return function(data) {
          return _this.scope.userstories = data;
        };
      })(this));
    };

    EpicDetailController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      return this.loadEpic().then((function(_this) {
        return function() {
          return _this.loadUserstories();
        };
      })(this));
    };


    /*
     * Note: This methods (onUpvote() and onDownvote()) are related to tg-vote-button.
     *       See app/modules/components/vote-button for more info
     */

    EpicDetailController.prototype.onUpvote = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadEpic();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.epics.upvote(this.scope.epicId).then(onSuccess, onError);
    };

    EpicDetailController.prototype.onDownvote = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadEpic();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.epics.downvote(this.scope.epicId).then(onSuccess, onError);
    };


    /*
     * Note: This methods (onWatch() and onUnwatch()) are related to tg-watch-button.
     *       See app/modules/components/watch-button for more info
     */

    EpicDetailController.prototype.onWatch = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadEpic();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.epics.watch(this.scope.epicId).then(onSuccess, onError);
    };

    EpicDetailController.prototype.onUnwatch = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadEpic();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.epics.unwatch(this.scope.epicId).then(onSuccess, onError);
    };

    EpicDetailController.prototype.onSelectColor = function(color) {
      var onSelectColorError, onSelectColorSuccess, transform;
      onSelectColorSuccess = (function(_this) {
        return function() {
          _this.rootscope.$broadcast("object:updated");
          return _this.confirm.notify('success');
        };
      })(this);
      onSelectColorError = (function(_this) {
        return function() {
          return _this.confirm.notify('error');
        };
      })(this);
      transform = this.modelTransform.save(function(epic) {
        epic.color = color;
        return epic;
      });
      return transform.then(onSelectColorSuccess, onSelectColorError);
    };

    return EpicDetailController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("EpicDetailController", EpicDetailController);

  EpicStatusDisplayDirective = function($template, $compile) {
    var link, template;
    template = $template.get("common/components/status-display.html", true);
    link = function($scope, $el, $attrs) {
      var render;
      render = function(epic) {
        var html, status;
        status = $scope.statusById[epic.status];
        html = template({
          is_closed: status.is_closed,
          status: status
        });
        html = $compile(html)($scope);
        return $el.html(html);
      };
      $scope.$watch($attrs.ngModel, function(epic) {
        if (epic != null) {
          return render(epic);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgEpicStatusDisplay", ["$tgTemplate", "$compile", EpicStatusDisplayDirective]);

  EpicStatusButtonDirective = function($rootScope, $repo, $confirm, $loading, $modelTransform, $compile, $translate, $template) {
    var link, template;
    template = $template.get("common/components/status-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var isEditable, render, save;
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_epic") !== -1;
      };
      render = (function(_this) {
        return function(epic) {
          var html, status;
          status = $scope.statusById[epic.status];
          html = $compile(template({
            status: status,
            statuses: $scope.statusList,
            editable: isEditable()
          }))($scope);
          return $el.html(html);
        };
      })(this);
      save = function(status) {
        var currentLoading, onError, onSuccess, transform;
        currentLoading = $loading().target($el).start();
        transform = $modelTransform.save(function(epic) {
          epic.status = status;
          return epic;
        });
        onSuccess = function() {
          $rootScope.$broadcast("object:updated");
          return currentLoading.finish();
        };
        onError = function() {
          $confirm.notify("error");
          return currentLoading.finish();
        };
        return transform.then(onSuccess, onError);
      };
      $el.on("click", ".js-edit-status", function(event) {
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        return $el.find(".pop-status").popover().open();
      });
      $el.on("click", ".status", function(event) {
        var target;
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        target = angular.element(event.currentTarget);
        $.fn.popover().closeAll();
        return save(target.data("status-id"));
      });
      $scope.$watch(function() {
        var ref;
        return (ref = $model.$modelValue) != null ? ref.status : void 0;
      }, function() {
        var epic;
        epic = $model.$modelValue;
        if (epic) {
          return render(epic);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgEpicStatusButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$compile", "$translate", "$tgTemplate", EpicStatusButtonDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/issues/detail.coffee
 */

(function() {
  var AssignSprintToIssueButtonDirective, IssueDetailController, IssuePriorityButtonDirective, IssueSeverityButtonDirective, IssueStatusButtonDirective, IssueStatusDisplayDirective, IssueTypeButtonDirective, bindMethods, bindOnce, groupBy, joinStr, mixOf, module, normalizeString, taiga, toString,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  toString = this.taiga.toString;

  joinStr = this.taiga.joinStr;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  bindMethods = this.taiga.bindMethods;

  normalizeString = this.taiga.normalizeString;

  module = angular.module("taigaIssues");

  IssueDetailController = (function(superClass) {
    extend(IssueDetailController, superClass);

    IssueDetailController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$log", "tgAppMetaService", "$tgAnalytics", "$tgNavUrls", "$translate", "$tgQueueModelTransformation", "tgErrorHandlingService", "tgProjectService"];

    function IssueDetailController(scope, rootscope, repo, confirm, rs, params, q, location, log, appMetaService, analytics, navUrls, translate, modelTransform, errorHandlingService, projectService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.log = log;
      this.appMetaService = appMetaService;
      this.analytics = analytics;
      this.navUrls = navUrls;
      this.translate = translate;
      this.modelTransform = modelTransform;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService;
      bindMethods(this);
      this.scope.issueRef = this.params.issueref;
      this.scope.sectionName = this.translate.instant("ISSUES.SECTION_NAME");
      this.initializeEventHandlers();
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          _this._setMeta();
          return _this.initializeOnDeleteGoToUrl();
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    IssueDetailController.prototype._setMeta = function() {
      var description, ref, ref1, ref2, ref3, title;
      title = this.translate.instant("ISSUE.PAGE_TITLE", {
        issueRef: "#" + this.scope.issue.ref,
        issueSubject: this.scope.issue.subject,
        projectName: this.scope.project.name
      });
      description = this.translate.instant("ISSUE.PAGE_DESCRIPTION", {
        issueStatus: ((ref = this.scope.statusById[this.scope.issue.status]) != null ? ref.name : void 0) || "--",
        issueType: ((ref1 = this.scope.typeById[this.scope.issue.type]) != null ? ref1.name : void 0) || "--",
        issueSeverity: ((ref2 = this.scope.severityById[this.scope.issue.severity]) != null ? ref2.name : void 0) || "--",
        issuePriority: ((ref3 = this.scope.priorityById[this.scope.issue.priority]) != null ? ref3.name : void 0) || "--",
        issueDescription: angular.element(this.scope.issue.description_html || "").text()
      });
      return this.appMetaService.setAll(title, description);
    };

    IssueDetailController.prototype.initializeEventHandlers = function() {
      this.scope.$on("attachment:create", (function(_this) {
        return function() {
          return _this.analytics.trackEvent("attachment", "create", "create attachment on issue", 1);
        };
      })(this));
      this.scope.$on("promote-issue-to-us:success", (function(_this) {
        return function() {
          _this.analytics.trackEvent("issue", "promoteToUserstory", "promote issue to userstory", 1);
          _this.rootscope.$broadcast("object:updated");
          return _this.loadIssue();
        };
      })(this));
      this.scope.$on("comment:new", (function(_this) {
        return function() {
          return _this.loadIssue();
        };
      })(this));
      this.scope.$on("custom-attributes-values:edit", (function(_this) {
        return function() {
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this));
      return this.scope.$on("assign-sprint-to-issue:success", (function(_this) {
        return function(ctx, milestoneId) {
          _this.scope.issue.milestone = milestoneId;
          _this.rootscope.$broadcast("object:updated");
          if (milestoneId) {
            return _this.loadSprint();
          } else {
            return _this.scope.sprint = null;
          }
        };
      })(this));
    };

    IssueDetailController.prototype.initializeOnDeleteGoToUrl = function() {
      var ctx;
      ctx = {
        project: this.scope.project.slug
      };
      if (this.scope.project.is_issues_activated) {
        return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project-issues", ctx);
      } else {
        return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project", ctx);
      }
    };

    IssueDetailController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      this.scope.statusList = project.issue_statuses;
      this.scope.statusById = groupBy(project.issue_statuses, function(x) {
        return x.id;
      });
      this.scope.typeById = groupBy(project.issue_types, function(x) {
        return x.id;
      });
      this.scope.typeList = _.sortBy(project.issue_types, "order");
      this.scope.severityList = project.severities;
      this.scope.severityById = groupBy(project.severities, function(x) {
        return x.id;
      });
      this.scope.priorityList = project.priorities;
      this.scope.priorityById = groupBy(project.priorities, function(x) {
        return x.id;
      });
      return project;
    };

    IssueDetailController.prototype.loadIssue = function() {
      return this.rs.issues.getByRef(this.scope.projectId, this.params.issueref).then((function(_this) {
        return function(issue) {
          var ctx, ref, ref1;
          _this.scope.issue = issue;
          _this.scope.issueId = issue.id;
          _this.scope.commentModel = issue;
          _this.modelTransform.setObject(_this.scope, 'issue');
          if (((ref = _this.scope.issue.neighbors.previous) != null ? ref.ref : void 0) != null) {
            ctx = {
              project: _this.scope.project.slug,
              ref: _this.scope.issue.neighbors.previous.ref
            };
            _this.scope.previousUrl = _this.navUrls.resolve("project-issues-detail", ctx);
          }
          if (((ref1 = _this.scope.issue.neighbors.next) != null ? ref1.ref : void 0) != null) {
            ctx = {
              project: _this.scope.project.slug,
              ref: _this.scope.issue.neighbors.next.ref
            };
            return _this.scope.nextUrl = _this.navUrls.resolve("project-issues-detail", ctx);
          }
        };
      })(this));
    };

    IssueDetailController.prototype.loadSprint = function() {
      if (this.scope.issue.milestone) {
        return this.rs.sprints.get(this.scope.issue.project, this.scope.issue.milestone).then((function(_this) {
          return function(sprint) {
            _this.scope.sprint = sprint;
            return sprint;
          };
        })(this));
      }
    };

    IssueDetailController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      return this.loadIssue().then((function(_this) {
        return function() {
          return _this.loadSprint();
        };
      })(this));
    };


    /*
     * Note: This methods (onUpvote() and onDownvote()) are related to tg-vote-button.
     *       See app/modules/components/vote-button for more info
     */

    IssueDetailController.prototype.onUpvote = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadIssue();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.issues.upvote(this.scope.issueId).then(onSuccess, onError);
    };

    IssueDetailController.prototype.onDownvote = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadIssue();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.issues.downvote(this.scope.issueId).then(onSuccess, onError);
    };


    /*
     * Note: This methods (onWatch() and onUnwatch()) are related to tg-watch-button.
     *       See app/modules/components/watch-button for more info
     */

    IssueDetailController.prototype.onWatch = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadIssue();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.issues.watch(this.scope.issueId).then(onSuccess, onError);
    };

    IssueDetailController.prototype.onUnwatch = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadIssue();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.issues.unwatch(this.scope.issueId).then(onSuccess, onError);
    };

    return IssueDetailController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("IssueDetailController", IssueDetailController);

  IssueStatusDisplayDirective = function($template, $compile) {
    var link, template;
    template = $template.get("common/components/status-display.html", true);
    link = function($scope, $el, $attrs) {
      var render;
      render = function(issue) {
        var html, status;
        status = $scope.statusById[issue.status];
        html = template({
          is_closed: status.is_closed,
          status: status
        });
        html = $compile(html)($scope);
        return $el.html(html);
      };
      $scope.$watch($attrs.ngModel, function(issue) {
        if (issue != null) {
          return render(issue);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgIssueStatusDisplay", ["$tgTemplate", "$compile", IssueStatusDisplayDirective]);

  IssueStatusButtonDirective = function($rootScope, $repo, $confirm, $loading, $modelTransform, $template, $compile) {
    var link, template;
    template = $template.get("common/components/status-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var isEditable, render, save;
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_issue") !== -1;
      };
      render = (function(_this) {
        return function(issue) {
          var html, status;
          status = $scope.statusById[issue.status];
          html = template({
            status: status,
            statuses: $scope.statusList,
            editable: isEditable()
          });
          html = $compile(html)($scope);
          return $el.html(html);
        };
      })(this);
      save = function(statusId) {
        var currentLoading, onError, onSuccess, transform;
        $.fn.popover().closeAll();
        currentLoading = $loading().target($el).start();
        transform = $modelTransform.save(function(issue) {
          issue.status = statusId;
          return issue;
        });
        onSuccess = function() {
          $rootScope.$broadcast("object:updated");
          return currentLoading.finish();
        };
        onError = function() {
          $confirm.notify("error");
          return currentLoading.finish();
        };
        return transform.then(onSuccess, onError);
      };
      $el.on("click", ".js-edit-status", function(event) {
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        return $el.find(".pop-status").popover().open();
      });
      $el.on("click", ".status", function(event) {
        var target;
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        target = angular.element(event.currentTarget);
        return save(target.data("status-id"));
      });
      $scope.$watch(function() {
        var ref;
        return (ref = $model.$modelValue) != null ? ref.status : void 0;
      }, function() {
        var issue;
        issue = $model.$modelValue;
        if (issue) {
          return render(issue);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgIssueStatusButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$compile", IssueStatusButtonDirective]);

  IssueTypeButtonDirective = function($rootScope, $repo, $confirm, $loading, $modelTransform, $template, $compile) {
    var link, template;
    template = $template.get("issue/issue-type-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var isEditable, notAutoSave, render, save;
      notAutoSave = $scope.$eval($attrs.notAutoSave);
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_issue") !== -1;
      };
      render = function(issue) {
        var html, type;
        type = $scope.typeById[issue.type];
        html = template({
          type: type,
          typees: $scope.typeList,
          editable: isEditable()
        });
        html = $compile(html)($scope);
        return $el.html(html);
      };
      save = function(type) {
        var currentLoading, onError, onSuccess, transform;
        $.fn.popover().closeAll();
        if (notAutoSave) {
          $model.$modelValue.type = type;
          $scope.$apply();
          return;
        }
        currentLoading = $loading().target($el.find(".level-name")).start();
        transform = $modelTransform.save(function(issue) {
          issue.type = type;
          return issue;
        });
        onSuccess = function() {
          $rootScope.$broadcast("object:updated");
          return currentLoading.finish();
        };
        onError = function() {
          $confirm.notify("error");
          return currentLoading.finish();
        };
        return transform.then(onSuccess, onError);
      };
      $el.on("click", ".type-data", function(event) {
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        return $el.find(".pop-type").popover().open();
      });
      $el.on("click", ".type", function(event) {
        var target, type;
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        target = angular.element(event.currentTarget);
        type = target.data("type-id");
        return save(type);
      });
      $scope.$watch(function() {
        var ref;
        return (ref = $model.$modelValue) != null ? ref.type : void 0;
      }, function() {
        var issue;
        issue = $model.$modelValue;
        if (issue) {
          return render(issue);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgIssueTypeButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$compile", IssueTypeButtonDirective]);

  IssueSeverityButtonDirective = function($rootScope, $repo, $confirm, $loading, $modelTransform, $template, $compile) {
    var link, template;
    template = $template.get("issue/issue-severity-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var isEditable, notAutoSave, render, save;
      notAutoSave = $scope.$eval($attrs.notAutoSave);
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_issue") !== -1;
      };
      render = function(issue) {
        var html, severity;
        severity = $scope.severityById[issue.severity];
        html = template({
          severity: severity,
          severityes: $scope.severityList,
          editable: isEditable()
        });
        html = $compile(html)($scope);
        return $el.html(html);
      };
      save = function(severity) {
        var currentLoading, onError, onSuccess, transform;
        $.fn.popover().closeAll();
        if (notAutoSave) {
          $model.$modelValue.severity = severity;
          $scope.$apply();
          return;
        }
        currentLoading = $loading().target($el.find(".level-name")).start();
        transform = $modelTransform.save(function(issue) {
          issue.severity = severity;
          return issue;
        });
        onSuccess = function() {
          $rootScope.$broadcast("object:updated");
          return currentLoading.finish();
        };
        onError = function() {
          $confirm.notify("error");
          return currentLoading.finish();
        };
        return transform.then(onSuccess, onError);
      };
      $el.on("click", ".severity-data", function(event) {
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        return $el.find(".pop-severity").popover().open();
      });
      $el.on("click", ".severity", function(event) {
        var severity, target;
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        target = angular.element(event.currentTarget);
        severity = target.data("severity-id");
        return save(severity);
      });
      $scope.$watch(function() {
        var ref;
        return (ref = $model.$modelValue) != null ? ref.severity : void 0;
      }, function() {
        var issue;
        issue = $model.$modelValue;
        if (issue) {
          return render(issue);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgIssueSeverityButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$compile", IssueSeverityButtonDirective]);

  IssuePriorityButtonDirective = function($rootScope, $repo, $confirm, $loading, $modelTransform, $template, $compile) {
    var link, template;
    template = $template.get("issue/issue-priority-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var isEditable, notAutoSave, render, save;
      notAutoSave = $scope.$eval($attrs.notAutoSave);
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_issue") !== -1;
      };
      render = function(issue) {
        var html, priority;
        priority = $scope.priorityById[issue.priority];
        html = template({
          priority: priority,
          priorityes: $scope.priorityList,
          editable: isEditable()
        });
        html = $compile(html)($scope);
        return $el.html(html);
      };
      save = function(priority) {
        var currentLoading, onError, onSuccess, transform;
        $.fn.popover().closeAll();
        if (notAutoSave) {
          $model.$modelValue.priority = priority;
          $scope.$apply();
          return;
        }
        currentLoading = $loading().target($el.find(".level-name")).start();
        transform = $modelTransform.save(function(issue) {
          issue.priority = priority;
          return issue;
        });
        onSuccess = function() {
          $rootScope.$broadcast("object:updated");
          return currentLoading.finish();
        };
        onError = function() {
          $confirm.notify("error");
          return currentLoading.finish();
        };
        return transform.then(onSuccess, onError);
      };
      $el.on("click", ".priority-data", function(event) {
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        return $el.find(".pop-priority").popover().open();
      });
      $el.on("click", ".priority", function(event) {
        var priority, target;
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        target = angular.element(event.currentTarget);
        priority = target.data("priority-id");
        return save(priority);
      });
      $scope.$watch(function() {
        var ref;
        return (ref = $model.$modelValue) != null ? ref.priority : void 0;
      }, function() {
        var issue;
        issue = $model.$modelValue;
        if (issue) {
          return render(issue);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgIssuePriorityButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$compile", IssuePriorityButtonDirective]);

  AssignSprintToIssueButtonDirective = function($rootscope, $rs, $repo, $loading, $translate, lightboxService, $modelTransform, $confirm) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var avaliableMilestones, existsMilestone, issue;
      avaliableMilestones = [];
      issue = null;
      $scope.$watch($attrs.ngModel, function(item) {
        if (!item) {
          return;
        }
        if (item.milestone) {
          $el.find('.assign-issue-button.button-unset').removeClass('is-active');
          return $el.find('.assign-issue-button.button-set').addClass('is-active');
        } else {
          $el.find('.assign-issue-button.button-set').removeClass('is-active');
          return $el.find('.assign-issue-button.button-unset').addClass('is-active');
        }
      });
      $el.on("click", ".assign-issue-button.button-unset", function(event) {
        var title;
        event.preventDefault();
        event.stopPropagation();
        title = $translate.instant("ISSUES.ACTION_ATTACH_SPRINT");
        issue = $model.$modelValue;
        return $rs.sprints.list($scope.projectId, null).then(function(data) {
          $scope.milestones = data.milestones;
          $scope.selectedSprint = issue.milestone;
          avaliableMilestones = angular.copy($scope.milestones);
          return lightboxService.open($el.find(".lightbox-assign-sprint-to-issue"));
        });
      });
      $el.on("click", ".assign-issue-button.button-set", function(event) {
        event.preventDefault();
        event.stopPropagation();
        issue = $model.$modelValue;
        return $rs.sprints.list($scope.projectId, null).then(function(data) {
          var currentSprint, message, title;
          currentSprint = _.find(data.milestones, {
            "id": issue.milestone
          });
          title = $translate.instant("ISSUES.CONFIRM_DETACH_FROM_SPRINT.TITLE");
          message = $translate.instant("ISSUES.CONFIRM_DETACH_FROM_SPRINT.MESSAGE", {
            sprintName: currentSprint.name
          });
          return $confirm.ask(title, null, message).then(function(askResponse) {
            var onError, onSuccess, transform;
            onSuccess = function() {
              $rootscope.$broadcast("assign-sprint-to-issue:success", null);
              askResponse.finish();
              return lightboxService.close($el);
            };
            onError = function() {
              askResponse.finish(false);
              return $confirm.notify("error");
            };
            transform = $modelTransform.save(function(issue) {
              issue.setAttr('milestone', null);
              return issue;
            });
            return transform.then(onSuccess, onError);
          });
        });
      });
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      existsMilestone = function(needle, haystack) {
        haystack = normalizeString(haystack.toUpperCase());
        needle = normalizeString(needle.toUpperCase());
        return _.includes(haystack, needle);
      };
      $scope.filterMilestones = function(filterText) {
        return $scope.milestones = avaliableMilestones.filter(function(milestone) {
          return existsMilestone(filterText, milestone.name);
        });
      };
      return $scope.saveIssueToSprint = function(selectedSprint, event) {
        var currentLoading, transform;
        currentLoading = $loading().target($(event.currentTarget)).start();
        issue.setAttr('milestone', selectedSprint.id);
        transform = $modelTransform.save(function(item) {
          issue.setAttr('milestone', selectedSprint.id);
          return item;
        });
        return transform.then(function() {
          currentLoading.finish();
          lightboxService.close($el.find(".lightbox-assign-sprint-to-issue"));
          return $rootscope.$broadcast("assign-sprint-to-issue:success", selectedSprint.id);
        });
      };
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel",
      templateUrl: "issue/assign-sprint-to-issue-button.html"
    };
  };

  module.directive("tgAssignSprintToIssueButton", ["$rootScope", "$tgResources", "$tgRepo", "$tgLoading", "$translate", "lightboxService", "$tgQueueModelTransformation", "$tgConfirm", AssignSprintToIssueButtonDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/issues/lightboxes.coffee
 */

(function() {
  var CreateBulkIssuesDirective, bindOnce, debounce, module, taiga, trim;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  trim = this.taiga.trim;

  module = angular.module("taigaIssues");

  CreateBulkIssuesDirective = function($repo, $rs, $confirm, $rootscope, $loading, lightboxService, $model) {
    var link;
    link = function($scope, $el, attrs) {
      var form, submit, submitButton;
      form = null;
      $scope.$on("issueform:bulk", function(ctx, projectId, milestoneId, status) {
        if (form) {
          form.reset();
        }
        lightboxService.open($el);
        return $scope["new"] = {
          projectId: projectId,
          milestoneId: milestoneId,
          bulk: ""
        };
      });
      submit = debounce(2000, function(event) {
        var currentLoading, data, milestoneId, projectId, promise;
        event.preventDefault();
        form = $el.find("form").checksley();
        if (!form.validate()) {
          return;
        }
        currentLoading = $loading().target(submitButton).start();
        data = $scope["new"].bulk;
        projectId = $scope["new"].projectId;
        milestoneId = $scope["new"].milestoneId;
        promise = $rs.issues.bulkCreate(projectId, milestoneId, data);
        promise.then(function(result) {
          result = _.map(result.data, function(x) {
            return $model.make_model('issues', x);
          });
          currentLoading.finish();
          $rootscope.$broadcast("issueform:new:success", result);
          lightboxService.close($el);
          return $confirm.notify("success");
        });
        return promise.then(null, function() {
          currentLoading.finish();
          return $confirm.notify("error");
        });
      });
      submitButton = $el.find(".submit-button");
      $el.on("submit", "form", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgLbCreateBulkIssues", ["$tgRepo", "$tgResources", "$tgConfirm", "$rootScope", "$tgLoading", "lightboxService", "$tgModel", CreateBulkIssuesDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/issues/list.coffee
 */

(function() {
  var IssueAssignedToInlineEditionDirective, IssueStatusInlineEditionDirective, IssuesController, IssuesDirective, bindMethods, bindOnce, debounceLeading, groupBy, joinStr, mixOf, module, startswith, taiga, toString, trim,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  trim = this.taiga.trim;

  toString = this.taiga.toString;

  joinStr = this.taiga.joinStr;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  debounceLeading = this.taiga.debounceLeading;

  startswith = this.taiga.startswith;

  bindMethods = this.taiga.bindMethods;

  debounceLeading = this.taiga.debounceLeading;

  module = angular.module("taigaIssues");

  IssuesController = (function(superClass) {
    extend(IssuesController, superClass);

    IssuesController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$tgUrls", "$routeParams", "$q", "$tgLocation", "tgAppMetaService", "$tgNavUrls", "$tgEvents", "$tgAnalytics", "$translate", "tgErrorHandlingService", "$tgStorage", "tgFilterRemoteStorageService", "tgProjectService", "tgUserActivityService"];

    IssuesController.prototype.filtersHashSuffix = "issues-filters";

    IssuesController.prototype.myFiltersHashSuffix = "issues-my-filters";

    IssuesController.prototype.excludePrefix = "exclude_";

    IssuesController.prototype.filterCategories = ["tags", "status", "type", "severity", "priority", "assigned_to", "owner", "role"];

    function IssuesController(scope, rootscope, repo, confirm, rs, urls, params1, q1, location, appMetaService, navUrls, events, analytics, translate, errorHandlingService, storage, filterRemoteStorageService, projectService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.urls = urls;
      this.params = params1;
      this.q = q1;
      this.location = location;
      this.appMetaService = appMetaService;
      this.navUrls = navUrls;
      this.events = events;
      this.analytics = analytics;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.storage = storage;
      this.filterRemoteStorageService = filterRemoteStorageService;
      this.projectService = projectService;
      this.loadIssues = bind(this.loadIssues, this);
      bindMethods(this);
      this.scope.sectionName = this.translate.instant("PROJECT.SECTION.ISSUES");
      this.voting = false;
      if (this.applyStoredFilters(this.params.pslug, this.filtersHashSuffix)) {
        return;
      }
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("ISSUES.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.translate.instant("ISSUES.PAGE_DESCRIPTION", {
            projectName: _this.scope.project.name,
            projectDescription: _this.scope.project.description
          });
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
      this.scope.$on("issueform:new:success", (function(_this) {
        return function() {
          _this.analytics.trackEvent("issue", "create", "create issue on issues list", 1);
          return _this.loadIssues();
        };
      })(this));
      this.scope.$on("assigned-to:changed", (function(_this) {
        return function() {
          _this.generateFilters();
          if (_this.isFilterDataTypeSelected('assigned_to') || _this.isFilterDataTypeSelected('role') || _this.isOrderedBy('assigned_to') || _this.isOrderedBy('modified')) {
            return _this.loadIssues();
          }
        };
      })(this));
      this.scope.$on("status:changed", (function(_this) {
        return function() {
          _this.generateFilters();
          if (_this.isFilterDataTypeSelected('status') || _this.isOrderedBy('status') || _this.isOrderedBy('modified')) {
            return _this.loadIssues();
          }
        };
      })(this));
    }

    IssuesController.prototype.isOrderedBy = function(fieldName) {
      var pattern;
      pattern = new RegExp("-*" + fieldName);
      return pattern.test(this.location.search().order_by);
    };

    IssuesController.prototype.changeQ = function(q) {
      this.unselectFilter("page");
      this.replaceFilter("q", q);
      this.loadIssues();
      return this.generateFilters();
    };

    IssuesController.prototype.removeFilter = function(filter) {
      this.unselectFilter("page");
      this.unselectFilter(filter.dataType, filter.id, false, filter.mode);
      this.loadIssues();
      return this.generateFilters();
    };

    IssuesController.prototype.addFilter = function(newFilter) {
      this.unselectFilter("page");
      this.selectFilter(newFilter.category.dataType, newFilter.filter.id, false, newFilter.mode);
      this.loadIssues();
      return this.generateFilters();
    };

    IssuesController.prototype.selectCustomFilter = function(customFilter) {
      var orderBy;
      orderBy = this.location.search().order_by;
      if (orderBy) {
        customFilter.filter.order_by = orderBy;
      }
      this.unselectFilter("page");
      this.replaceAllFilters(customFilter.filter);
      this.loadIssues();
      return this.generateFilters();
    };

    IssuesController.prototype.removeCustomFilter = function(customFilter) {
      return this.filterRemoteStorageService.getFilters(this.scope.projectId, this.myFiltersHashSuffix).then((function(_this) {
        return function(userFilters) {
          delete userFilters[customFilter.id];
          return _this.filterRemoteStorageService.storeFilters(_this.scope.projectId, userFilters, _this.myFiltersHashSuffix).then(_this.generateFilters);
        };
      })(this));
    };

    IssuesController.prototype.isFilterDataTypeSelected = function(filterDataType) {
      var filter, j, len, ref;
      ref = this.selectedFilters;
      for (j = 0, len = ref.length; j < len; j++) {
        filter = ref[j];
        if (filter['dataType'] === filterDataType) {
          return true;
        }
      }
      return false;
    };

    IssuesController.prototype.saveCustomFilter = function(name) {
      var excludeKey, filters, j, key, len, ref, urlfilters;
      filters = {};
      urlfilters = this.location.search();
      ref = this.filterCategories;
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        excludeKey = this.excludePrefix.concat(key);
        filters[key] = urlfilters[key];
        filters[excludeKey] = urlfilters[excludeKey];
      }
      return this.filterRemoteStorageService.getFilters(this.scope.projectId, this.myFiltersHashSuffix).then((function(_this) {
        return function(userFilters) {
          userFilters[name] = filters;
          return _this.filterRemoteStorageService.storeFilters(_this.scope.projectId, userFilters, _this.myFiltersHashSuffix).then(_this.generateFilters);
        };
      })(this));
    };

    IssuesController.prototype.generateFilters = function() {
      var excludeKey, j, key, len, loadFilters, ref, urlfilters;
      this.storeFilters(this.params.pslug, this.location.search(), this.filtersHashSuffix);
      urlfilters = this.location.search();
      loadFilters = {};
      loadFilters.project = this.scope.projectId;
      loadFilters.q = urlfilters.q;
      ref = this.filterCategories;
      for (j = 0, len = ref.length; j < len; j++) {
        key = ref[j];
        excludeKey = this.excludePrefix.concat(key);
        loadFilters[key] = urlfilters[key];
        loadFilters[excludeKey] = urlfilters[excludeKey];
      }
      return this.q.all([this.rs.issues.filtersData(loadFilters), this.filterRemoteStorageService.getFilters(this.scope.projectId, this.myFiltersHashSuffix)]).then((function(_this) {
        return function(result) {
          var customFiltersRaw, data, dataCollection, k, len1, ref1, selected, tagsWithAtLeastOneElement;
          data = result[0];
          customFiltersRaw = result[1];
          dataCollection = {};
          dataCollection.status = _.map(data.statuses, function(it) {
            it.id = it.id.toString();
            return it;
          });
          dataCollection.type = _.map(data.types, function(it) {
            it.id = it.id.toString();
            return it;
          });
          dataCollection.severity = _.map(data.severities, function(it) {
            it.id = it.id.toString();
            return it;
          });
          dataCollection.priority = _.map(data.priorities, function(it) {
            it.id = it.id.toString();
            return it;
          });
          dataCollection.tags = _.map(data.tags, function(it) {
            it.id = it.name;
            return it;
          });
          tagsWithAtLeastOneElement = _.filter(dataCollection.tags, function(tag) {
            return tag.count > 0;
          });
          dataCollection.assigned_to = _.map(data.assigned_to, function(it) {
            if (it.id) {
              it.id = it.id.toString();
            } else {
              it.id = "null";
            }
            it.name = it.full_name || "Unassigned";
            return it;
          });
          dataCollection.owner = _.map(data.owners, function(it) {
            it.id = it.id.toString();
            it.name = it.full_name;
            return it;
          });
          dataCollection.role = _.map(data.roles, function(it) {
            if (it.id) {
              it.id = it.id.toString();
            } else {
              it.id = "null";
            }
            it.name = it.name || "Unassigned";
            return it;
          });
          _this.selectedFilters = [];
          ref1 = _this.filterCategories;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            key = ref1[k];
            excludeKey = _this.excludePrefix.concat(key);
            if (loadFilters[key]) {
              selected = _this.formatSelectedFilters(key, dataCollection[key], loadFilters[key]);
              _this.selectedFilters = _this.selectedFilters.concat(selected);
            }
            if (loadFilters[excludeKey]) {
              selected = _this.formatSelectedFilters(key, dataCollection[key], loadFilters[excludeKey], "exclude");
              _this.selectedFilters = _this.selectedFilters.concat(selected);
            }
          }
          _this.filterQ = loadFilters.q;
          _this.filters = [
            {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.TYPE"),
              dataType: "type",
              content: dataCollection.type
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.SEVERITY"),
              dataType: "severity",
              content: dataCollection.severity
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.PRIORITIES"),
              dataType: "priority",
              content: dataCollection.priority
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.STATUS"),
              dataType: "status",
              content: dataCollection.status
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.TAGS"),
              dataType: "tags",
              content: dataCollection.tags,
              hideEmpty: true,
              totalTaggedElements: tagsWithAtLeastOneElement.length
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.ASSIGNED_TO"),
              dataType: "assigned_to",
              content: dataCollection.assigned_to
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.ROLE"),
              dataType: "role",
              content: dataCollection.role
            }, {
              title: _this.translate.instant("COMMON.FILTERS.CATEGORIES.CREATED_BY"),
              dataType: "owner",
              content: dataCollection.owner
            }
          ];
          _this.customFilters = [];
          return _.forOwn(customFiltersRaw, function(value, key) {
            return _this.customFilters.push({
              id: key,
              name: key,
              filter: value
            });
          });
        };
      })(this));
    };

    IssuesController.prototype.initializeSubscription = function() {
      var routingKey;
      routingKey = "changes.project." + this.scope.projectId + ".issues";
      return this.events.subscribe(this.scope, routingKey, debounceLeading(500, (function(_this) {
        return function(message) {
          return _this.loadIssues();
        };
      })(this)));
    };

    IssuesController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      if (!project.is_issues_activated) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      this.scope.issueStatusById = groupBy(project.issue_statuses, function(x) {
        return x.id;
      });
      this.scope.issueStatusList = _.sortBy(project.issue_statuses, "order");
      this.scope.severityById = groupBy(project.severities, function(x) {
        return x.id;
      });
      this.scope.severityList = _.sortBy(project.severities, "order");
      this.scope.priorityById = groupBy(project.priorities, function(x) {
        return x.id;
      });
      this.scope.priorityList = _.sortBy(project.priorities, "order");
      this.scope.issueTypes = _.sortBy(project.issue_types, "order");
      this.scope.issueTypeById = groupBy(project.issue_types, function(x) {
        return x.id;
      });
      return project;
    };

    IssuesController.prototype.loadIssuesRequests = 0;

    IssuesController.prototype.loadIssues = function() {
      var params, promise;
      params = this.location.search();
      promise = this.rs.issues.list(this.scope.projectId, params);
      this.loadIssuesRequests += 1;
      promise.index = this.loadIssuesRequests;
      promise.then((function(_this) {
        return function(data) {
          if (promise.index === _this.loadIssuesRequests) {
            _this.scope.issues = data.models;
            _this.scope.page = data.current;
            _this.scope.count = data.count;
            _this.scope.paginatedBy = data.paginatedBy;
          }
          return data;
        };
      })(this));
      return promise;
    };

    IssuesController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      this.initializeSubscription();
      this.generateFilters();
      return this.loadIssues();
    };

    IssuesController.prototype.addNewIssue = function() {
      var project;
      project = this.projectService.project.toJS();
      return this.rootscope.$broadcast("genericform:new", {
        'objType': 'issue',
        'project': project
      });
    };

    IssuesController.prototype.addIssuesInBulk = function() {
      return this.rootscope.$broadcast("issueform:bulk", this.scope.projectId);
    };

    IssuesController.prototype.upVoteIssue = function(issueId) {
      var onError, onSuccess;
      this.voting = issueId;
      onSuccess = (function(_this) {
        return function() {
          _this.loadIssues();
          return _this.voting = null;
        };
      })(this);
      onError = (function(_this) {
        return function() {
          _this.confirm.notify("error");
          return _this.voting = null;
        };
      })(this);
      return this.rs.issues.upvote(issueId).then(onSuccess, onError);
    };

    IssuesController.prototype.downVoteIssue = function(issueId) {
      var onError, onSuccess;
      this.voting = issueId;
      onSuccess = (function(_this) {
        return function() {
          _this.loadIssues();
          return _this.voting = null;
        };
      })(this);
      onError = (function(_this) {
        return function() {
          _this.confirm.notify("error");
          return _this.voting = null;
        };
      })(this);
      return this.rs.issues.downvote(issueId).then(onSuccess, onError);
    };

    IssuesController.prototype.getOrderBy = function() {
      if (_.isString(this.location.search().order_by)) {
        return this.location.search().order_by;
      } else {
        return "created_date";
      }
    };

    return IssuesController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  module.controller("IssuesController", IssuesController);

  IssuesDirective = function($log, $location, $template, $compile) {
    var link, linkOrdering, linkPagination, template;
    template = $template.get("issue/issue-paginator.html", true);
    linkPagination = function($scope, $el, $attrs, $ctrl) {
      var $pagEl, afterCurrent, atBegin, atEnd, beforeCurrent, getNumPages, renderPagination;
      afterCurrent = 2;
      beforeCurrent = 4;
      atBegin = 2;
      atEnd = 2;
      $pagEl = $el.find(".issues-paginator");
      getNumPages = function() {
        var numPages;
        numPages = $scope.count / $scope.paginatedBy;
        if (parseInt(numPages, 10) < numPages) {
          numPages = parseInt(numPages, 10) + 1;
        } else {
          numPages = parseInt(numPages, 10);
        }
        return numPages;
      };
      renderPagination = function() {
        var cpage, html, i, j, numPages, options, pages, ref;
        numPages = getNumPages();
        if (numPages <= 1) {
          $pagEl.hide();
          return;
        }
        $pagEl.show();
        pages = [];
        options = {};
        options.pages = pages;
        options.showPrevious = $scope.page > 1;
        options.showNext = !($scope.page === numPages);
        cpage = $scope.page;
        for (i = j = 1, ref = numPages; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          if (i === (cpage + afterCurrent) && numPages > (cpage + afterCurrent + atEnd)) {
            pages.push({
              classes: "dots",
              type: "dots"
            });
          } else if (i === (cpage - beforeCurrent) && cpage > (atBegin + beforeCurrent)) {
            pages.push({
              classes: "dots",
              type: "dots"
            });
          } else if (i > (cpage + afterCurrent) && i <= (numPages - atEnd)) {

          } else if (i < (cpage - beforeCurrent) && i > atBegin) {

          } else if (i === cpage) {
            pages.push({
              classes: "active",
              num: i,
              type: "page-active"
            });
          } else {
            pages.push({
              classes: "page",
              num: i,
              type: "page"
            });
          }
        }
        html = template(options);
        html = $compile(html)($scope);
        return $pagEl.html(html);
      };
      $scope.$watch("issues", function(value) {
        if (!value) {
          return;
        }
        return renderPagination();
      });
      $el.on("click", ".issues-paginator a.next", function(event) {
        event.preventDefault();
        return $scope.$apply(function() {
          $ctrl.selectFilter("page", $scope.page + 1);
          return $ctrl.loadIssues();
        });
      });
      $el.on("click", ".issues-paginator a.previous", function(event) {
        event.preventDefault();
        return $scope.$apply(function() {
          $ctrl.selectFilter("page", $scope.page - 1);
          return $ctrl.loadIssues();
        });
      });
      return $el.on("click", ".issues-paginator li.page > a", function(event) {
        var pagenum, target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        pagenum = target.data("pagenum");
        return $scope.$apply(function() {
          $ctrl.selectFilter("page", pagenum);
          return $ctrl.loadIssues();
        });
      });
    };
    linkOrdering = function($scope, $el, $attrs, $ctrl) {
      var colHeadElement, currentOrder, icon, svg;
      currentOrder = $ctrl.getOrderBy();
      if (currentOrder) {
        icon = startswith(currentOrder, "-") ? "icon-arrow-up" : "icon-arrow-down";
        colHeadElement = $el.find(".row.title > div[data-fieldname='" + (trim(currentOrder, "-")) + "']");
        svg = $("<tg-svg>").attr("svg-icon", icon);
        colHeadElement.append(svg);
        $compile(colHeadElement.contents())($scope);
      }
      return $el.on("click", ".row.title > div", function(event) {
        var finalOrder, newOrder, target;
        target = angular.element(event.currentTarget);
        currentOrder = $ctrl.getOrderBy();
        newOrder = target.data("fieldname");
        if (newOrder === 'total_voters' && currentOrder !== "-total_voters") {
          currentOrder = "total_voters";
        }
        finalOrder = currentOrder === newOrder ? "-" + newOrder : newOrder;
        return $scope.$apply(function() {
          $ctrl.replaceFilter("order_by", finalOrder);
          $ctrl.storeFilters($ctrl.params.pslug, $location.search(), $ctrl.filtersHashSuffix);
          return $ctrl.loadIssues().then(function() {
            $el.find(".row.title > div > tg-svg").remove();
            icon = startswith(finalOrder, "-") ? "icon-arrow-up" : "icon-arrow-down";
            svg = $("<tg-svg>").attr("svg-icon", icon);
            target.append(svg);
            return $compile(target.contents())($scope);
          });
        });
      });
    };
    link = function($scope, $el, $attrs) {
      var $ctrl;
      $ctrl = $el.controller();
      linkOrdering($scope, $el, $attrs, $ctrl);
      linkPagination($scope, $el, $attrs, $ctrl);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgIssues", ["$log", "$tgLocation", "$tgTemplate", "$compile", IssuesDirective]);

  IssueStatusInlineEditionDirective = function($repo, $template, $rootscope) {

    /*
    Print the status of an Issue and a popover to change it.
    - tg-issue-status-inline-edition: The issue
    
    Example:
    
      div.status(tg-issue-status-inline-edition="issue")
        a.issue-status(href="")
    
    NOTE: This directive need 'issueStatusById' and 'project'.
     */
    var link, selectionTemplate, updateIssueStatus;
    selectionTemplate = $template.get("issue/issue-status-inline-edition-selection.html", true);
    updateIssueStatus = function($el, issue, issueStatusById) {
      var issueStatusDom, issueStatusDomParent, status;
      issueStatusDomParent = $el.find(".issue-status");
      issueStatusDom = $el.find(".issue-status .issue-status-bind");
      status = issueStatusById[issue.status];
      if (status) {
        issueStatusDom.text(status.name);
        issueStatusDom.prop("title", status.name);
        return issueStatusDomParent.css('color', status.color);
      }
    };
    link = function($scope, $el, $attrs) {
      var $ctrl, issue;
      $ctrl = $el.controller();
      issue = $scope.$eval($attrs.tgIssueStatusInlineEdition);
      $el.on("click", ".issue-status", function(event) {
        event.preventDefault();
        event.stopPropagation();
        return $el.find(".pop-status").popover().open();
      });
      $el.on("click", ".status", function(event) {
        var target;
        event.preventDefault();
        event.stopPropagation();
        target = angular.element(event.currentTarget);
        issue.status = target.data("status-id");
        $el.find(".pop-status").popover().close();
        updateIssueStatus($el, issue, $scope.issueStatusById);
        return $scope.$apply(function() {
          return $repo.save(issue).then(function(response) {
            return $rootscope.$broadcast("status:changed", response);
          });
        });
      });
      taiga.bindOnce($scope, "project", function(project) {
        $el.append(selectionTemplate({
          'statuses': project.issue_statuses
        }));
        updateIssueStatus($el, issue, $scope.issueStatusById);
        if (project.my_permissions.indexOf("modify_issue") === -1) {
          $el.unbind("click");
          return $el.find("a").addClass("not-clickable");
        }
      });
      $scope.$watch($attrs.tgIssueStatusInlineEdition, (function(_this) {
        return function(val) {
          return updateIssueStatus($el, val, $scope.issueStatusById);
        };
      })(this));
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgIssueStatusInlineEdition", ["$tgRepo", "$tgTemplate", "$rootScope", IssueStatusInlineEditionDirective]);

  IssueAssignedToInlineEditionDirective = function($repo, $rootscope, $translate, avatarService, $lightboxFactory) {
    var link, template;
    template = _.template("<img style=\"background-color: <%- bg %>\" src=\"<%- imgurl %>\" alt=\"<%- name %>\"/>\n<figcaption><%- name %></figcaption>");
    link = function($scope, $el, $attrs) {
      var $ctrl, issue, updateIssue;
      updateIssue = function(issue) {
        var avatar, ctx, member;
        ctx = {
          name: $translate.instant("COMMON.ASSIGNED_TO.NOT_ASSIGNED"),
          imgurl: "/" + window._version + "/images/unnamed.png"
        };
        member = $scope.usersById[issue.assigned_to];
        avatar = avatarService.getAvatar(member);
        ctx.imgurl = avatar.url;
        ctx.bg = null;
        if (member) {
          ctx.name = member.full_name_display;
          ctx.bg = avatar.bg;
        }
        $el.find(".avatar").html(template(ctx));
        return $el.find(".issue-assignedto").attr('title', ctx.name);
      };
      $ctrl = $el.controller();
      issue = $scope.$eval($attrs.tgIssueAssignedToInlineEdition);
      updateIssue(issue);
      $el.on("click", ".issue-assignedto", function(event) {
        var onClose;
        onClose = (function(_this) {
          return function(assignedUsers) {
            issue.assigned_to = assignedUsers.pop() || null;
            return $repo.save(issue).then(function() {
              updateIssue(issue);
              return $rootscope.$broadcast("assigned-to:changed", issue);
            });
          };
        })(this);
        return $lightboxFactory.create('tg-lb-select-user', {
          "class": "lightbox lightbox-select-user"
        }, {
          "currentUsers": [issue.assigned_to],
          "activeUsers": $scope.activeUsers,
          "onClose": onClose,
          "single": true,
          "lbTitle": $translate.instant("COMMON.ASSIGNED_USERS.ADD")
        });
      });
      taiga.bindOnce($scope, "project", function(project) {
        if (project.my_permissions.indexOf("modify_issue") === -1) {
          $el.unbind("click");
          return $el.find("a").addClass("not-clickable");
        }
      });
      $scope.$watch($attrs.tgIssueAssignedToInlineEdition, function(val) {
        return updateIssue(val);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgIssueAssignedToInlineEdition", ["$tgRepo", "$rootScope", "$translate", "tgAvatarService", "tgLightboxFactory", IssueAssignedToInlineEditionDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/userstories/detail.coffee
 */

(function() {
  var UsClientRequirementButtonDirective, UsStatusButtonDirective, UsStatusDisplayDirective, UsTeamRequirementButtonDirective, UserStoryDetailController, bindMethods, bindOnce, groupBy, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  bindMethods = this.taiga.bindMethods;

  module = angular.module("taigaUserStories");

  UserStoryDetailController = (function(superClass) {
    extend(UserStoryDetailController, superClass);

    UserStoryDetailController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$log", "tgAppMetaService", "$tgNavUrls", "$tgAnalytics", "$translate", "$tgQueueModelTransformation", "tgErrorHandlingService", "$tgConfig", "tgProjectService", "tgWysiwygService"];

    function UserStoryDetailController(scope, rootscope, repo, confirm, rs, params, q, location, log, appMetaService, navUrls, analytics, translate, modelTransform, errorHandlingService, configService, projectService, wysiwigService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.log = log;
      this.appMetaService = appMetaService;
      this.navUrls = navUrls;
      this.analytics = analytics;
      this.translate = translate;
      this.modelTransform = modelTransform;
      this.errorHandlingService = errorHandlingService;
      this.configService = configService;
      this.projectService = projectService;
      this.wysiwigService = wysiwigService;
      bindMethods(this);
      this.scope.usRef = this.params.usref;
      this.scope.sectionName = this.translate.instant("US.SECTION_NAME");
      this.scope.tribeEnabled = this.configService.config.tribeHost;
      this.initializeEventHandlers();
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          _this._setMeta();
          return _this.initializeOnDeleteGoToUrl();
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    UserStoryDetailController.prototype._setMeta = function() {
      var closedTasks, description, progressPercentage, ref, title, totalTasks;
      totalTasks = this.scope.tasks.length;
      closedTasks = _.filter(this.scope.tasks, (function(_this) {
        return function(t) {
          return _this.scope.taskStatusById[t.status].is_closed;
        };
      })(this)).length;
      progressPercentage = totalTasks > 0 ? Math.round(100 * closedTasks / totalTasks) : 0;
      title = this.translate.instant("US.PAGE_TITLE", {
        userStoryRef: "#" + this.scope.us.ref,
        userStorySubject: this.scope.us.subject,
        projectName: this.scope.project.name
      });
      description = this.translate.instant("US.PAGE_DESCRIPTION", {
        userStoryStatus: ((ref = this.scope.statusById[this.scope.us.status]) != null ? ref.name : void 0) || "--",
        userStoryPoints: this.scope.us.total_points,
        userStoryDescription: angular.element(this.wysiwigService.getHTML(this.scope.us.description) || "").text(),
        userStoryClosedTasks: closedTasks,
        userStoryTotalTasks: totalTasks,
        userStoryProgressPercentage: progressPercentage
      });
      return this.appMetaService.setAll(title, description);
    };

    UserStoryDetailController.prototype.initializeEventHandlers = function() {
      this.scope.relateToEpic = (function(_this) {
        return function(us) {
          return _this.scope.$broadcast("relate-to-epic:add", us);
        };
      })(this);
      this.scope.$on("related-tasks:update", (function(_this) {
        return function() {
          var allClosed;
          _this.loadTasks();
          _this.scope.tasks = _.clone(_this.scope.tasks, false);
          allClosed = _.every(_this.scope.tasks, function(task) {
            return task.is_closed;
          });
          if (_this.scope.us.is_closed !== allClosed) {
            return _this.loadUs();
          }
        };
      })(this));
      this.scope.$on("attachment:create", (function(_this) {
        return function() {
          return _this.analytics.trackEvent("attachment", "create", "create attachment on userstory", 1);
        };
      })(this));
      this.scope.$on("task:reorder", (function(_this) {
        return function(event, task, newIndex) {
          return _this.reorderTask(task, newIndex);
        };
      })(this));
      return this.scope.$on("comment:new", (function(_this) {
        return function() {
          return _this.loadUs();
        };
      })(this));
    };

    UserStoryDetailController.prototype.initializeOnDeleteGoToUrl = function() {
      var ctx;
      ctx = {
        project: this.scope.project.slug
      };
      this.scope.onDeleteGoToUrl = this.navUrls.resolve("project", ctx);
      if (this.scope.project.is_backlog_activated) {
        if (this.scope.us.milestone) {
          ctx.sprint = this.scope.sprint.slug;
          return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project-taskboard", ctx);
        } else {
          return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project-backlog", ctx);
        }
      } else if (this.scope.project.is_kanban_activated) {
        return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project-kanban", ctx);
      }
    };

    UserStoryDetailController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      this.scope.statusList = project.us_statuses;
      this.scope.statusById = groupBy(project.us_statuses, function(x) {
        return x.id;
      });
      this.scope.taskStatusById = groupBy(project.task_statuses, function(x) {
        return x.id;
      });
      this.scope.pointsList = _.sortBy(project.points, "order");
      this.scope.pointsById = groupBy(this.scope.pointsList, function(e) {
        return e.id;
      });
      return project;
    };

    UserStoryDetailController.prototype.loadUs = function() {
      var httpParams, kanbanStaus, milestone, noMilestone;
      httpParams = _.pick(this.location.search(), "milestone", "no-milestone", "kanban-status");
      milestone = httpParams.milestone;
      if (milestone) {
        this.rs.userstories.storeQueryParams(this.scope.projectId, {
          milestone: milestone,
          order_by: "sprint_order"
        });
      }
      noMilestone = httpParams["no-milestone"];
      if (noMilestone) {
        this.rs.userstories.storeQueryParams(this.scope.projectId, {
          milestone: "null",
          order_by: "backlog_order"
        });
      }
      kanbanStaus = httpParams["kanban-status"];
      if (kanbanStaus) {
        this.rs.userstories.storeQueryParams(this.scope.projectId, {
          status: kanbanStaus,
          order_by: "kanban_order"
        });
      }
      return this.rs.userstories.getByRef(this.scope.projectId, this.params.usref).then((function(_this) {
        return function(us) {
          _this.rootscope.$broadcast("userstory:loaded", us);
          _this.scope.us = us;
          _this.scope.usId = us.id;
          _this.scope.commentModel = us;
          _this.modelTransform.setObject(_this.scope, 'us');
          return us;
        };
      })(this));
    };

    UserStoryDetailController.prototype.loadSprint = function() {
      if (this.scope.us.milestone) {
        return this.rs.sprints.get(this.scope.us.project, this.scope.us.milestone).then((function(_this) {
          return function(sprint) {
            _this.scope.sprint = sprint;
            return sprint;
          };
        })(this));
      }
    };

    UserStoryDetailController.prototype.loadTasks = function() {
      return this.rs.tasks.list(this.scope.projectId, null, this.scope.usId).then((function(_this) {
        return function(tasks) {
          _this.scope.tasks = tasks;
          return tasks;
        };
      })(this));
    };

    UserStoryDetailController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      return this.loadUs().then((function(_this) {
        return function() {
          return _this.q.all([_this.loadSprint(), _this.loadTasks()]);
        };
      })(this));
    };


    /*
     * Note: This methods (onUpvote() and onDownvote()) are related to tg-vote-button.
     *       See app/modules/components/vote-button for more info
     */

    UserStoryDetailController.prototype.onUpvote = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadUs();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.userstories.upvote(this.scope.usId).then(onSuccess, onError);
    };

    UserStoryDetailController.prototype.onDownvote = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadUs();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.userstories.downvote(this.scope.usId).then(onSuccess, onError);
    };


    /*
     * Note: This methods (onWatch() and onUnwatch()) are related to tg-watch-button.
     *       See app/modules/components/watch-button for more info
     */

    UserStoryDetailController.prototype.onWatch = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadUs();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.userstories.watch(this.scope.usId).then(onSuccess, onError);
    };

    UserStoryDetailController.prototype.onUnwatch = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadUs();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.userstories.unwatch(this.scope.usId).then(onSuccess, onError);
    };

    UserStoryDetailController.prototype.onTribeInfo = function() {
      var image, publishDesc, publishTitle, text;
      publishTitle = this.translate.instant("US.TRIBE.PUBLISH_MORE_INFO_TITLE");
      image = $('<img />').attr({
        'src': "/" + window._version + "/images/monster-fight.png",
        'alt': this.translate.instant("US.TRIBE.PUBLISH_MORE_INFO_TITLE")
      });
      text = this.translate.instant("US.TRIBE.PUBLISH_MORE_INFO_TEXT");
      publishDesc = $('<div></div>').append(image).append(text);
      return this.confirm.success(publishTitle, publishDesc);
    };

    UserStoryDetailController.prototype.reorderTask = function(task, newIndex) {
      var afterDestination, beforeDestination, data, newOrder, orderList, previous, previousWithTheSameOrder, setOrders, withoutMoved;
      orderList = {};
      this.scope.tasks.forEach(function(it) {
        return orderList[it.id] = it.us_order;
      });
      withoutMoved = this.scope.tasks.filter(function(it) {
        return it.id !== task.id;
      });
      beforeDestination = withoutMoved.slice(0, newIndex);
      afterDestination = withoutMoved.slice(newIndex);
      previous = beforeDestination[beforeDestination.length - 1];
      newOrder = !previous ? 0 : previous.us_order + 1;
      orderList[task.id] = newOrder;
      previousWithTheSameOrder = beforeDestination.filter(function(it) {
        return it.us_order === previous.us_order;
      });
      setOrders = _.fromPairs(previousWithTheSameOrder.map(function(it) {
        return [it.id, it.us_order];
      }));
      afterDestination.forEach(function(it) {
        return orderList[it.id] = it.us_order + 1;
      });
      this.scope.tasks = _.map(this.scope.tasks, function(it) {
        it.us_order = orderList[it.id];
        return it;
      });
      this.scope.tasks = _.sortBy(this.scope.tasks, "us_order");
      data = {
        us_order: newOrder,
        version: task.version
      };
      return this.rs.tasks.reorder(task.id, data, setOrders).then((function(_this) {
        return function(newTask) {
          _this.scope.tasks = _.map(_this.scope.tasks, function(it) {
            if (it.id === newTask.id) {
              return newTask;
            } else {
              return it;
            }
          });
          return _this.rootscope.$broadcast("related-tasks:reordered");
        };
      })(this));
    };

    return UserStoryDetailController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("UserStoryDetailController", UserStoryDetailController);

  UsStatusDisplayDirective = function($template, $compile) {
    var link, template;
    template = $template.get("common/components/status-display.html", true);
    link = function($scope, $el, $attrs) {
      var render;
      render = function(us) {
        var html, status;
        status = $scope.statusById[us.status];
        html = template({
          is_closed: us.is_closed,
          status: status
        });
        html = $compile(html)($scope);
        return $el.html(html);
      };
      $scope.$watch($attrs.ngModel, function(us) {
        if (us != null) {
          return render(us);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgUsStatusDisplay", ["$tgTemplate", "$compile", UsStatusDisplayDirective]);

  UsStatusButtonDirective = function($rootScope, $repo, $confirm, $loading, $modelTransform, $template, $compile) {
    var link, template;
    template = $template.get("common/components/status-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var isEditable, render, save;
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_us") !== -1;
      };
      render = (function(_this) {
        return function(us) {
          var html, status;
          status = $scope.statusById[us.status];
          html = template({
            status: status,
            statuses: $scope.statusList,
            editable: isEditable()
          });
          $el.html(html);
          return $compile($el.contents())($scope);
        };
      })(this);
      save = (function(_this) {
        return function(status) {
          var currentLoading, onError, onSuccess, transform;
          $el.find(".pop-status").popover().close();
          currentLoading = $loading().target($el.find('.js-edit-status')).start();
          transform = $modelTransform.save(function(us) {
            us.status = status;
            return us;
          });
          onSuccess = function() {
            $rootScope.$broadcast("object:updated");
            return currentLoading.finish();
          };
          onError = function() {
            $confirm.notify("error");
            return currentLoading.finish();
          };
          return transform.then(onSuccess, onError);
        };
      })(this);
      $el.on("click", ".js-edit-status", function(event) {
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        return $el.find(".pop-status").popover().open();
      });
      $el.on("click", ".status", function(event) {
        var status, target;
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        target = angular.element(event.currentTarget);
        status = target.data("status-id");
        return save(status);
      });
      $scope.$watch(function() {
        var ref;
        return (ref = $model.$modelValue) != null ? ref.status : void 0;
      }, function() {
        var us;
        us = $model.$modelValue;
        if (us) {
          return render(us);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgUsStatusButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$compile", UsStatusButtonDirective]);

  UsTeamRequirementButtonDirective = function($rootscope, $tgrepo, $confirm, $loading, $modelTransform, $template, $compile) {
    var link, template;
    template = $template.get("us/us-team-requirement-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var canEdit, render, save;
      canEdit = function() {
        return $scope.project.my_permissions.indexOf("modify_us") !== -1;
      };
      render = function(us) {
        var ctx, html;
        ctx = {
          canEdit: canEdit(),
          isRequired: us.team_requirement
        };
        html = template(ctx);
        html = $compile(html)($scope);
        return $el.html(html);
      };
      save = function(team_requirement) {
        var currentLoading, transform;
        currentLoading = $loading().target($el.find("label")).start();
        transform = $modelTransform.save(function(us) {
          us.team_requirement = team_requirement;
          return us;
        });
        transform.then((function(_this) {
          return function() {
            currentLoading.finish();
            return $rootscope.$broadcast("object:updated");
          };
        })(this));
        return transform.then(null, function() {
          currentLoading.finish();
          return $confirm.notify("error");
        });
      };
      $el.on("click", ".team-requirement", function(event) {
        var team_requirement;
        if (!canEdit()) {
          return;
        }
        team_requirement = !$model.$modelValue.team_requirement;
        return save(team_requirement);
      });
      $scope.$watch(function() {
        var ref;
        return (ref = $model.$modelValue) != null ? ref.team_requirement : void 0;
      }, function() {
        var us;
        us = $model.$modelValue;
        if (us) {
          return render(us);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgUsTeamRequirementButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$compile", UsTeamRequirementButtonDirective]);

  UsClientRequirementButtonDirective = function($rootscope, $tgrepo, $confirm, $loading, $modelTransform, $template, $compile) {
    var link, template;
    template = $template.get("us/us-client-requirement-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var canEdit, render, save;
      canEdit = function() {
        return $scope.project.my_permissions.indexOf("modify_us") !== -1;
      };
      render = function(us) {
        var ctx, html;
        ctx = {
          canEdit: canEdit(),
          isRequired: us.client_requirement
        };
        html = $compile(template(ctx))($scope);
        return $el.html(html);
      };
      save = function(client_requirement) {
        var currentLoading, transform;
        currentLoading = $loading().target($el.find("label")).start();
        transform = $modelTransform.save(function(us) {
          us.client_requirement = client_requirement;
          return us;
        });
        transform.then((function(_this) {
          return function() {
            currentLoading.finish();
            return $rootscope.$broadcast("object:updated");
          };
        })(this));
        return transform.then(null, function() {
          return $confirm.notify("error");
        });
      };
      $el.on("click", ".client-requirement", function(event) {
        var client_requirement;
        if (!canEdit()) {
          return;
        }
        client_requirement = !$model.$modelValue.client_requirement;
        return save(client_requirement);
      });
      $scope.$watch(function() {
        var ref;
        return (ref = $model.$modelValue) != null ? ref.client_requirement : void 0;
      }, function() {
        var us;
        us = $model.$modelValue;
        if (us) {
          return render(us);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgUsClientRequirementButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$compile", UsClientRequirementButtonDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/tasks/detail.coffee
 */

(function() {
  var TaskDetailController, TaskIsIocaineButtonDirective, TaskStatusButtonDirective, TaskStatusDisplayDirective, bindMethods, groupBy, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  groupBy = this.taiga.groupBy;

  bindMethods = this.taiga.bindMethods;

  module = angular.module("taigaTasks");

  TaskDetailController = (function(superClass) {
    extend(TaskDetailController, superClass);

    TaskDetailController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$log", "tgAppMetaService", "$tgNavUrls", "$tgAnalytics", "$translate", "$tgQueueModelTransformation", "tgErrorHandlingService", "tgProjectService"];

    function TaskDetailController(scope, rootscope, repo, confirm, rs, params, q, location, log, appMetaService, navUrls, analytics, translate, modelTransform, errorHandlingService, projectService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.log = log;
      this.appMetaService = appMetaService;
      this.navUrls = navUrls;
      this.analytics = analytics;
      this.translate = translate;
      this.modelTransform = modelTransform;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService;
      bindMethods(this);
      this.scope.taskRef = this.params.taskref;
      this.scope.sectionName = this.translate.instant("TASK.SECTION_NAME");
      this.initializeEventHandlers();
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          _this._setMeta();
          return _this.initializeOnDeleteGoToUrl();
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    TaskDetailController.prototype._setMeta = function() {
      var description, ref1, title;
      title = this.translate.instant("TASK.PAGE_TITLE", {
        taskRef: "#" + this.scope.task.ref,
        taskSubject: this.scope.task.subject,
        projectName: this.scope.project.name
      });
      description = this.translate.instant("TASK.PAGE_DESCRIPTION", {
        taskStatus: ((ref1 = this.scope.statusById[this.scope.task.status]) != null ? ref1.name : void 0) || "--",
        taskDescription: angular.element(this.scope.task.description_html || "").text()
      });
      return this.appMetaService.setAll(title, description);
    };

    TaskDetailController.prototype.initializeEventHandlers = function() {
      this.scope.$on("promote-task-to-us:success", (function(_this) {
        return function(e, ref) {
          var ctx;
          _this.analytics.trackEvent("task", "promoteToUserstory", "promote task to userstory", 1);
          ctx = {
            project: _this.scope.project.slug,
            ref: ref
          };
          return _this.location.path(_this.navUrls.resolve("project-userstories-detail", ctx));
        };
      })(this));
      this.scope.$on("attachment:create", (function(_this) {
        return function() {
          return _this.analytics.trackEvent("attachment", "create", "create attachment on task", 1);
        };
      })(this));
      this.scope.$on("custom-attributes-values:edit", (function(_this) {
        return function() {
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this));
      return this.scope.$on("comment:new", (function(_this) {
        return function() {
          return _this.loadTask();
        };
      })(this));
    };

    TaskDetailController.prototype.initializeOnDeleteGoToUrl = function() {
      var ctx;
      ctx = {
        project: this.scope.project.slug
      };
      this.scope.onDeleteGoToUrl = this.navUrls.resolve("project", ctx);
      if (this.scope.project.is_backlog_activated) {
        if (this.scope.task.milestone) {
          ctx.sprint = this.scope.sprint.slug;
          return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project-taskboard", ctx);
        } else if (this.scope.task.us) {
          ctx.ref = this.scope.us.ref;
          return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project-userstories-detail", ctx);
        }
      } else if (this.scope.project.is_kanban_activated) {
        if (this.scope.us) {
          ctx.ref = this.scope.us.ref;
          return this.scope.onDeleteGoToUrl = this.navUrls.resolve("project-userstories-detail", ctx);
        }
      }
    };

    TaskDetailController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      this.scope.statusList = project.task_statuses;
      this.scope.statusById = groupBy(project.task_statuses, function(x) {
        return x.id;
      });
      return project;
    };

    TaskDetailController.prototype.loadTask = function() {
      return this.rs.tasks.getByRef(this.scope.projectId, this.params.taskref).then((function(_this) {
        return function(task) {
          var ctx, ref1, ref2;
          _this.scope.task = task;
          _this.scope.taskId = task.id;
          _this.scope.commentModel = task;
          _this.modelTransform.setObject(_this.scope, 'task');
          if (((ref1 = _this.scope.task.neighbors.previous) != null ? ref1.ref : void 0) != null) {
            ctx = {
              project: _this.scope.project.slug,
              ref: _this.scope.task.neighbors.previous.ref
            };
            _this.scope.previousUrl = _this.navUrls.resolve("project-tasks-detail", ctx);
          }
          if (((ref2 = _this.scope.task.neighbors.next) != null ? ref2.ref : void 0) != null) {
            ctx = {
              project: _this.scope.project.slug,
              ref: _this.scope.task.neighbors.next.ref
            };
            _this.scope.nextUrl = _this.navUrls.resolve("project-tasks-detail", ctx);
          }
          return task;
        };
      })(this));
    };

    TaskDetailController.prototype.loadSprint = function() {
      if (this.scope.task.milestone) {
        return this.rs.sprints.get(this.scope.task.project, this.scope.task.milestone).then((function(_this) {
          return function(sprint) {
            _this.scope.sprint = sprint;
            return sprint;
          };
        })(this));
      }
    };

    TaskDetailController.prototype.loadUserStory = function() {
      if (this.scope.task.user_story) {
        return this.rs.userstories.get(this.scope.task.project, this.scope.task.user_story).then((function(_this) {
          return function(us) {
            _this.scope.us = us;
            return us;
          };
        })(this));
      }
    };

    TaskDetailController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      return this.loadTask().then((function(_this) {
        return function() {
          return _this.q.all([_this.loadSprint(), _this.loadUserStory()]);
        };
      })(this));
    };


    /*
     * Note: This methods (onUpvote() and onDownvote()) are related to tg-vote-button.
     *       See app/modules/components/vote-button for more info
     */

    TaskDetailController.prototype.onUpvote = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadTask();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.tasks.upvote(this.scope.taskId).then(onSuccess, onError);
    };

    TaskDetailController.prototype.onDownvote = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadTask();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.tasks.downvote(this.scope.taskId).then(onSuccess, onError);
    };


    /*
     * Note: This methods (onWatch() and onUnwatch()) are related to tg-watch-button.
     *       See app/modules/components/watch-button for more info
     */

    TaskDetailController.prototype.onWatch = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadTask();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.tasks.watch(this.scope.taskId).then(onSuccess, onError);
    };

    TaskDetailController.prototype.onUnwatch = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.loadTask();
          return _this.rootscope.$broadcast("object:updated");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.rs.tasks.unwatch(this.scope.taskId).then(onSuccess, onError);
    };

    return TaskDetailController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("TaskDetailController", TaskDetailController);

  TaskStatusDisplayDirective = function($template, $compile) {
    var link, template;
    template = $template.get("common/components/status-display.html", true);
    link = function($scope, $el, $attrs) {
      var render;
      render = function(task) {
        var html, status;
        status = $scope.statusById[task.status];
        html = template({
          is_closed: status.is_closed,
          status: status
        });
        html = $compile(html)($scope);
        return $el.html(html);
      };
      $scope.$watch($attrs.ngModel, function(task) {
        if (task != null) {
          return render(task);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgTaskStatusDisplay", ["$tgTemplate", "$compile", TaskStatusDisplayDirective]);

  TaskStatusButtonDirective = function($rootScope, $repo, $confirm, $loading, $modelTransform, $compile, $translate, $template) {
    var link, template;
    template = $template.get("common/components/status-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var isEditable, render, save;
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_task") !== -1;
      };
      render = (function(_this) {
        return function(task) {
          var html, status;
          status = $scope.statusById[task.status];
          html = $compile(template({
            status: status,
            statuses: $scope.statusList,
            editable: isEditable()
          }))($scope);
          return $el.html(html);
        };
      })(this);
      save = function(status) {
        var currentLoading, onError, onSuccess, transform;
        currentLoading = $loading().target($el).start();
        transform = $modelTransform.save(function(task) {
          task.status = status;
          return task;
        });
        onSuccess = function() {
          $rootScope.$broadcast("object:updated");
          return currentLoading.finish();
        };
        onError = function() {
          $confirm.notify("error");
          return currentLoading.finish();
        };
        return transform.then(onSuccess, onError);
      };
      $el.on("click", ".js-edit-status", function(event) {
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        return $el.find(".pop-status").popover().open();
      });
      $el.on("click", ".status", function(event) {
        var target;
        event.preventDefault();
        event.stopPropagation();
        if (!isEditable()) {
          return;
        }
        target = angular.element(event.currentTarget);
        $.fn.popover().closeAll();
        return save(target.data("status-id"));
      });
      $scope.$watch(function() {
        var ref1;
        return (ref1 = $model.$modelValue) != null ? ref1.status : void 0;
      }, function() {
        var task;
        task = $model.$modelValue;
        if (task) {
          return render(task);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgTaskStatusButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$compile", "$translate", "$tgTemplate", TaskStatusButtonDirective]);

  TaskIsIocaineButtonDirective = function($rootscope, $tgrepo, $confirm, $loading, $modelTransform, $compile, $template) {
    var link, template;
    template = $template.get("issue/iocaine-button.html", true);
    link = function($scope, $el, $attrs, $model) {
      var isEditable, render, save;
      isEditable = function() {
        return $scope.project.my_permissions.indexOf("modify_task") !== -1;
      };
      render = function(task) {
        var ctx, html;
        if (!isEditable() && !task.is_iocaine) {
          $el.html("");
          return;
        }
        ctx = {
          isIocaine: task.is_iocaine,
          isEditable: isEditable()
        };
        html = $compile(template(ctx))($scope);
        return $el.html(html);
      };
      save = function(is_iocaine) {
        var currentLoading, transform;
        currentLoading = $loading().target($el.find('label')).start();
        transform = $modelTransform.save(function(task) {
          task.is_iocaine = is_iocaine;
          return task;
        });
        transform.then(function() {
          return $rootscope.$broadcast("object:updated");
        });
        transform.then(null, function() {
          return $confirm.notify("error");
        });
        return transform["finally"](function() {
          return currentLoading.finish();
        });
      };
      $el.on("click", ".is-iocaine", function(event) {
        var is_iocaine;
        if (!isEditable()) {
          return;
        }
        is_iocaine = !$model.$modelValue.is_iocaine;
        return save(is_iocaine);
      });
      $scope.$watch(function() {
        var ref1;
        return (ref1 = $model.$modelValue) != null ? ref1.is_iocaine : void 0;
      }, function() {
        var task;
        task = $model.$modelValue;
        if (task) {
          return render(task);
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgTaskIsIocaineButton", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgQueueModelTransformation", "$compile", "$tgTemplate", TaskIsIocaineButtonDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/team/main.coffee
 */

(function() {
  var LeaveProjectDirective, TeamController, TeamFiltersDirective, TeamMemberCurrentUserDirective, TeamMemberStatsDirective, TeamMembersDirective, membersFilter, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  module = angular.module("taigaTeam");

  TeamController = (function(superClass) {
    extend(TeamController, superClass);

    TeamController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgResources", "$routeParams", "$q", "$location", "$tgNavUrls", "tgAppMetaService", "$tgAuth", "$translate", "tgProjectService", "tgErrorHandlingService"];

    function TeamController(scope, rootscope, repo, rs, params, q, location, navUrls, appMetaService, auth, translate, projectService, errorHandlingService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.appMetaService = appMetaService;
      this.auth = auth;
      this.translate = translate;
      this.projectService = projectService;
      this.errorHandlingService = errorHandlingService;
      this.scope.sectionName = "TEAM.SECTION_NAME";
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("TEAM.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.translate.instant("TEAM.PAGE_DESCRIPTION", {
            projectName: _this.scope.project.name,
            projectDescription: _this.scope.project.description
          });
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    TeamController.prototype.setRole = function(role) {
      if (role) {
        return this.scope.filtersRole = role;
      } else {
        return this.scope.filtersRole = null;
      }
    };

    TeamController.prototype.loadMembers = function() {
      var i, len, member, ref, user;
      user = this.auth.getUser();
      this.scope.totals = {};
      ref = this.scope.activeUsers;
      for (i = 0, len = ref.length; i < len; i++) {
        member = ref[i];
        this.scope.totals[member.id] = 0;
      }
      this.scope.currentUser = _.find(this.scope.activeUsers, {
        id: user != null ? user.id : void 0
      });
      return this.scope.memberships = _.reject(this.scope.activeUsers, {
        id: user != null ? user.id : void 0
      });
    };

    TeamController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      this.scope.issuesEnabled = project.is_issues_activated;
      this.scope.tasksEnabled = project.is_kanban_activated || project.is_backlog_activated;
      this.scope.wikiEnabled = project.is_wiki_activated;
      this.scope.owner = project.owner.id;
      return project;
    };

    TeamController.prototype.loadMemberStats = function() {
      return this.rs.projects.memberStats(this.scope.projectId).then((function(_this) {
        return function(stats) {
          var totals;
          totals = {};
          _.forEach(_this.scope.totals, function(total, userId) {
            var vals;
            vals = _.map(stats, function(memberStats, statsKey) {
              return memberStats[userId];
            });
            total = _.reduce(vals, function(sum, el) {
              return sum + el;
            });
            return _this.scope.totals[userId] = total;
          });
          _this.scope.stats = _this._processStats(stats);
          return _this.scope.stats.totals = _this.scope.totals;
        };
      })(this));
    };

    TeamController.prototype._processStat = function(stat) {
      var key, max, min, singleStat, value;
      max = _.max(_.toArray(stat));
      min = _.min(_.toArray(stat));
      singleStat = Object();
      for (key in stat) {
        if (!hasProp.call(stat, key)) continue;
        value = stat[key];
        if (value === min) {
          singleStat[key] = 0.1;
        } else if (value === max) {
          singleStat[key] = 1;
        } else {
          singleStat[key] = (value * 0.5) / max;
        }
      }
      return singleStat;
    };

    TeamController.prototype._processStats = function(stats) {
      var key, value;
      for (key in stats) {
        value = stats[key];
        stats[key] = this._processStat(value);
      }
      return stats;
    };

    TeamController.prototype.loadInitialData = function() {
      var project, userRoles;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      this.loadMembers();
      userRoles = _.map(this.scope.users, function(user) {
        return user.role;
      });
      this.scope.roles = _.filter(this.scope.roles, function(role) {
        return userRoles.indexOf(role.id) !== -1;
      });
      return this.loadMemberStats();
    };

    return TeamController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("TeamController", TeamController);

  TeamFiltersDirective = function() {
    return {
      templateUrl: "team/team-filter.html"
    };
  };

  module.directive("tgTeamFilters", [TeamFiltersDirective]);

  TeamMemberStatsDirective = function() {
    return {
      templateUrl: "team/team-member-stats.html",
      scope: {
        stats: "=",
        userId: "=user",
        issuesEnabled: "=issuesenabled",
        tasksEnabled: "=tasksenabled",
        wikiEnabled: "=wikienabled"
      }
    };
  };

  module.directive("tgTeamMemberStats", TeamMemberStatsDirective);

  TeamMemberCurrentUserDirective = function() {
    return {
      templateUrl: "team/team-member-current-user.html",
      scope: {
        project: "=project",
        currentUser: "=currentuser",
        stats: "=",
        issuesEnabled: "=issuesenabled",
        tasksEnabled: "=tasksenabled",
        wikiEnabled: "=wikienabled",
        owner: "=owner"
      }
    };
  };

  module.directive("tgTeamCurrentUser", TeamMemberCurrentUserDirective);

  TeamMembersDirective = function() {
    var template;
    template = "team/team-members.html";
    return {
      templateUrl: template,
      scope: {
        memberships: "=",
        filtersQ: "=filtersq",
        filtersRole: "=filtersrole",
        stats: "=",
        issuesEnabled: "=issuesenabled",
        tasksEnabled: "=tasksenabled",
        wikiEnabled: "=wikienabled",
        owner: "=owner"
      }
    };
  };

  module.directive("tgTeamMembers", TeamMembersDirective);

  LeaveProjectDirective = function($repo, $confirm, $location, $rs, $navurls, $translate, lightboxFactory, currentUserService) {
    var link;
    link = function($scope, $el, $attrs) {
      var leaveConfirm;
      leaveConfirm = function() {
        var confirm_leave_project_text, leave_project_text;
        leave_project_text = $translate.instant("TEAM.ACTION_LEAVE_PROJECT");
        confirm_leave_project_text = $translate.instant("TEAM.CONFIRM_LEAVE_PROJECT");
        return $confirm.ask(leave_project_text, confirm_leave_project_text).then((function(_this) {
          return function(response) {
            var promise;
            promise = $rs.projects.leave($scope.project.id);
            promise.then(function() {
              return currentUserService.loadProjects().then(function() {
                response.finish();
                $confirm.notify("success");
                return $location.path($navurls.resolve("home"));
              });
            });
            return promise.then(null, function(response) {
              response.finish();
              return $confirm.notify('error', response.data._error_message);
            });
          };
        })(this));
      };
      return $scope.leave = function() {
        if ($scope.project.owner.id === $scope.user.id) {
          return lightboxFactory.create("tg-lightbox-leave-project-warning", {
            "class": "lightbox lightbox-leave-project-warning"
          }, {
            isCurrentUser: true,
            project: $scope.project
          });
        } else {
          return leaveConfirm();
        }
      };
    };
    return {
      scope: {
        user: "=",
        project: "="
      },
      templateUrl: "team/leave-project.html",
      link: link
    };
  };

  module.directive("tgLeaveProject", ["$tgRepo", "$tgConfirm", "$tgLocation", "$tgResources", "$tgNavUrls", "$translate", "tgLightboxFactory", "tgCurrentUserService", LeaveProjectDirective]);

  membersFilter = function() {
    return function(members, filtersQ, filtersRole) {
      return _.filter(members, function(m) {
        return (!filtersRole || m.role === filtersRole.id) && (!filtersQ || m.full_name.search(new RegExp(filtersQ, "i")) >= 0);
      });
    };
  };

  module.filter('membersFilter', membersFilter);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/wiki/main.coffee
 */

(function() {
  var WikiDetailController, WikiSummaryDirective, WikiWysiwyg, bindOnce, debounce, groupBy, mixOf, module, taiga,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  module = angular.module("taigaWiki");

  WikiDetailController = (function(superClass) {
    extend(WikiDetailController, superClass);

    WikiDetailController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgModel", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$filter", "$log", "tgAppMetaService", "$tgNavUrls", "$tgAnalytics", "$translate", "tgErrorHandlingService", "tgProjectService"];

    function WikiDetailController(scope, rootscope, repo, model, confirm, rs, params, q, location, filter, log, appMetaService, navUrls, analytics, translate, errorHandlingService, projectService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.model = model;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.filter = filter;
      this.log = log;
      this.appMetaService = appMetaService;
      this.navUrls = navUrls;
      this.analytics = analytics;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService;
      this.moveLink = bind(this.moveLink, this);
      this.loadWiki = bind(this.loadWiki, this);
      this.scope.$on("wiki:links:move", this.moveLink);
      this.scope.$on("wikipage:add", this.loadWiki);
      this.scope.projectSlug = this.params.pslug;
      this.scope.wikiSlug = this.params.slug;
      this.scope.sectionName = "Wiki";
      this.scope.linksVisible = false;
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          return _this._setMeta();
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    WikiDetailController.prototype._setMeta = function() {
      var description, ref, ref1, ref2, title;
      title = this.translate.instant("WIKI.PAGE_TITLE", {
        wikiPageName: this.scope.wikiSlug,
        projectName: this.scope.project.name
      });
      description = this.translate.instant("WIKI.PAGE_DESCRIPTION", {
        wikiPageContent: angular.element(((ref = this.scope.wiki) != null ? ref.html : void 0) || "").text(),
        totalEditions: ((ref1 = this.scope.wiki) != null ? ref1.editions : void 0) || 0,
        lastModifiedDate: moment((ref2 = this.scope.wiki) != null ? ref2.modified_date : void 0).format(this.translate.instant("WIKI.DATETIME"))
      });
      return this.appMetaService.setAll(title, description);
    };

    WikiDetailController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      if (!project.is_wiki_activated) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    WikiDetailController.prototype.loadWiki = function() {
      var promise;
      promise = this.rs.wiki.getBySlug(this.scope.projectId, this.params.slug);
      promise.then((function(_this) {
        return function(wiki) {
          _this.scope.wiki = wiki;
          _this.scope.wikiId = wiki.id;
          return _this.scope.wiki;
        };
      })(this));
      return promise.then(null, (function(_this) {
        return function(xhr) {
          var data;
          _this.scope.wikiId = null;
          if (_this.scope.project.my_permissions.indexOf("add_wiki_page") === -1) {
            return null;
          }
          data = {
            project: _this.scope.projectId,
            slug: _this.scope.wikiSlug,
            content: ""
          };
          _this.scope.wiki = _this.model.make_model("wiki", data);
          return _this.scope.wiki;
        };
      })(this));
    };

    WikiDetailController.prototype.loadWikiLinks = function() {
      return this.rs.wiki.listLinks(this.scope.projectId).then((function(_this) {
        return function(wikiLinks) {
          var i, len, link, ref, selectedWikiLink;
          _this.scope.wikiLinks = wikiLinks;
          ref = _this.scope.wikiLinks;
          for (i = 0, len = ref.length; i < len; i++) {
            link = ref[i];
            link.url = _this.navUrls.resolve("project-wiki-page", {
              project: _this.scope.projectSlug,
              slug: link.href
            });
          }
          return selectedWikiLink = _.find(wikiLinks, {
            href: _this.scope.wikiSlug
          });
        };
      })(this));
    };

    WikiDetailController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      return this.q.all([this.loadWikiLinks(), this.loadWiki()]).then(this.checkLinksPerms.bind(this));
    };

    WikiDetailController.prototype.checkLinksPerms = function() {
      if (this.scope.project.my_permissions.indexOf("add_wiki_link") !== -1 || (this.scope.project.my_permissions.indexOf("view_wiki_links") !== -1 && this.scope.wikiLinks.length)) {
        return this.scope.linksVisible = true;
      }
    };

    WikiDetailController.prototype["delete"] = function() {
      var message, title;
      title = this.translate.instant("WIKI.DELETE_LIGHTBOX_TITLE");
      message = this.scope.wikiSlug;
      return this.confirm.askOnDelete(title, message).then((function(_this) {
        return function(askResponse) {
          var onError, onSuccess;
          onSuccess = function() {
            var ctx;
            askResponse.finish();
            ctx = {
              project: _this.scope.projectSlug
            };
            _this.location.path(_this.navUrls.resolve("project-wiki", ctx));
            _this.confirm.notify("success");
            return _this.loadWiki();
          };
          onError = function() {
            askResponse.finish(false);
            return _this.confirm.notify("error");
          };
          return _this.repo.remove(_this.scope.wiki).then(onSuccess, onError);
        };
      })(this));
    };

    WikiDetailController.prototype.moveLink = function(ctx, item, itemIndex) {
      var r, values;
      values = this.scope.wikiLinks;
      r = values.indexOf(item);
      values.splice(r, 1);
      values.splice(itemIndex, 0, item);
      _.each(values, function(value, index) {
        return value.order = index;
      });
      return this.repo.saveAll(values);
    };

    return WikiDetailController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("WikiDetailController", WikiDetailController);

  WikiSummaryDirective = function($log, $template, $compile, $translate, avatarService) {
    var link, template;
    template = $template.get("wiki/wiki-summary.html", true);
    link = function($scope, $el, $attrs, $model) {
      var render;
      render = function(wiki) {
        var avatar, ctx, html, user;
        if ($scope.usersById == null) {
          $log.error("WikiSummaryDirective requires userById set in scope.");
        } else {
          user = $scope.usersById[wiki.last_modifier];
        }
        avatar = avatarService.getAvatar(user);
        if (user === void 0) {
          user = {
            name: "unknown",
            avatar: avatar
          };
        } else {
          user = {
            name: user.full_name_display,
            avatar: avatar
          };
        }
        ctx = {
          totalEditions: wiki.editions,
          lastModifiedDate: moment(wiki.modified_date).format($translate.instant("WIKI.DATETIME")),
          user: user
        };
        html = template(ctx);
        html = $compile(html)($scope);
        return $el.html(html);
      };
      $scope.$watch($attrs.ngModel, function(wikiPage) {
        if (!wikiPage) {
          return;
        }
        return render(wikiPage);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgWikiSummary", ["$log", "$tgTemplate", "$compile", "$translate", "tgAvatarService", WikiSummaryDirective]);

  WikiWysiwyg = function($modelTransform, $rootscope, $confirm, attachmentsFullService, $qqueue, $repo, $analytics, activityService) {
    var link;
    link = function($scope, $el, $attrs) {
      var uploadFile;
      $scope.editableDescription = false;
      $scope.saveDescription = $qqueue.bindAdd(function(description, cb) {
        var onError, onSuccess, promise;
        onSuccess = function(wikiPage) {
          if ($scope.item.id == null) {
            $analytics.trackEvent("wikipage", "create", "create wiki page", 1);
            $scope.$emit("wikipage:add");
          }
          activityService.fetchEntries(true);
          return $confirm.notify("success");
        };
        onError = function() {
          return $confirm.notify("error");
        };
        $scope.item.content = description;
        if ($scope.item.id != null) {
          promise = $repo.save($scope.item).then(onSuccess, onError);
        } else {
          promise = $repo.create("wiki", $scope.item).then(onSuccess, onError);
        }
        return promise["finally"](cb);
      });
      uploadFile = function(file, cb) {
        return attachmentsFullService.addAttachment($scope.project.id, $scope.item.id, 'wiki_page', file).then(function(result) {
          return cb(result.getIn(['file', 'name']), result.getIn(['file', 'url']), 'wiki_page', result.getIn(['file', 'id']));
        });
      };
      $scope.uploadFiles = function(files, cb) {
        var file, i, len, results;
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(uploadFile(file, cb));
        }
        return results;
      };
      $scope.$watch($attrs.model, function(value) {
        if (!value) {
          return;
        }
        $scope.item = value;
        $scope.version = value.version;
        return $scope.storageKey = $scope.project.id + "-" + value.id + "-wiki";
      });
      return $scope.$watch('project', function(project) {
        if (!project) {
          return;
        }
        return $scope.editableDescription = project.my_permissions.indexOf("modify_wiki_page") !== -1;
      });
    };
    return {
      scope: true,
      link: link,
      template: "<div>\n    <tg-wysiwyg\n        ng-if=\"editableDescription\"\n        version='version'\n        storage-key='storageKey'\n        content='item.content'\n        on-save='saveDescription(text, cb)'\n        on-upload-file='uploadFiles(files, cb)'>\n    </tg-wysiwyg>\n\n    <div\n        class=\"wysiwyg\"\n        ng-if=\"!editableDescription && item.content.length\"\n        ng-bind-html=\"item.content | markdownToHTML\"></div>\n\n    <div\n        class=\"wysiwyg\"\n        ng-if=\"!editableDescription && !item.content.length\">\n        {{'COMMON.DESCRIPTION.NO_DESCRIPTION' | translate}}\n    </div>\n</div>"
    };
  };

  module.directive("tgWikiWysiwyg", ["$tgQueueModelTransformation", "$rootScope", "$tgConfirm", "tgAttachmentsFullService", "$tgQqueue", "$tgRepo", "$tgAnalytics", "tgActivityService", WikiWysiwyg]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/wiki/nav.coffee
 */

(function() {
  var WikiNavDirective, bindOnce, groupBy, mixOf, module, taiga;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaWiki");

  WikiNavDirective = function($tgrepo, $log, $location, $confirm, $analytics, $loading, $template, $compile, $translate) {
    var link, linkWikiLinks, template;
    template = $template.get("wiki/wiki-nav.html", true);
    linkWikiLinks = function($scope, $el, $attrs) {
      var $ctrl, addWikiLinkPermission, drake, render;
      $ctrl = $el.controller();
      if ($attrs.ngModel == null) {
        return $log.error("WikiNavDirective: no ng-model attr is defined");
      }
      addWikiLinkPermission = $scope.project.my_permissions.indexOf("add_wiki_link") > -1;
      drake = null;
      render = function(wikiLinks) {
        var deleteWikiLinkPermission, html, itemEl, scroll, tdom;
        addWikiLinkPermission = $scope.project.my_permissions.indexOf("add_wiki_link") > -1;
        deleteWikiLinkPermission = $scope.project.my_permissions.indexOf("delete_wiki_link") > -1;
        html = template({
          wikiLinks: wikiLinks,
          projectSlug: $scope.projectSlug,
          addWikiLinkPermission: addWikiLinkPermission,
          deleteWikiLinkPermission: deleteWikiLinkPermission
        });
        html = $compile(html)($scope);
        $el.off();
        if (addWikiLinkPermission && drake) {
          drake.destroy();
        }
        $el.html(html);
        if (addWikiLinkPermission) {
          itemEl = null;
          tdom = $el.find(".sortable");
          drake = dragula([tdom[0]], {
            direction: 'vertical',
            copySortSource: false,
            copy: false,
            mirrorContainer: tdom[0],
            moves: function(item) {
              return $(item).is('li');
            }
          });
          drake.on('dragend', function(item) {
            var itemIndex;
            itemEl = $(item);
            item = itemEl.scope().link;
            itemIndex = itemEl.index();
            return $scope.$emit("wiki:links:move", item, itemIndex);
          });
          scroll = autoScroll(window, {
            margin: 20,
            pixels: 30,
            scrollWhenOutside: true,
            autoScroll: function() {
              return this.down && drake.dragging;
            }
          });
        }
        $el.on("click", ".add-button", function(event) {
          event.preventDefault();
          $el.find(".new").removeClass("hidden");
          $el.find(".new input").focus();
          return $el.find(".add-button").hide();
        });
        $el.on("click", ".js-delete-link", function(event) {
          var linkId, message, target, title;
          event.preventDefault();
          event.stopPropagation();
          target = angular.element(event.currentTarget);
          linkId = target.parents('.wiki-link').data('id');
          title = $translate.instant("WIKI.DELETE_LINK_TITLE");
          message = $scope.wikiLinks[linkId].title;
          return $confirm.askOnDelete(title, message).then((function(_this) {
            return function(askResponse) {
              var promise;
              promise = $tgrepo.remove($scope.wikiLinks[linkId]);
              promise.then(function() {
                promise = $ctrl.loadWikiLinks();
                promise.then(function() {
                  askResponse.finish();
                  return render($scope.wikiLinks);
                });
                return promise.then(null, function() {
                  return askResponse.finish();
                });
              });
              return promise.then(null, function() {
                askResponse.finish(false);
                return $confirm.notify("error");
              });
            };
          })(this));
        });
        return $el.on("keyup", ".new input", function(event) {
          var currentLoading, newLink, promise, target;
          event.preventDefault();
          if (event.keyCode === 13) {
            target = angular.element(event.currentTarget);
            newLink = target.val();
            currentLoading = $loading().target($el.find(".new")).start();
            promise = $tgrepo.create("wiki-links", {
              project: $scope.projectId,
              title: newLink
            });
            promise.then(function() {
              var loadPromise;
              $analytics.trackEvent("wikilink", "create", "create wiki link", 1);
              loadPromise = $ctrl.loadWikiLinks();
              loadPromise.then(function() {
                currentLoading.finish();
                $el.find(".new").addClass("hidden");
                $el.find(".new input").val('');
                $el.find(".add-button").show();
                return render($scope.wikiLinks);
              });
              return loadPromise.then(null, function() {
                currentLoading.finish();
                $el.find(".new").addClass("hidden");
                $el.find(".new input").val('');
                $el.find(".add-button").show();
                return $confirm.notify("error", "Error loading wiki links");
              });
            });
            return promise.then(null, function(error) {
              var ref;
              currentLoading.finish();
              $el.find(".new input").val(newLink);
              $el.find(".new input").focus().select();
              if ((error != null ? (ref = error.__all__) != null ? ref[0] : void 0 : void 0) != null) {
                return $confirm.notify("error", "The link already exists");
              } else {
                return $confirm.notify("error");
              }
            });
          } else if (event.keyCode === 27) {
            target = angular.element(event.currentTarget);
            $el.find(".new").addClass("hidden");
            $el.find(".new input").val('');
            return $el.find(".add-button").show();
          }
        });
      };
      return bindOnce($scope, $attrs.ngModel, render);
    };
    link = function($scope, $el, $attrs) {
      linkWikiLinks($scope, $el, $attrs);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgWikiNav", ["$tgRepo", "$log", "$tgLocation", "$tgConfirm", "$tgAnalytics", "$tgLoading", "$tgTemplate", "$compile", "$translate", WikiNavDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/wiki/pages-list.coffee
 */

(function() {
  var WikiPagesListController, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  module = angular.module("taigaWiki");

  WikiPagesListController = (function(superClass) {
    extend(WikiPagesListController, superClass);

    WikiPagesListController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgModel", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgNavUrls", "tgErrorHandlingService", "tgProjectService"];

    function WikiPagesListController(scope, rootscope, repo, model, confirm, rs, params, q, navUrls, errorHandlingService, projectService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.model = model;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.navUrls = navUrls;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService;
      this.scope.projectSlug = this.params.pslug;
      this.scope.wikiSlug = this.params.slug;
      this.scope.sectionName = "Wiki";
      this.scope.linksVisible = false;
      promise = this.loadInitialData();
      promise.then(null, this.onInitialDataError.bind(this));
    }

    WikiPagesListController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      if (!project.is_wiki_activated) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    WikiPagesListController.prototype.loadWikiPages = function() {
      var promise;
      return promise = this.rs.wiki.list(this.scope.projectId).then((function(_this) {
        return function(wikipages) {
          return _this.scope.wikipages = wikipages;
        };
      })(this));
    };

    WikiPagesListController.prototype.loadWikiLinks = function() {
      return this.rs.wiki.listLinks(this.scope.projectId).then((function(_this) {
        return function(wikiLinks) {
          var i, len, link, ref, selectedWikiLink;
          _this.scope.wikiLinks = wikiLinks;
          ref = _this.scope.wikiLinks;
          for (i = 0, len = ref.length; i < len; i++) {
            link = ref[i];
            link.url = _this.navUrls.resolve("project-wiki-page", {
              project: _this.scope.projectSlug,
              slug: link.href
            });
          }
          return selectedWikiLink = _.find(wikiLinks, {
            href: _this.scope.wikiSlug
          });
        };
      })(this));
    };

    WikiPagesListController.prototype.loadInitialData = function() {
      var project;
      project = this.loadProject();
      this.fillUsersAndRoles(project.members, project.roles);
      return this.q.all([this.loadWikiLinks(), this.loadWikiPages()]).then(this.checkLinksPerms.bind(this));
    };

    WikiPagesListController.prototype.checkLinksPerms = function() {
      if (this.scope.project.my_permissions.indexOf("add_wiki_link") !== -1 || (this.scope.project.my_permissions.indexOf("view_wiki_links") !== -1 && this.scope.wikiLinks.length)) {
        return this.scope.linksVisible = true;
      }
    };

    return WikiPagesListController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("WikiPagesListController", WikiPagesListController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/admin/lightboxes.coffee
 */

(function() {
  var ChangeOwnerLightboxController, ChangeOwnerLightboxDirective, LbRequestOwnershipDirective, LightboxAddMembersWarningMessageDirective, TransferProjectStartSuccessDirective, debounce, module, normalizeString, taiga;

  taiga = this.taiga;

  debounce = this.taiga.debounce;

  normalizeString = this.taiga.normalizeString;

  module = angular.module("taigaKanban");

  LightboxAddMembersWarningMessageDirective = function() {
    return {
      templateUrl: "admin/memberships-warning-message.html",
      scope: {
        project: "="
      }
    };
  };

  module.directive("tgLightboxAddMembersWarningMessage", [LightboxAddMembersWarningMessageDirective]);

  LbRequestOwnershipDirective = function(lightboxService, rs, confirmService, $translate) {
    return {
      link: function(scope, el) {
        lightboxService.open(el);
        return scope.request = function() {
          scope.loading = true;
          return rs.projects.transferRequest(scope.projectId).then(function() {
            scope.loading = false;
            lightboxService.close(el);
            return confirmService.notify("success", $translate.instant("ADMIN.PROJECT_PROFILE.REQUEST_OWNERSHIP_SUCCESS"));
          });
        };
      },
      templateUrl: "common/lightbox/lightbox-request-ownership.html"
    };
  };

  module.directive('tgLbRequestOwnership', ["lightboxService", "tgResources", "$tgConfirm", "$translate", LbRequestOwnershipDirective]);

  ChangeOwnerLightboxController = (function() {
    function ChangeOwnerLightboxController(rs1, lightboxService1, confirm, translate) {
      this.rs = rs1;
      this.lightboxService = lightboxService1;
      this.confirm = confirm;
      this.translate = translate;
      this.users = [];
      this.q = "";
      this.commentOpen = false;
    }

    ChangeOwnerLightboxController.prototype.limit = 3;

    ChangeOwnerLightboxController.prototype.filterUsers = function(user) {
      var text, username;
      username = user.full_name_display.toUpperCase();
      username = normalizeString(username);
      text = this.q.toUpperCase();
      text = normalizeString(text);
      return _.includes(username, text);
    };

    ChangeOwnerLightboxController.prototype.getUsers = function() {
      var users;
      if (!this.users.length && !this.q.length) {
        users = this.activeUsers;
      } else {
        users = this.users;
      }
      users = _.reject(users, {
        "id": this.currentOwnerId
      });
      users = _.reject(users, {
        "selected": true
      });
      this.totalUsers = _.size(users);
      return users.slice(0, this.limit);
    };

    ChangeOwnerLightboxController.prototype.userSearch = function() {
      this.users = this.activeUsers;
      this.selected = _.find(this.users, {
        "selected": true
      });
      if (this.q) {
        return this.users = _.filter(this.users, this.filterUsers.bind(this));
      }
    };

    ChangeOwnerLightboxController.prototype.selectUser = function(user) {
      this.activeUsers = _.map(this.activeUsers, function(user) {
        user.selected = false;
        return user;
      });
      user.selected = true;
      return this.userSearch();
    };

    ChangeOwnerLightboxController.prototype.submit = function() {
      this.loading = true;
      return this.rs.projects.transferStart(this.projectId, this.selected.id, this.comment).then((function(_this) {
        return function() {
          var desc, title;
          _this.loading = false;
          _this.lightboxService.closeAll();
          title = _this.translate.instant("ADMIN.PROJECT_PROFILE.CHANGE_OWNER_SUCCESS_TITLE");
          desc = _this.translate.instant("ADMIN.PROJECT_PROFILE.CHANGE_OWNER_SUCCESS_DESC");
          return _this.confirm.success(title, desc, {
            type: "svg",
            name: "icon-speak-up"
          });
        };
      })(this));
    };

    return ChangeOwnerLightboxController;

  })();

  ChangeOwnerLightboxController.$inject = ["tgResources", "lightboxService", "$tgConfirm", "$translate"];

  module.controller('ChangeOwnerLightbox', ChangeOwnerLightboxController);

  ChangeOwnerLightboxDirective = function(lightboxService, lightboxKeyboardNavigationService, $template, $compile) {
    var link;
    link = function(scope, el) {
      return lightboxService.open(el);
    };
    return {
      scope: true,
      controller: "ChangeOwnerLightbox",
      controllerAs: "vm",
      bindToController: {
        currentOwnerId: "=",
        projectId: "=",
        activeUsers: "="
      },
      templateUrl: "common/lightbox/lightbox-change-owner.html",
      link: link
    };
  };

  module.directive("tgLbChangeOwner", ["lightboxService", "lightboxKeyboardNavigationService", "$tgTemplate", "$compile", ChangeOwnerLightboxDirective]);

  TransferProjectStartSuccessDirective = function(lightboxService) {
    var link;
    link = function(scope, el) {
      scope.close = function() {
        return lightboxService.close(el);
      };
      return lightboxService.open(el);
    };
    return {
      templateUrl: "common/lightbox/lightbox-transfer-project-start-success.html",
      link: link
    };
  };

  module.directive("tgLbTransferProjectStartSuccess", ["lightboxService", TransferProjectStartSuccessDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/admin/memberships.coffee
 */

(function() {
  var MembershipsController, MembershipsDirective, MembershipsRowActionsDirective, MembershipsRowAdminCheckboxDirective, MembershipsRowAvatarDirective, MembershipsRowRoleSelectorDirective, NoMoreMembershipsExplanationDirective, bindMethods, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  bindMethods = this.taiga.bindMethods;

  module = angular.module("taigaAdmin");

  MembershipsController = (function(superClass) {
    extend(MembershipsController, superClass);

    MembershipsController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "$tgAnalytics", "tgAppMetaService", "$translate", "$tgAuth", "tgLightboxFactory", "tgErrorHandlingService", "tgProjectService"];

    function MembershipsController(scope, rootscope, repo, confirm, rs, params, q, location, navUrls, analytics, appMetaService, translate, auth, lightboxFactory1, errorHandlingService, projectService1) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.analytics = analytics;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.auth = auth;
      this.lightboxFactory = lightboxFactory1;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService1;
      bindMethods(this);
      this.scope.project = {};
      this.scope.filters = {};
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("ADMIN.MEMBERSHIPS.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
      this.scope.$on("membersform:new:success", (function(_this) {
        return function() {
          _this.loadInitialData();
          return _this.analytics.trackEvent("membership", "create", "create memberships on admin", 1);
        };
      })(this));
    }

    MembershipsController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      if (!project.i_am_admin) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.canAddUsers = project.max_memberships === null || project.max_memberships > project.total_memberships;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    MembershipsController.prototype.loadMembers = function() {
      var httpFilters;
      httpFilters = this.getUrlFilters();
      return this.rs.memberships.list(this.scope.projectId, httpFilters).then((function(_this) {
        return function(data) {
          _this.scope.memberships = _.filter(data.models, function(membership) {
            return membership.user === null || membership.is_user_active;
          });
          _.map(_this.scope.memberships, function(member) {
            if (member.is_owner) {
              return _this.scope.projectOwnerEmail = member.user_email;
            }
          });
          _this.scope.page = data.current;
          _this.scope.count = data.count;
          _this.scope.paginatedBy = data.paginatedBy;
          return data;
        };
      })(this));
    };

    MembershipsController.prototype.loadInitialData = function() {
      this.loadProject();
      return this.q.all([this.loadMembers(), this.auth.refresh()]);
    };

    MembershipsController.prototype.getUrlFilters = function() {
      var filters;
      filters = _.pick(this.location.search(), "page");
      if (!filters.page) {
        filters.page = 1;
      }
      return filters;
    };

    MembershipsController.prototype.addNewMembers = function() {
      return this.lightboxFactory.create('tg-lb-add-members', {
        "class": "lightbox lightbox-add-member",
        "project": "project"
      }, {
        "project": this.scope.project
      });
    };

    MembershipsController.prototype.showLimitUsersWarningMessage = function() {
      var icon, message, title;
      title = this.translate.instant("ADMIN.MEMBERSHIPS.LIMIT_USERS_WARNING");
      message = this.translate.instant("ADMIN.MEMBERSHIPS.LIMIT_USERS_WARNING_MESSAGE", {
        members: this.scope.project.max_memberships
      });
      icon = "/" + window._version + "/svg/icons/team-question.svg";
      return this.confirm.success(title, message, {
        name: icon,
        type: "img"
      });
    };

    return MembershipsController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  module.controller("MembershipsController", MembershipsController);

  MembershipsDirective = function($template, $compile) {
    var link, linkPagination, template;
    template = $template.get("admin/admin-membership-paginator.html", true);
    linkPagination = function($scope, $el, $attrs, $ctrl) {
      var $pagEl, afterCurrent, atBegin, atEnd, beforeCurrent, getNumPages, renderPagination;
      afterCurrent = 2;
      beforeCurrent = 4;
      atBegin = 2;
      atEnd = 2;
      $pagEl = $el.find(".memberships-paginator");
      getNumPages = function() {
        var numPages;
        numPages = $scope.count / $scope.paginatedBy;
        if (parseInt(numPages, 10) < numPages) {
          numPages = parseInt(numPages, 10) + 1;
        } else {
          numPages = parseInt(numPages, 10);
        }
        return numPages;
      };
      renderPagination = function() {
        var cpage, html, i, j, numPages, options, pages, ref;
        numPages = getNumPages();
        if (numPages <= 1) {
          $pagEl.hide();
          return;
        }
        pages = [];
        options = {};
        options.pages = pages;
        options.showPrevious = $scope.page > 1;
        options.showNext = !($scope.page === numPages);
        cpage = $scope.page;
        for (i = j = 1, ref = numPages; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          if (i === (cpage + afterCurrent) && numPages > (cpage + afterCurrent + atEnd)) {
            pages.push({
              classes: "dots",
              type: "dots"
            });
          } else if (i === (cpage - beforeCurrent) && cpage > (atBegin + beforeCurrent)) {
            pages.push({
              classes: "dots",
              type: "dots"
            });
          } else if (i > (cpage + afterCurrent) && i <= (numPages - atEnd)) {

          } else if (i < (cpage - beforeCurrent) && i > atBegin) {

          } else if (i === cpage) {
            pages.push({
              classes: "active",
              num: i,
              type: "page-active"
            });
          } else {
            pages.push({
              classes: "page",
              num: i,
              type: "page"
            });
          }
        }
        html = template(options);
        html = $compile(html)($scope);
        $pagEl.html(html);
        return $pagEl.show();
      };
      $scope.$watch("memberships", function(value) {
        if (!value) {
          return;
        }
        return renderPagination();
      });
      $el.on("click", ".memberships-paginator a.next", function(event) {
        event.preventDefault();
        return $scope.$apply(function() {
          $ctrl.selectFilter("page", $scope.page + 1);
          return $ctrl.loadMembers();
        });
      });
      $el.on("click", ".memberships-paginator a.previous", function(event) {
        event.preventDefault();
        return $scope.$apply(function() {
          $ctrl.selectFilter("page", $scope.page - 1);
          return $ctrl.loadMembers();
        });
      });
      return $el.on("click", ".memberships-paginator li.page > a", function(event) {
        var pagenum, target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        pagenum = target.data("pagenum");
        return $scope.$apply(function() {
          $ctrl.selectFilter("page", pagenum);
          return $ctrl.loadMembers();
        });
      });
    };
    link = function($scope, $el, $attrs) {
      var $ctrl;
      $ctrl = $el.controller();
      linkPagination($scope, $el, $attrs, $ctrl);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgMemberships", ["$tgTemplate", "$compile", MembershipsDirective]);

  MembershipsRowAvatarDirective = function($log, $template, $translate, $compile, avatarService) {
    var link, template;
    template = $template.get("admin/memberships-row-avatar.html", true);
    link = function($scope, $el, $attrs) {
      var member, pending, render;
      pending = $translate.instant("ADMIN.MEMBERSHIP.STATUS_PENDING");
      render = function(member) {
        var avatar, ctx, html;
        avatar = avatarService.getAvatar(member);
        ctx = {
          full_name: member.full_name ? member.full_name : "",
          email: member.user_email ? member.user_email : member.email,
          imgurl: avatar.url,
          bg: avatar.bg,
          pending: !member.is_user_active ? pending : "",
          isOwner: member.is_owner
        };
        html = template(ctx);
        html = $compile(html)($scope);
        return $el.html(html);
      };
      if ($attrs.tgMembershipsRowAvatar == null) {
        return $log.error("MembershipsRowAvatarDirective: the directive need a member");
      }
      member = $scope.$eval($attrs.tgMembershipsRowAvatar);
      render(member);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgMembershipsRowAvatar", ["$log", "$tgTemplate", '$translate', "$compile", "tgAvatarService", MembershipsRowAvatarDirective]);

  MembershipsRowAdminCheckboxDirective = function($log, $repo, $confirm, $template, $compile) {
    var link, template;
    template = $template.get("admin/admin-memberships-row-checkbox.html", true);
    link = function($scope, $el, $attrs) {
      var html, member, render;
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      if ($attrs.tgMembershipsRowAdminCheckbox == null) {
        return $log.error("MembershipsRowAdminCheckboxDirective: the directive need a member");
      }
      member = $scope.$eval($attrs.tgMembershipsRowAdminCheckbox);
      if (member.is_owner) {
        $el.find(".js-check").remove();
        return;
      }
      render = function(member) {
        var ctx, html;
        ctx = {
          inputId: "is-admin-" + member.id
        };
        html = template(ctx);
        html = $compile(html)($scope);
        return $el.html(html);
      };
      $el.on("click", ":checkbox", (function(_this) {
        return function(event) {
          var onError, onSuccess, target;
          onSuccess = function() {
            return $confirm.notify("success");
          };
          onError = function(data) {
            member.revert();
            $el.find(":checkbox").prop("checked", member.is_admin);
            return $confirm.notify("error", data.is_admin[0]);
          };
          target = angular.element(event.currentTarget);
          member.is_admin = target.prop("checked");
          return $repo.save(member).then(onSuccess, onError);
        };
      })(this));
      html = render(member);
      if (member.is_admin) {
        return $el.find(":checkbox").prop("checked", true);
      }
    };
    return {
      link: link
    };
  };

  module.directive("tgMembershipsRowAdminCheckbox", ["$log", "$tgRepo", "$tgConfirm", "$tgTemplate", "$compile", MembershipsRowAdminCheckboxDirective]);

  MembershipsRowRoleSelectorDirective = function($log, $repo, $confirm) {
    var link, template;
    template = _.template("<select>\n    <% _.each(roleList, function(role) { %>\n    <option value=\"<%- role.id %>\" <% if(selectedRole === role.id){ %>selected=\"selected\"<% } %>>\n        <%- role.name %>\n    </option>\n    <% }); %>\n</select>");
    link = function($scope, $el, $attrs) {
      var $ctrl, html, member, render;
      render = function(member) {
        var ctx, html;
        ctx = {
          roleList: $scope.project.roles,
          selectedRole: member.role
        };
        html = template(ctx);
        return $el.html(html);
      };
      if ($attrs.tgMembershipsRowRoleSelector == null) {
        return $log.error("MembershipsRowRoleSelectorDirective: the directive need a member");
      }
      $ctrl = $el.controller();
      member = $scope.$eval($attrs.tgMembershipsRowRoleSelector);
      html = render(member);
      $el.on("change", "select", (function(_this) {
        return function(event) {
          var newRole, onError, onSuccess, target;
          onSuccess = function() {
            return $confirm.notify("success");
          };
          onError = function() {
            return $confirm.notify("error");
          };
          target = angular.element(event.currentTarget);
          newRole = parseInt(target.val(), 10);
          if (member.role !== newRole) {
            member.role = newRole;
            return $repo.save(member).then(onSuccess, onError);
          }
        };
      })(this));
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgMembershipsRowRoleSelector", ["$log", "$tgRepo", "$tgConfirm", MembershipsRowRoleSelectorDirective]);

  MembershipsRowActionsDirective = function($log, $repo, $rs, $confirm, $compile, $translate, $location, $navUrls, lightboxFactory, projectService) {
    var activedTemplate, link, pendingTemplate;
    activedTemplate = "<div class=\"active\"\n     translate=\"ADMIN.MEMBERSHIP.STATUS_ACTIVE\">\n</div>\n<a class=\"delete\" href=\"\"\n   title=\"{{ 'ADMIN.MEMBERSHIP.DELETE_MEMBER' | translate }}\">\n    <tg-svg svg-icon=\"icon-trash\"></tg-svg>\n</a>";
    pendingTemplate = "<a class=\"resend js-resend\" href=\"\"\n   title=\"{{ 'ADMIN.MEMBERSHIP.RESEND' | translate }}\"\n   translate=\"ADMIN.MEMBERSHIP.RESEND\">\n</a>\n<a class=\"delete\" href=\"\"\n   title=\"{{ 'ADMIN.MEMBERSHIP.DELETE_MEMBER' | translate }}\">\n    <tg-svg svg-icon=\"icon-trash\"></tg-svg>\n</a>";
    link = function($scope, $el, $attrs) {
      var $ctrl, leaveConfirm, member, render;
      render = function(member) {
        var html;
        if (member.user) {
          html = $compile(activedTemplate)($scope);
        } else {
          html = $compile(pendingTemplate)($scope);
        }
        return $el.html(html);
      };
      if ($attrs.tgMembershipsRowActions == null) {
        return $log.error("MembershipsRowActionsDirective: the directive need a member");
      }
      $ctrl = $el.controller();
      member = $scope.$eval($attrs.tgMembershipsRowActions);
      render(member);
      $el.on("click", ".js-resend", function(event) {
        var onError, onSuccess;
        event.preventDefault();
        onSuccess = function() {
          var text;
          text = $translate.instant("ADMIN.MEMBERSHIP.SUCCESS_SEND_INVITATION", {
            email: $scope.member.email
          });
          return $confirm.notify("success", text);
        };
        onError = function() {
          var text;
          text = $translate.instant("ADMIM.MEMBERSHIP.ERROR_SEND_INVITATION");
          return $confirm.notify("error", text);
        };
        return $rs.memberships.resendInvitation($scope.member.id).then(onSuccess, onError);
      });
      leaveConfirm = function() {
        var defaultMsg, message, title;
        title = $translate.instant("ADMIN.MEMBERSHIP.DELETE_MEMBER");
        defaultMsg = $translate.instant("ADMIN.MEMBERSHIP.DEFAULT_DELETE_MESSAGE", {
          email: member.email
        });
        message = member.user ? member.full_name : defaultMsg;
        return $confirm.askOnDelete(title, message).then(function(askResponse) {
          var onError, onSuccess;
          onSuccess = (function(_this) {
            return function() {
              var text;
              askResponse.finish();
              if (member.user !== $scope.user.id) {
                if ($scope.page > 1 && ($scope.count - 1) <= $scope.paginatedBy) {
                  $ctrl.selectFilter("page", $scope.page - 1);
                }
                projectService.fetchProject().then(function() {
                  return $ctrl.loadInitialData();
                });
              } else {
                $location.path($navUrls.resolve("home"));
              }
              text = $translate.instant("ADMIN.MEMBERSHIP.SUCCESS_DELETE", {
                message: message
              });
              return $confirm.notify("success", text, null, 5000);
            };
          })(this);
          onError = (function(_this) {
            return function() {
              var text;
              askResponse.finish(false);
              text = $translate.instant("ADMIN.MEMBERSHIP.ERROR_DELETE", {
                message: message
              });
              return $confirm.notify("error", text);
            };
          })(this);
          return $repo.remove(member).then(onSuccess, onError);
        });
      };
      $el.on("click", ".delete", function(event) {
        var isCurrentUser;
        event.preventDefault();
        if ($scope.project.owner.id === member.user) {
          isCurrentUser = $scope.user.id === member.user;
          return lightboxFactory.create("tg-lightbox-leave-project-warning", {
            "class": "lightbox lightbox-leave-project-warning"
          }, {
            isCurrentUser: isCurrentUser,
            project: $scope.project
          });
        } else {
          return leaveConfirm();
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgMembershipsRowActions", ["$log", "$tgRepo", "$tgResources", "$tgConfirm", "$compile", "$translate", "$tgLocation", "$tgNavUrls", "tgLightboxFactory", "tgProjectService", MembershipsRowActionsDirective]);

  NoMoreMembershipsExplanationDirective = function() {
    return {
      templateUrl: "admin/no-more-memberships-explanation.html",
      scope: {
        project: "=",
        ownerEmail: "="
      }
    };
  };

  module.directive("tgNoMoreMembershipsExplanation", [NoMoreMembershipsExplanationDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/admin/nav.coffee
 */

(function() {
  var AdminNavigationDirective, module;

  AdminNavigationDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var section;
      section = $attrs.tgAdminNavigation;
      $el.find(".active").removeClass("active");
      $el.find("#adminmenu-" + section + " a").addClass("active");
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module = angular.module("taigaAdmin");

  module.directive("tgAdminNavigation", AdminNavigationDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/admin/project-profile.coffee
 */

(function() {
  var AdminProjectChangeOwnerDirective, AdminProjectRequestOwnershipDirective, AdminProjectRestrictionsDirective, CsvEpicDirective, CsvExporterController, CsvExporterEpicsController, CsvExporterIssuesController, CsvExporterTasksController, CsvExporterUserstoriesController, CsvIssueDirective, CsvTaskDirective, CsvUsDirective, ProjectDefaultValuesDirective, ProjectExportDirective, ProjectLogoDirective, ProjectLogoModelDirective, ProjectModulesDirective, ProjectProfileController, ProjectProfileDirective, bindOnce, debounce, groupBy, joinStr, mixOf, module, scopeDefer, taiga, toString, trim,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  scopeDefer = this.taiga.scopeDefer;

  trim = this.taiga.trim;

  toString = this.taiga.toString;

  joinStr = this.taiga.joinStr;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  module = angular.module("taigaAdmin");

  ProjectProfileController = (function(superClass) {
    extend(ProjectProfileController, superClass);

    ProjectProfileController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "tgAppMetaService", "$translate", "$tgAuth", "tgCurrentUserService", "tgErrorHandlingService", "tgProjectService", "$tgModel"];

    function ProjectProfileController(scope1, rootscope, repo, confirm, rs, params, q, location, navUrls, appMetaService, translate, tgAuth, currentUserService1, errorHandlingService, projectService1, model1) {
      var promise;
      this.scope = scope1;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.tgAuth = tgAuth;
      this.currentUserService = currentUserService1;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService1;
      this.model = model1;
      this.scope.project = {};
      this.scope.projectTags = [];
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, sectionName, title;
          sectionName = _this.translate.instant(_this.scope.sectionName);
          title = _this.translate.instant("ADMIN.PROJECT_PROFILE.PAGE_TITLE", {
            sectionName: sectionName,
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          _this.appMetaService.setAll(title, description);
          return _this.fillUsersAndRoles(_this.scope.project.members, _this.scope.project.roles);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
      this.scope.$on("project:loaded", (function(_this) {
        return function() {
          var description, sectionName, title;
          sectionName = _this.translate.instant(_this.scope.sectionName);
          title = _this.translate.instant("ADMIN.PROJECT_PROFILE.PAGE_TITLE", {
            sectionName: sectionName,
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
    }

    ProjectProfileController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      project = this.model.make_model("projects", project);
      if (!project.i_am_admin) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.epicStatusList = _.sortBy(project.epic_statuses, "order");
      this.scope.usStatusList = _.sortBy(project.us_statuses, "order");
      this.scope.pointsList = _.sortBy(project.points, "order");
      this.scope.taskStatusList = _.sortBy(project.task_statuses, "order");
      this.scope.issueTypesList = _.sortBy(project.issue_types, "order");
      this.scope.issueStatusList = _.sortBy(project.issue_statuses, "order");
      this.scope.prioritiesList = _.sortBy(project.priorities, "order");
      this.scope.severitiesList = _.sortBy(project.severities, "order");
      scopeDefer(this.scope, (function(_this) {
        return function() {
          return _this.scope.$emit('project:loaded', project);
        };
      })(this));
      this.scope.projectTags = _.map(this.scope.project.tags, (function(_this) {
        return function(it) {
          return [it, _this.scope.project.tags_colors[it]];
        };
      })(this));
      return project;
    };

    ProjectProfileController.prototype.loadInitialData = function() {
      this.loadProject();
      return this.tgAuth.refresh();
    };

    ProjectProfileController.prototype.openDeleteLightbox = function() {
      return this.rootscope.$broadcast("deletelightbox:new", this.scope.project);
    };

    ProjectProfileController.prototype.addTag = function(name, color) {
      var tags;
      tags = _.clone(this.scope.project.tags);
      tags.push(name);
      this.scope.projectTags.push([name, null]);
      return this.scope.project.tags = tags;
    };

    ProjectProfileController.prototype.deleteTag = function(tag) {
      var tags;
      tags = _.clone(this.scope.project.tags);
      _.pull(tags, tag[0]);
      _.remove(this.scope.projectTags, (function(_this) {
        return function(it) {
          return it[0] === tag[0];
        };
      })(this));
      return this.scope.project.tags = tags;
    };

    return ProjectProfileController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("ProjectProfileController", ProjectProfileController);

  ProjectProfileDirective = function($repo, $confirm, $loading, $navurls, $location, projectService, currentUserService, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var $ctrl, form, submit, submitButton;
      $ctrl = $el.controller();
      form = $el.find("form").checksley({
        "onlyOneErrorElement": true
      });
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, privacyChanged, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          privacyChanged = $scope.project.isAttributeModified("is_private");
          promise = $repo.save($scope.project);
          promise.then(function() {
            var newUrl;
            currentLoading.finish();
            if (privacyChanged && $scope.project.is_private) {
              $analytics.trackEvent("project-privacy-changed", "from-public-to-private", "Change project privacy from public to private", 1);
            } else if (privacyChanged && !$scope.project.is_private) {
              $analytics.trackEvent("project-privacy-changed", "from-private-to-public", "Change project privacy from private to public", 1);
            }
            $confirm.notify("success");
            newUrl = $navurls.resolve("project-admin-project-profile-details", {
              project: $scope.project.slug
            });
            $location.path(newUrl);
            projectService.fetchProject().then((function(_this) {
              return function() {
                return $ctrl.loadInitialData();
              };
            })(this));
            return currentUserService.loadProjects();
          });
          return promise.then(null, function(data) {
            currentLoading.finish();
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("error", data._error_message);
            }
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      return $el.on("submit", "form", submit);
    };
    return {
      link: link
    };
  };

  module.directive("tgProjectProfile", ["$tgRepo", "$tgConfirm", "$tgLoading", "$tgNavUrls", "$tgLocation", "tgProjectService", "tgCurrentUserService", "$tgAnalytics", ProjectProfileDirective]);

  ProjectDefaultValuesDirective = function($rootScope, $repo, $confirm, $loading) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, submit, submitButton;
      form = $el.find("form").checksley({
        "onlyOneErrorElement": true
      });
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          promise = $repo.save($scope.project);
          promise.then(function() {
            currentLoading.finish();
            $confirm.notify("success");
            return $rootScope.$broadcast("admin:project-default-values:updated");
          });
          return promise.then(null, function(data) {
            currentLoading.finish();
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("error", data._error_message);
            }
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      $el.on("submit", "form", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgProjectDefaultValues", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", ProjectDefaultValuesDirective]);

  ProjectModulesDirective = function($rootScope, $repo, $confirm, $loading) {
    var link;
    link = function($scope, $el, $attrs) {
      var submit;
      submit = (function(_this) {
        return function() {
          var form, promise;
          form = $el.find("form").checksley();
          form.initializeFields();
          form.reset();
          if (!form.validate()) {
            return;
          }
          promise = $repo.save($scope.project);
          promise.then(function() {
            $scope.$emit("project:loaded", $scope.project);
            $rootScope.$broadcast("admin:project-modules:updated");
            return $confirm.notify("success");
          });
          return promise.then(null, function(data) {
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("error", data._error_message);
            }
          });
        };
      })(this);
      $el.on("change", ".module-activation.module-direct-active input", function(event) {
        event.preventDefault();
        return $scope.$applyAsync(submit);
      });
      $el.on("submit", "form", function(event) {
        event.preventDefault();
        return submit();
      });
      $el.on("click", ".save", function(event) {
        event.preventDefault();
        return submit();
      });
      $el.on("keydown", ".videoconference-attributes input", function(e) {
        return e.which !== 32;
      });
      $scope.$watch("project.videoconferences", function(newVal, oldVal) {
        if ((newVal != null) && (oldVal != null) && newVal !== oldVal) {
          return $scope.project.videoconferences_extra_data = "";
        }
      });
      $scope.$watch("isVideoconferenceActivated", function(newValue, oldValue) {
        if (newValue === false) {
          $scope.project.videoconferences = null;
          $scope.project.videoconferences_extra_data = "";
          if (oldValue === true) {
            return submit();
          }
        }
      });
      return $scope.$watch("project", function(project) {
        if (project.videoconferences != null) {
          return $scope.isVideoconferenceActivated = true;
        } else {
          return $scope.isVideoconferenceActivated = false;
        }
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgProjectModules", ["$rootScope", "$tgRepo", "$tgConfirm", "$tgLoading", ProjectModulesDirective]);

  ProjectExportDirective = function($window, $rs, $confirm, $translate, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var asyn_message, buttonsEl, dump_ready_text, hideButtons, hideResult, hideSpinner, loading_msg, loading_title, resultEl, resultMessageEl, resultTitleEl, setAsyncMessage, setAsyncTitle, setLoadingMessage, setLoadingTitle, setSyncMessage, setSyncTitle, showButtons, showErrorMode, showExportResultAsyncMode, showExportResultSyncMode, showLoadingMode, showResult, showSpinner, spinnerEl, syn_message;
      buttonsEl = $el.find(".admin-project-export-buttons");
      showButtons = function() {
        return buttonsEl.removeClass("hidden");
      };
      hideButtons = function() {
        return buttonsEl.addClass("hidden");
      };
      resultEl = $el.find(".admin-project-export-result");
      showResult = function() {
        return resultEl.removeClass("hidden");
      };
      hideResult = function() {
        return resultEl.addClass("hidden");
      };
      spinnerEl = $el.find(".spin");
      showSpinner = function() {
        return spinnerEl.removeClass("hidden");
      };
      hideSpinner = function() {
        return spinnerEl.addClass("hidden");
      };
      resultTitleEl = $el.find(".result-title");
      loading_title = $translate.instant("ADMIN.PROJECT_EXPORT.LOADING_TITLE");
      loading_msg = $translate.instant("ADMIN.PROJECT_EXPORT.LOADING_MESSAGE");
      dump_ready_text = function() {
        return resultTitleEl.html($translate.instant("ADMIN.PROJECT_EXPORT.DUMP_READY"));
      };
      asyn_message = function() {
        return resultTitleEl.html($translate.instant("ADMIN.PROJECT_EXPORT.ASYNC_MESSAGE"));
      };
      syn_message = function(url) {
        return resultTitleEl.html($translate.instant("ADMIN.PROJECT_EXPORT.SYNC_MESSAGE", {
          url: url
        }));
      };
      setLoadingTitle = function() {
        return resultTitleEl.html(loading_title);
      };
      setAsyncTitle = function() {
        return resultTitleEl.html(loading_msg);
      };
      setSyncTitle = function() {
        return resultTitleEl.html(dump_ready_text);
      };
      resultMessageEl = $el.find(".result-message ");
      setLoadingMessage = function() {
        return resultMessageEl.html(loading_msg);
      };
      setAsyncMessage = function() {
        return resultMessageEl.html(asyn_message);
      };
      setSyncMessage = function(url) {
        return resultMessageEl.html(syn_message(url));
      };
      showLoadingMode = function() {
        showSpinner();
        setLoadingTitle();
        setLoadingMessage();
        hideButtons();
        return showResult();
      };
      showExportResultAsyncMode = function() {
        hideSpinner();
        setAsyncTitle();
        return setAsyncMessage();
      };
      showExportResultSyncMode = function(url) {
        hideSpinner();
        setSyncTitle();
        return setSyncMessage(url);
      };
      showErrorMode = function() {
        hideSpinner();
        hideResult();
        return showButtons();
      };
      return $el.on("click", "a.button-export", debounce(2000, (function(_this) {
        return function(event) {
          var onError, onSuccess;
          event.preventDefault();
          onSuccess = function(result) {
            var dumpUrl;
            $analytics.trackEvent("exporter", "export-project", "Exported project", 1);
            if (result.status === 202) {
              return showExportResultAsyncMode();
            } else {
              dumpUrl = result.data.url;
              showExportResultSyncMode(dumpUrl);
              return $window.open(dumpUrl, "_blank");
            }
          };
          onError = function(result) {
            var errorMsg, ref;
            showErrorMode();
            errorMsg = $translate.instant("ADMIN.PROJECT_EXPORT.ERROR");
            if (result.status === 429) {
              errorMsg = $translate.instant("ADMIN.PROJECT_EXPORT.ERROR_BUSY");
            } else if ((ref = result.data) != null ? ref._error_message : void 0) {
              errorMsg = $translate.instant("ADMIN.PROJECT_EXPORT.ERROR_BUSY", {
                message: result.data._error_message
              });
            }
            return $confirm.notify("error", errorMsg);
          };
          showLoadingMode();
          return $rs.projects["export"]($scope.projectId).then(onSuccess, onError);
        };
      })(this)));
    };
    return {
      link: link
    };
  };

  module.directive("tgProjectExport", ["$window", "$tgResources", "$tgConfirm", "$translate", "$tgAnalytics", ProjectExportDirective]);

  CsvExporterController = (function(superClass) {
    extend(CsvExporterController, superClass);

    CsvExporterController.$inject = ["$scope", "$rootScope", "$tgUrls", "$tgConfirm", "$tgResources", "$translate"];

    function CsvExporterController(scope1, rootscope, urls, confirm, rs, translate) {
      this.scope = scope1;
      this.rootscope = rootscope;
      this.urls = urls;
      this.confirm = confirm;
      this.rs = rs;
      this.translate = translate;
      this._deleteUuid = bind(this._deleteUuid, this);
      this._generateUuid = bind(this._generateUuid, this);
      this.setCsvUuid = bind(this.setCsvUuid, this);
      this.rootscope.$on("project:loaded", this.setCsvUuid);
      this.scope.$watch("csvUuid", (function(_this) {
        return function(value) {
          if (value) {
            return _this.scope.csvUrl = _this.urls.resolveAbsolute(_this.type + "-csv", value);
          } else {
            return _this.scope.csvUrl = "";
          }
        };
      })(this));
    }

    CsvExporterController.prototype.setCsvUuid = function() {
      return this.scope.csvUuid = this.scope.project[this.type + "_csv_uuid"];
    };

    CsvExporterController.prototype._generateUuid = function(response) {
      var promise;
      if (response == null) {
        response = null;
      }
      promise = this.rs.projects["regenerate_" + this.type + "_csv_uuid"](this.scope.projectId);
      promise.then((function(_this) {
        return function(data) {
          var ref;
          return _this.scope.csvUuid = (ref = data.data) != null ? ref.uuid : void 0;
        };
      })(this));
      promise.then(null, (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this));
      promise["finally"](function() {
        if (response) {
          return response.finish();
        }
      });
      return promise;
    };

    CsvExporterController.prototype._deleteUuid = function(response) {
      var promise;
      if (response == null) {
        response = null;
      }
      promise = this.rs.projects["delete_" + this.type + "_csv_uuid"](this.scope.projectId);
      promise.then((function(_this) {
        return function(data) {
          var ref;
          return _this.scope.csvUuid = (ref = data.data) != null ? ref.uuid : void 0;
        };
      })(this));
      promise.then(null, (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this));
      promise["finally"](function() {
        if (response) {
          return response.finish();
        }
      });
      return promise;
    };

    CsvExporterController.prototype.regenerateUuid = function() {
      var subtitle, title;
      if (this.scope.csvUuid) {
        title = this.translate.instant("ADMIN.REPORTS.REGENERATE_TITLE");
        subtitle = this.translate.instant("ADMIN.REPORTS.REGENERATE_SUBTITLE");
        return this.confirm.ask(title, subtitle).then(this._generateUuid);
      } else {
        return this._generateUuid();
      }
    };

    CsvExporterController.prototype.deleteUuid = function() {
      var subtitle, title;
      if (this.scope.csvUuid) {
        title = this.translate.instant("ADMIN.REPORTS.DELETE_TITLE");
        subtitle = this.translate.instant("ADMIN.REPORTS.DELETE_SUBTITLE");
        return this.confirm.ask(title, subtitle).then(this._deleteUuid);
      } else {
        return this._deleteUuid();
      }
    };

    return CsvExporterController;

  })(taiga.Controller);

  CsvExporterEpicsController = (function(superClass) {
    extend(CsvExporterEpicsController, superClass);

    function CsvExporterEpicsController() {
      return CsvExporterEpicsController.__super__.constructor.apply(this, arguments);
    }

    CsvExporterEpicsController.prototype.type = "epics";

    return CsvExporterEpicsController;

  })(CsvExporterController);

  CsvExporterUserstoriesController = (function(superClass) {
    extend(CsvExporterUserstoriesController, superClass);

    function CsvExporterUserstoriesController() {
      return CsvExporterUserstoriesController.__super__.constructor.apply(this, arguments);
    }

    CsvExporterUserstoriesController.prototype.type = "userstories";

    return CsvExporterUserstoriesController;

  })(CsvExporterController);

  CsvExporterTasksController = (function(superClass) {
    extend(CsvExporterTasksController, superClass);

    function CsvExporterTasksController() {
      return CsvExporterTasksController.__super__.constructor.apply(this, arguments);
    }

    CsvExporterTasksController.prototype.type = "tasks";

    return CsvExporterTasksController;

  })(CsvExporterController);

  CsvExporterIssuesController = (function(superClass) {
    extend(CsvExporterIssuesController, superClass);

    function CsvExporterIssuesController() {
      return CsvExporterIssuesController.__super__.constructor.apply(this, arguments);
    }

    CsvExporterIssuesController.prototype.type = "issues";

    return CsvExporterIssuesController;

  })(CsvExporterController);

  module.controller("CsvExporterEpicsController", CsvExporterEpicsController);

  module.controller("CsvExporterUserstoriesController", CsvExporterUserstoriesController);

  module.controller("CsvExporterTasksController", CsvExporterTasksController);

  module.controller("CsvExporterIssuesController", CsvExporterIssuesController);

  CsvEpicDirective = function($translate) {
    var link;
    link = function($scope) {
      return $scope.sectionTitle = "ADMIN.CSV.SECTION_TITLE_EPIC";
    };
    return {
      controller: "CsvExporterEpicsController",
      controllerAs: "ctrl",
      templateUrl: "admin/project-csv.html",
      link: link,
      scope: true
    };
  };

  module.directive("tgCsvEpic", ["$translate", CsvEpicDirective]);

  CsvUsDirective = function($translate) {
    var link;
    link = function($scope) {
      return $scope.sectionTitle = "ADMIN.CSV.SECTION_TITLE_US";
    };
    return {
      controller: "CsvExporterUserstoriesController",
      controllerAs: "ctrl",
      templateUrl: "admin/project-csv.html",
      link: link,
      scope: true
    };
  };

  module.directive("tgCsvUs", ["$translate", CsvUsDirective]);

  CsvTaskDirective = function($translate) {
    var link;
    link = function($scope) {
      return $scope.sectionTitle = "ADMIN.CSV.SECTION_TITLE_TASK";
    };
    return {
      controller: "CsvExporterTasksController",
      controllerAs: "ctrl",
      templateUrl: "admin/project-csv.html",
      link: link,
      scope: true
    };
  };

  module.directive("tgCsvTask", ["$translate", CsvTaskDirective]);

  CsvIssueDirective = function($translate) {
    var link;
    link = function($scope) {
      return $scope.sectionTitle = "ADMIN.CSV.SECTION_TITLE_ISSUE";
    };
    return {
      controller: "CsvExporterIssuesController",
      controllerAs: "ctrl",
      templateUrl: "admin/project-csv.html",
      link: link,
      scope: true
    };
  };

  module.directive("tgCsvIssue", ["$translate", CsvIssueDirective]);

  ProjectLogoDirective = function($auth, $model, $rs, $confirm) {
    var link;
    link = function($scope, $el, $attrs) {
      var onError, onSuccess, showSizeInfo;
      showSizeInfo = function() {
        return $el.find(".size-info").addClass("active");
      };
      onSuccess = function(response) {
        var project;
        project = $model.make_model("projects", response.data);
        $scope.project = project;
        $el.find('.loading-overlay').removeClass('active');
        return $confirm.notify('success');
      };
      onError = function(response) {
        if (response.status === 413) {
          showSizeInfo();
        }
        $el.find('.loading-overlay').removeClass('active');
        return $confirm.notify('error', response.data._error_message);
      };
      $el.on("click", ".js-change-logo", function() {
        return $el.find("#logo-field").click();
      });
      $el.on("change", "#logo-field", function(event) {
        if ($scope.logoAttachment) {
          $el.find('.loading-overlay').addClass("active");
          return $rs.projects.changeLogo($scope.project.id, $scope.logoAttachment).then(onSuccess, onError);
        }
      });
      $el.on("click", "a.js-use-default-logo", function(event) {
        $el.find('.loading-overlay').addClass("active");
        return $rs.projects.removeLogo($scope.project.id).then(onSuccess, onError);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgProjectLogo", ["$tgAuth", "$tgModel", "$tgResources", "$tgConfirm", ProjectLogoDirective]);

  ProjectLogoModelDirective = function($parse) {
    var link;
    link = function($scope, $el, $attrs) {
      var model, modelSetter;
      model = $parse($attrs.tgProjectLogoModel);
      modelSetter = model.assign;
      return $el.bind('change', function() {
        return $scope.$apply(function() {
          return modelSetter($scope, $el[0].files[0]);
        });
      });
    };
    return {
      link: link
    };
  };

  module.directive('tgProjectLogoModel', ['$parse', ProjectLogoModelDirective]);

  AdminProjectRestrictionsDirective = function() {
    return {
      scope: {
        "project": "="
      },
      templateUrl: "admin/admin-project-restrictions.html"
    };
  };

  module.directive('tgAdminProjectRestrictions', [AdminProjectRestrictionsDirective]);

  AdminProjectRequestOwnershipDirective = function(lightboxFactory) {
    return {
      link: function(scope) {
        return scope.requestOwnership = function() {
          return lightboxFactory.create("tg-lb-request-ownership", {
            "class": "lightbox lightbox-request-ownership"
          }, {
            projectId: scope.projectId
          });
        };
      },
      scope: {
        "projectId": "=",
        "owner": "="
      },
      templateUrl: "admin/admin-project-request-ownership.html"
    };
  };

  module.directive('tgAdminProjectRequestOwnership', ["tgLightboxFactory", AdminProjectRequestOwnershipDirective]);

  AdminProjectChangeOwnerDirective = function(lightboxFactory) {
    return {
      link: function(scope) {
        return scope.changeOwner = function() {
          return lightboxFactory.create("tg-lb-change-owner", {
            "class": "lightbox lightbox-select-user",
            "project-id": "projectId",
            "active-users": "activeUsers",
            "current-owner-id": "currentOwnerId"
          }, {
            projectId: scope.projectId,
            activeUsers: scope.activeUsers,
            currentOwnerId: scope.owner.id,
            members: scope.members
          });
        };
      },
      scope: {
        "activeUsers": "=",
        "projectId": "=",
        "owner": "=",
        "members": "="
      },
      templateUrl: "admin/admin-project-change-owner.html"
    };
  };

  module.directive('tgAdminProjectChangeOwner', ["tgLightboxFactory", AdminProjectChangeOwnerDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/admin/project-values.coffee
 */

(function() {
  var CHECKBOX_TYPE, ColorSelectionDirective, DATE_TYPE, DROPDOWN_TYPE, MULTILINE_TYPE, NUMBER_TYPE, ProjectCustomAttributesController, ProjectCustomAttributesDirective, ProjectDueDatesValues, ProjectDueDatesValuesController, ProjectTagsController, ProjectTagsDirective, ProjectValuesController, ProjectValuesDirective, ProjectValuesSectionController, RICHTEXT_TYPE, TEXT_TYPE, TYPE_CHOICES, URL_TYPE, bindOnce, debounce, getDefaulColorList, groupBy, joinStr, mixOf, module, taiga, toString, trim,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  trim = this.taiga.trim;

  toString = this.taiga.toString;

  joinStr = this.taiga.joinStr;

  groupBy = this.taiga.groupBy;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  getDefaulColorList = this.taiga.getDefaulColorList;

  module = angular.module("taigaAdmin");

  ProjectValuesSectionController = (function(superClass) {
    extend(ProjectValuesSectionController, superClass);

    ProjectValuesSectionController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "tgAppMetaService", "$translate", "tgErrorHandlingService", "tgProjectService"];

    function ProjectValuesSectionController(scope, rootscope, repo, confirm, rs, params, q, location, navUrls, appMetaService, translate, errorHandlingService, projectService1) {
      var description, sectionName, title;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService1;
      this.scope.project = {};
      this.loadInitialData();
      sectionName = this.translate.instant(this.scope.sectionName);
      title = this.translate.instant("ADMIN.PROJECT_VALUES.PAGE_TITLE", {
        "sectionName": sectionName,
        "projectName": this.scope.project.name
      });
      description = this.scope.project.description;
      this.appMetaService.setAll(title, description);
    }

    ProjectValuesSectionController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      if (!project.i_am_admin) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    ProjectValuesSectionController.prototype.loadInitialData = function() {
      var promise;
      promise = this.loadProject();
      return promise;
    };

    return ProjectValuesSectionController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("ProjectValuesSectionController", ProjectValuesSectionController);

  ProjectValuesController = (function(superClass) {
    extend(ProjectValuesController, superClass);

    ProjectValuesController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources"];

    function ProjectValuesController(scope, rootscope, repo, confirm, rs) {
      var unwatch;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.moveValue = bind(this.moveValue, this);
      this.loadValues = bind(this.loadValues, this);
      this.scope.$on("admin:project-values:move", this.moveValue);
      unwatch = this.scope.$watch("resource", (function(_this) {
        return function(resource) {
          if (resource) {
            _this.loadValues();
            return unwatch();
          }
        };
      })(this));
    }

    ProjectValuesController.prototype.loadValues = function() {
      return this.rs[this.scope.resource].listValues(this.scope.projectId, this.scope.type).then((function(_this) {
        return function(values) {
          if (values.length) {
            _this.scope.values = values;
            _this.scope.maxValueOrder = _.maxBy(values, "order").order;
          }
          return values;
        };
      })(this));
    };

    ProjectValuesController.prototype.moveValue = function(ctx, itemValue, itemIndex) {
      var r, values;
      values = this.scope.values;
      r = values.indexOf(itemValue);
      values.splice(r, 1);
      values.splice(itemIndex, 0, itemValue);
      _.each(values, function(value, index) {
        return value.order = index;
      });
      return this.repo.saveAll(values).then((function(_this) {
        return function() {
          return _this.rootscope.$broadcast("admin:project-values:updated");
        };
      })(this));
    };

    return ProjectValuesController;

  })(taiga.Controller);

  module.controller("ProjectValuesController", ProjectValuesController);

  ProjectDueDatesValuesController = (function(superClass) {
    extend(ProjectDueDatesValuesController, superClass);

    function ProjectDueDatesValuesController() {
      this.displayValues = bind(this.displayValues, this);
      this.createDefaultValues = bind(this.createDefaultValues, this);
      this.loadValues = bind(this.loadValues, this);
      return ProjectDueDatesValuesController.__super__.constructor.apply(this, arguments);
    }

    ProjectDueDatesValuesController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources"];

    ProjectDueDatesValuesController.prototype.loadValues = function() {
      return this.rs[this.scope.resource].listValues(this.scope.projectId, this.scope.type).then((function(_this) {
        return function(values) {
          if (values.length) {
            _this.scope.maxValueOrder = _.maxBy(values, "order").order;
            _this.displayValues(values);
          } else {
            _this.createDefaultValues();
          }
          return values;
        };
      })(this));
    };

    ProjectDueDatesValuesController.prototype.createDefaultValues = function() {
      if (this.rs[this.scope.resource].createDefaultValues == null) {
        return;
      }
      return this.rs[this.scope.resource].createDefaultValues(this.scope.projectId, this.scope.type).then((function(_this) {
        return function(response) {
          var values;
          _this.rootscope.$broadcast("admin:project-values:updated");
          values = response.data;
          if (values.length) {
            _this.scope.maxValueOrder = _.maxBy(values, "order").order;
            _this.displayValues(values);
          }
          return values;
        };
      })(this));
    };

    ProjectDueDatesValuesController.prototype.displayValues = function(values) {
      _.each(values, function(value, index) {
        value.days_to_due_abs = value.days_to_due !== null ? Math.abs(value.days_to_due) : null;
        return value.sign = value.days_to_due >= 0 ? 1 : -1;
      });
      return this.scope.values = values;
    };

    return ProjectDueDatesValuesController;

  })(ProjectValuesController);

  module.controller("ProjectDueDatesValuesController", ProjectDueDatesValuesController);

  ProjectValuesDirective = function($log, $repo, $confirm, $location, animationFrame, $translate, $rootscope, projectService) {
    var link, linkDragAndDrop, linkValue;
    linkDragAndDrop = function($scope, $el, $attrs) {
      var drake, itemEl, newParentScope, oldParentScope, scroll, tdom;
      oldParentScope = null;
      newParentScope = null;
      itemEl = null;
      tdom = $el.find(".sortable");
      drake = dragula([tdom[0]], {
        direction: 'vertical',
        copySortSource: false,
        copy: false,
        mirrorContainer: tdom[0],
        moves: function(item) {
          return $(item).is('div[tg-bind-scope]');
        }
      });
      drake.on('dragend', function(item) {
        var itemIndex, itemValue;
        itemEl = $(item);
        itemValue = itemEl.scope().value;
        itemIndex = itemEl.index();
        return $scope.$broadcast("admin:project-values:move", itemValue, itemIndex);
      });
      scroll = autoScroll(window, {
        margin: 20,
        pixels: 30,
        scrollWhenOutside: true,
        autoScroll: function() {
          return this.down && drake.dragging;
        }
      });
      return $scope.$on("$destroy", function() {
        $el.off();
        return drake.destroy();
      });
    };
    linkValue = function($scope, $el, $attrs) {
      var $ctrl, cancel, goToBottomList, initializeNewValue, initializeTextTranslations, objName, saveNewValue, saveValue, valueType;
      $ctrl = $el.controller();
      valueType = $attrs.type;
      objName = $attrs.objname;
      initializeNewValue = function() {
        return $scope.newValue = {
          "name": "",
          "is_closed": false,
          "is_archived": false
        };
      };
      initializeTextTranslations = function() {
        return $scope.addNewElementText = $translate.instant("ADMIN.PROJECT_VALUES_" + (objName.toUpperCase()) + ".ACTION_ADD");
      };
      initializeNewValue();
      initializeTextTranslations();
      $rootscope.$on("$translateChangeEnd", function() {
        return $scope.$evalAsync(initializeTextTranslations);
      });
      goToBottomList = (function(_this) {
        return function(focus) {
          var table;
          if (focus == null) {
            focus = false;
          }
          table = $el.find(".table-main");
          $(document.body).scrollTop(table.offset().top + table.height());
          if (focus) {
            return $el.find(".new-value input:visible").first().focus();
          }
        };
      })(this);
      saveValue = function(target) {
        var form, formEl, promise, value;
        formEl = target.parents("form");
        form = formEl.checksley();
        if (!form.validate()) {
          return;
        }
        value = formEl.scope().value;
        promise = $repo.save(value);
        promise.then(function() {
          var row;
          row = target.parents(".row.table-main");
          row.addClass("hidden");
          row.siblings(".visualization").removeClass('hidden');
          $rootscope.$broadcast("admin:project-values:updated");
          return projectService.fetchProject();
        });
        return promise.then(null, function(data) {
          return form.setErrors(data);
        });
      };
      saveNewValue = function(target) {
        var form, formEl, promise;
        formEl = target.parents("form");
        form = formEl.checksley();
        if (!form.validate()) {
          return;
        }
        $scope.newValue.project = $scope.project.id;
        $scope.newValue.order = $scope.maxValueOrder ? $scope.maxValueOrder + 1 : 1;
        promise = $repo.create(valueType, $scope.newValue);
        promise.then(function(data) {
          target.addClass("hidden");
          $scope.values.push(data);
          $scope.maxValueOrder = data.order;
          initializeNewValue();
          return $rootscope.$broadcast("admin:project-values:updated");
        });
        return promise.then(null, function(data) {
          return form.setErrors(data);
        });
      };
      cancel = function(target) {
        var formEl, row, value;
        row = target.parents(".row.table-main");
        formEl = target.parents("form");
        value = formEl.scope().value;
        return $scope.$apply(function() {
          row.addClass("hidden");
          value.revert();
          return row.siblings(".visualization").removeClass('hidden');
        });
      };
      $el.on("click", ".show-add-new", function(event) {
        event.preventDefault();
        $el.find(".new-value").removeClass('hidden');
        return goToBottomList(true);
      });
      $el.on("click", ".add-new", debounce(2000, function(event) {
        var target;
        event.preventDefault();
        target = $el.find(".new-value");
        return saveNewValue(target);
      }));
      $el.on("click", ".delete-new", function(event) {
        event.preventDefault();
        $el.find(".new-value").addClass("hidden");
        return initializeNewValue();
      });
      $el.on("click", ".edit-value", function(event) {
        var editionRow, row, target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        row = target.parents(".row.table-main");
        row.addClass("hidden");
        editionRow = row.siblings(".edition");
        editionRow.removeClass('hidden');
        return editionRow.find('input:visible').first().focus().select();
      });
      $el.on("keyup", ".new-value input", function(event) {
        var target;
        if (event.keyCode === 13) {
          target = $el.find(".new-value");
          return saveNewValue(target);
        } else if (event.keyCode === 27) {
          $el.find(".new-value").addClass("hidden");
          return initializeNewValue();
        }
      });
      $el.on("click", ".save", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        return saveValue(target);
      });
      $el.on("click", ".cancel", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        return cancel(target);
      });
      return $el.on("click", ".delete-value", function(event) {
        var choices, formEl, subtitle, target, text, title, value;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        formEl = target.parents("form");
        value = formEl.scope().value;
        choices = {};
        _.each($scope.values, function(option) {
          if (value.id !== option.id) {
            return choices[option.id] = option.name;
          }
        });
        subtitle = value.name;
        if (_.keys(choices).length === 0) {
          return $confirm.error($translate.instant("ADMIN.PROJECT_VALUES.ERROR_DELETE_ALL"));
        }
        title = $translate.instant("ADMIN.COMMON.TITLE_ACTION_DELETE_VALUE");
        text = $translate.instant("ADMIN.PROJECT_VALUES.REPLACEMENT");
        return $confirm.askChoice(title, subtitle, choices, text).then(function(response) {
          var onError, onSucces;
          onSucces = function() {
            return $ctrl.loadValues()["finally"](function() {
              $rootscope.$broadcast("admin:project-values:updated");
              return response.finish();
            });
          };
          onError = function() {
            return $confirm.notify("error");
          };
          return $repo.remove(value, {
            "moveTo": response.selected
          }).then(onSucces, onError);
        });
      });
    };
    link = function($scope, $el, $attrs) {
      linkDragAndDrop($scope, $el, $attrs);
      linkValue($scope, $el, $attrs);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgProjectValues", ["$log", "$tgRepo", "$tgConfirm", "$tgLocation", "animationFrame", "$translate", "$rootScope", "tgProjectService", ProjectValuesDirective]);

  ProjectDueDatesValues = function($log, $repo, $confirm, $location, animationFrame, $translate, $rootscope, projectService) {
    var linkDueDateStatusValue, parentDirective;
    parentDirective = ProjectValuesDirective($log, $repo, $confirm, $location, animationFrame, $translate, $rootscope, projectService);
    linkDueDateStatusValue = function($scope, $el, $attrs, $ctrl) {
      var _setDaysToDue, _valueFromEventTarget, initializeNewValue, saveNewValue, valueType;
      $ctrl = $el.controller();
      valueType = $attrs.type;
      initializeNewValue = function() {
        return $scope.newValue = {
          "name": "",
          "days_to_due": 0,
          "sign": 1
        };
      };
      initializeNewValue();
      _setDaysToDue = function(value) {
        return value.days_to_due = value.days_to_due_abs * value.sign;
      };
      _valueFromEventTarget = function(event) {
        var formEl, row, target;
        target = angular.element(event.currentTarget);
        row = target.parents(".row.table-main");
        formEl = target.parents("form");
        if (!formEl.scope().value) {
          return formEl.scope().newValue;
        } else {
          return formEl.scope().value;
        }
      };
      saveNewValue = function(target) {
        var form, formEl, promise;
        formEl = target.parents("form");
        form = formEl.checksley();
        if (!form.validate()) {
          return;
        }
        $scope.newValue.project = $scope.project.id;
        $scope.newValue.order = $scope.maxValueOrder ? $scope.maxValueOrder + 1 : 1;
        promise = $repo.create(valueType, $scope.newValue);
        promise.then(function(data) {
          target.addClass("hidden");
          data.sign = $scope.newValue.sign;
          data.days_to_due_abs = $scope.newValue.days_to_due_abs;
          $scope.values.push(data);
          $rootscope.$broadcast("admin:project-values:updated");
          return initializeNewValue();
        });
        return promise.then(null, function(data) {
          return form.setErrors(data);
        });
      };
      $el.on("input", ".days-to-due-abs", function(event) {
        var value;
        event.preventDefault();
        value = _valueFromEventTarget(event);
        return $scope.$apply(function() {
          return _setDaysToDue(value);
        });
      });
      $el.on("click", ".days-to-due-sign", function(event) {
        var value;
        event.preventDefault();
        value = _valueFromEventTarget(event);
        return $scope.$apply(function() {
          value.sign = value.sign * -1;
          return _setDaysToDue(value);
        });
      });
      $el.on("click", ".add-new-due-date", debounce(2000, function(event) {
        var target;
        event.preventDefault();
        target = $el.find(".new-value");
        return saveNewValue(target);
      }));
      return $el.on("click", ".delete-due-date", function(event) {
        var formEl, subtitle, target, title, value;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        formEl = target.parents("form");
        value = formEl.scope().value;
        title = $translate.instant("LIGHTBOX.ADMIN_DUE_DATES.TITLE_ACTION_DELETE_DUE_DATE");
        subtitle = $translate.instant("LIGHTBOX.ADMIN_DUE_DATES.SUBTITLE_ACTION_DELETE_DUE_DATE", {
          due_date_status_name: value.name
        });
        return $confirm.ask(title, subtitle).then(function(response) {
          var onError, onSucces;
          onSucces = function() {
            return $ctrl.loadValues()["finally"](function() {
              $rootscope.$broadcast("admin:project-values:updated");
              return response.finish();
            });
          };
          onError = function() {
            return $confirm.notify("error");
          };
          return $repo.remove(value).then(onSucces, onError);
        });
      });
    };
    return {
      link: function($scope, $el, $attrs) {
        parentDirective.link($scope, $el, $attrs);
        return linkDueDateStatusValue($scope, $el, $attrs);
      }
    };
  };

  module.directive("tgProjectDueDatesValues", ["$log", "$tgRepo", "$tgConfirm", "$tgLocation", "animationFrame", "$translate", "$rootScope", "tgProjectService", ProjectDueDatesValues]);

  ColorSelectionDirective = function() {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var $ctrl;
      $scope.colorList = getDefaulColorList();
      $scope.allowEmpty = false;
      if ($attrs.tgAllowEmpty) {
        $scope.allowEmpty = true;
      }
      $ctrl = $el.controller();
      $scope.$watch($attrs.ngModel, function(element) {
        return $scope.color = element.color;
      });
      $el.on("click", ".current-color", function(event) {
        var body, target;
        event.preventDefault();
        event.stopPropagation();
        target = angular.element(event.currentTarget);
        $(".select-color").hide();
        target.siblings(".select-color").show();
        body = angular.element("body");
        return body.on("click", (function(_this) {
          return function(event) {
            if (angular.element(event.target).parent(".select-color").length === 0) {
              $el.find(".select-color").hide();
              return body.unbind("click");
            }
          };
        })(this));
      });
      $el.on("click", ".select-color .color", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        $scope.$apply(function() {
          return $model.$modelValue.color = target.data("color");
        });
        return $el.find(".select-color").hide();
      });
      $el.on("click", ".select-color .selected-color", function(event) {
        event.preventDefault();
        $scope.$apply(function() {
          return $model.$modelValue.color = $scope.color;
        });
        return $el.find(".select-color").hide();
      });
      $el.on("keyup", "input", function(event) {
        event.stopPropagation();
        if (event.keyCode === 13) {
          $scope.$apply(function() {
            return $model.$modelValue.color = $scope.color;
          });
          return $el.find(".select-color").hide();
        } else if (event.keyCode === 27) {
          return $el.find(".select-color").hide();
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      require: "ngModel"
    };
  };

  module.directive("tgColorSelection", ColorSelectionDirective);

  TEXT_TYPE = "text";

  MULTILINE_TYPE = "multiline";

  RICHTEXT_TYPE = "richtext";

  DATE_TYPE = "date";

  URL_TYPE = "url";

  DROPDOWN_TYPE = "dropdown";

  CHECKBOX_TYPE = "checkbox";

  NUMBER_TYPE = "number";

  TYPE_CHOICES = [
    {
      key: TEXT_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_TEXT"
    }, {
      key: MULTILINE_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_MULTI"
    }, {
      key: RICHTEXT_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_RICHTEXT"
    }, {
      key: DATE_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_DATE"
    }, {
      key: URL_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_URL"
    }, {
      key: DROPDOWN_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_DROPDOWN"
    }, {
      key: CHECKBOX_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_CHECKBOX"
    }, {
      key: NUMBER_TYPE,
      name: "ADMIN.CUSTOM_FIELDS.FIELD_TYPE_NUMBER"
    }
  ];

  ProjectCustomAttributesController = (function(superClass) {
    extend(ProjectCustomAttributesController, superClass);

    ProjectCustomAttributesController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "tgAppMetaService", "$translate", "tgProjectService"];

    function ProjectCustomAttributesController(scope, rootscope, repo, rs, params, q, location, navUrls, appMetaService, translate, projectService1) {
      var description, sectionName, title;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.projectService = projectService1;
      this.moveCustomAttributes = bind(this.moveCustomAttributes, this);
      this.deleteCustomAttribute = bind(this.deleteCustomAttribute, this);
      this.saveCustomAttribute = bind(this.saveCustomAttribute, this);
      this.createCustomAttribute = bind(this.createCustomAttribute, this);
      this.loadCustomAttributes = bind(this.loadCustomAttributes, this);
      this._onCustomAttributesModified = bind(this._onCustomAttributesModified, this);
      this.scope.TYPE_CHOICES = TYPE_CHOICES;
      this.scope.project = this.projectService.project.toJS();
      this.scope.projectId = this.scope.project.id;
      sectionName = this.translate.instant(this.scope.sectionName);
      title = this.translate.instant("ADMIN.CUSTOM_ATTRIBUTES.PAGE_TITLE", {
        "sectionName": sectionName,
        "projectName": this.scope.project.name
      });
      description = this.scope.project.description;
      this.appMetaService.setAll(title, description);
      this.scope.init = (function(_this) {
        return function(type) {
          _this.scope.type = type;
          return _this.loadCustomAttributes();
        };
      })(this);
    }

    ProjectCustomAttributesController.prototype._parseAttributesExtra = function() {
      return this.scope.customAttributes = _.map(this.scope.customAttributes, (function(_this) {
        return function(x) {
          return _this._parseAttributeExtra(x);
        };
      })(this));
    };

    ProjectCustomAttributesController.prototype._parseAttributeExtra = function(attr) {
      if (attr.type === 'dropdown' && !attr.extra) {
        attr.extra = [''];
      }
      return attr;
    };

    ProjectCustomAttributesController.prototype._onCustomAttributesModified = function() {
      return this.rootscope.$broadcast("admin:project-custom-attributes:updated");
    };

    ProjectCustomAttributesController.prototype.loadCustomAttributes = function() {
      return this.rs.customAttributes[this.scope.type].list(this.scope.projectId).then((function(_this) {
        return function(customAttributes) {
          var ref;
          _this.scope.customAttributes = customAttributes;
          _this.scope.maxOrder = (ref = _.maxBy(customAttributes, "order")) != null ? ref.order : void 0;
          _this._parseAttributesExtra();
          return customAttributes;
        };
      })(this));
    };

    ProjectCustomAttributesController.prototype.createCustomAttribute = function(attrValues) {
      return this.repo.create("custom-attributes/" + this.scope.type, attrValues).then((function(_this) {
        return function() {
          return _this._onCustomAttributesModified();
        };
      })(this));
    };

    ProjectCustomAttributesController.prototype.saveCustomAttribute = function(attrModel) {
      return this.repo.save(attrModel).then((function(_this) {
        return function() {
          return _this._onCustomAttributesModified();
        };
      })(this));
    };

    ProjectCustomAttributesController.prototype.deleteCustomAttribute = function(attrModel) {
      return this.repo.remove(attrModel).then((function(_this) {
        return function() {
          return _this._onCustomAttributesModified();
        };
      })(this));
    };

    ProjectCustomAttributesController.prototype.moveCustomAttributes = function(attrModel, newIndex) {
      var customAttributes, r;
      customAttributes = this.scope.customAttributes;
      r = customAttributes.indexOf(attrModel);
      customAttributes.splice(r, 1);
      customAttributes.splice(newIndex, 0, attrModel);
      _.each(customAttributes, function(val, idx) {
        return val.order = idx;
      });
      return this.repo.saveAll(customAttributes).then((function(_this) {
        return function() {
          return _this._onCustomAttributesModified();
        };
      })(this));
    };

    return ProjectCustomAttributesController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("ProjectCustomAttributesController", ProjectCustomAttributesController);

  ProjectCustomAttributesDirective = function($log, $confirm, animationFrame, $translate) {
    var link;
    link = function($scope, $el, $attrs) {
      var $ctrl, _manageExtraFormEvent, _manageFormEvent, addExtraOption, cancelCreate, cancelUpdate, create, deleteCustomAttribute, hideAddButton, hideCancelButton, hideCreateForm, hideEditForm, hideExtra, initAttrType, initDraggable, removeExtraOption, resetNewAttr, revertChangesInCustomAttribute, showAddButton, showCancelButton, showCreateForm, showEditForm, showExtra, update;
      $ctrl = $el.controller();
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      $scope.isExtraVisible = {};
      _manageFormEvent = function(event, callback) {
        var formEl;
        event.preventDefault();
        formEl = angular.element(event.currentTarget).closest("form");
        return callback(formEl);
      };
      initDraggable = function() {
        var drake, el, i, len, results, sortableChildren, sortableEl;
        sortableEl = $el.find(".js-sortable");
        drake = dragula([sortableEl[0]], {
          direction: 'vertical',
          copySortSource: false,
          copy: false,
          mirrorContainer: sortableEl[0],
          moves: function(item, source, handle) {
            var childItem;
            childItem = $(handle).closest('.js-child-sortable');
            if (childItem[0]) {
              return false;
            }
            return $(item).is('div[tg-bind-scope]');
          }
        });
        drake.on('dragend', function(item) {
          var itemAttr, itemEl, itemIndex;
          itemEl = $(item);
          itemAttr = itemEl.scope().attr;
          itemIndex = itemEl.index();
          return $ctrl.moveCustomAttributes(itemAttr, itemIndex);
        });
        sortableChildren = $el.find(".js-child-sortable");
        results = [];
        for (i = 0, len = sortableChildren.length; i < len; i++) {
          el = sortableChildren[i];
          drake[el] = dragula([el], {
            direction: 'vertical',
            copySortSource: false,
            copy: false,
            mirrorContainer: el,
            moves: function(item) {
              return $(item).is('div[tg-bind-scope]');
            }
          });
          results.push(drake[el].on('dragend', function(item) {
            var attrExtra, itemEl, sourceIndex, targetIndex, value;
            itemEl = $(item);
            attrExtra = itemEl.scope().attr.extra;
            sourceIndex = itemEl.scope().$index;
            targetIndex = itemEl.index();
            value = attrExtra[sourceIndex];
            attrExtra.splice(sourceIndex, 1);
            attrExtra.splice(targetIndex, 0, value);
            itemEl.scope().attr.setAttr('extra', attrExtra);
            return $ctrl.saveCustomAttribute(itemEl.scope().attr).then(function() {
              return $confirm.notify("success");
            });
          }));
        }
        return results;
      };
      showCreateForm = function() {
        $el.find(".js-new-custom-field").removeClass("hidden");
        return $el.find(".js-new-custom-field input:visible").first().focus();
      };
      hideCreateForm = function() {
        return $el.find(".js-new-custom-field").addClass("hidden");
      };
      showAddButton = function() {
        return $el.find(".js-add-custom-field-button").removeClass("hidden");
      };
      hideAddButton = function() {
        return $el.find(".js-add-custom-field-button").addClass("hidden");
      };
      showCancelButton = function() {
        return $el.find(".js-cancel-new-custom-field-button").removeClass("hidden");
      };
      hideCancelButton = function() {
        return $el.find(".js-cancel-new-custom-field-button").addClass("hidden");
      };
      resetNewAttr = function() {
        return $scope.newAttr = {};
      };
      create = function(formEl) {
        var attr, form, onError, onSucces;
        form = formEl.checksley();
        if (!form.validate()) {
          return;
        }
        onSucces = function() {
          $ctrl.loadCustomAttributes();
          hideCreateForm();
          resetNewAttr();
          return $confirm.notify("success");
        };
        onError = function(data) {
          return form.setErrors(data);
        };
        attr = $scope.newAttr;
        attr.project = $scope.projectId;
        attr.order = $scope.maxOrder ? $scope.maxOrder + 1 : 1;
        return $ctrl.createCustomAttribute(attr).then(onSucces, onError);
      };
      cancelCreate = function() {
        hideCreateForm();
        return resetNewAttr();
      };
      initAttrType = function(formEl) {
        var attr, ref;
        attr = formEl.scope().newAttr ? formEl.scope().newAttr : formEl.scope().attr;
        if (attr.type !== "dropdown") {
          return;
        }
        if ((ref = attr.extra) != null ? ref.length : void 0) {
          return;
        }
        attr.extra = [''];
        if (attr.id) {
          return showEditForm(formEl);
        } else {
          showExtra(-1);
          return formEl.scope().$apply();
        }
      };
      $scope.$watch("customAttributes", function(customAttributes) {
        if (!customAttributes) {
          return;
        }
        if (customAttributes.length === 0) {
          hideCancelButton();
          hideAddButton();
          return showCreateForm();
        } else {
          hideCreateForm();
          showAddButton();
          showCancelButton();
          return initDraggable();
        }
      });
      $el.on("change", ".custom-field-type select", function(event) {
        return _manageFormEvent(event, initAttrType);
      });
      $el.on("click", ".js-add-custom-field-button", function(event) {
        return _manageFormEvent(event, showCreateForm);
      });
      $el.on("click", ".js-create-custom-field-button", debounce(2000, function(event) {
        return _manageFormEvent(event, create);
      }));
      $el.on("click", ".js-cancel-new-custom-field-button", function(event) {
        event.preventDefault();
        return cancelCreate();
      });
      $el.on("keyup", ".js-new-custom-field input", function(event) {
        if (event.keyCode === 13) {
          return _manageFormEvent(event, create);
        } else if (event.keyCode === 27) {
          return cancelCreate();
        }
      });
      showEditForm = function(formEl) {
        formEl.find(".js-view-custom-field").addClass("hidden");
        formEl.find(".js-edit-custom-field").removeClass("hidden");
        formEl.find(".js-edit-custom-field input:visible").first().focus().select();
        formEl.find(".js-view-custom-field-extra").addClass("hidden");
        formEl.find(".js-edit-custom-field-extra").removeClass("hidden");
        formEl.find(".custom-extra-actions").removeClass("hidden");
        showExtra(formEl.scope().attr.id);
        return $scope.$apply();
      };
      update = function(formEl) {
        var attr, form, onError, onSucces;
        form = formEl.checksley();
        if (!form.validate()) {
          return;
        }
        onSucces = function() {
          $ctrl.loadCustomAttributes();
          hideEditForm(formEl);
          return $confirm.notify("success");
        };
        onError = function(data) {
          return form.setErrors(data);
        };
        attr = formEl.scope().attr;
        attr.setAttr('extra', attr.extra);
        return $ctrl.saveCustomAttribute(attr).then(onSucces, onError);
      };
      cancelUpdate = function(formEl) {
        hideEditForm(formEl);
        return revertChangesInCustomAttribute(formEl);
      };
      hideEditForm = function(formEl) {
        formEl.find(".js-edit-custom-field").addClass("hidden");
        formEl.find(".js-view-custom-field").removeClass("hidden");
        formEl.find(".js-edit-custom-field-extra").addClass("hidden");
        formEl.find(".js-view-custom-field-extra").removeClass("hidden");
        return formEl.find(".custom-extra-actions").addClass("hidden");
      };
      revertChangesInCustomAttribute = function(formEl) {
        return $scope.$apply(function() {
          return formEl.scope().attr.revert();
        });
      };
      $el.on("click", ".js-edit-custom-field-button", function(event) {
        return _manageFormEvent(event, showEditForm);
      });
      $el.on("click", ".js-update-custom-field-button", debounce(1000, function(event) {
        return _manageFormEvent(event, update);
      }));
      $el.on("click", ".js-cancel-edit-custom-field-button", function(event) {
        return _manageFormEvent(event, cancelUpdate);
      });
      $el.on("keyup", ".js-edit-custom-field input", function(event) {
        if (event.keyCode === 13) {
          return _manageFormEvent(event, update);
        } else if (event.keyCode === 27) {
          return _manageFormEvent(event, cancelUpdate);
        }
      });
      deleteCustomAttribute = function(formEl) {
        var attr, message, text, title;
        attr = formEl.scope().attr;
        message = attr.name;
        title = $translate.instant("COMMON.CUSTOM_ATTRIBUTES.DELETE");
        text = $translate.instant("COMMON.CUSTOM_ATTRIBUTES.CONFIRM_DELETE");
        return $confirm.ask(title, text, message).then(function(response) {
          var onError, onSucces;
          onSucces = function() {
            return $ctrl.loadCustomAttributes()["finally"](function() {
              return response.finish();
            });
          };
          onError = function() {
            return $confirm.notify("error", null, "We have not been able to delete '" + message + "'.");
          };
          return $ctrl.deleteCustomAttribute(attr).then(onSucces, onError);
        });
      };
      $el.on("click", ".js-delete-custom-field-button", debounce(2000, function(event) {
        return _manageFormEvent(event, deleteCustomAttribute);
      }));
      $scope.toggleExtraVisible = function(index) {
        if (!$scope.isExtraVisible[index]) {
          return showExtra(index);
        } else {
          return hideExtra(index);
        }
      };
      showExtra = function(index) {
        return $scope.isExtraVisible[index] = true;
      };
      hideExtra = function(index) {
        return $scope.isExtraVisible[index] = false;
      };
      _manageExtraFormEvent = function(event, callback) {
        var formEl, formExtraEl;
        event.preventDefault();
        formEl = angular.element(event.currentTarget).closest("form");
        formExtraEl = angular.element(event.currentTarget).closest(".js-form");
        return callback(formEl, formExtraEl);
      };
      addExtraOption = function(formEl, formExtraEl) {
        var attrExtra, formScope, ref;
        formScope = formEl.scope();
        attrExtra = ((ref = formScope.newAttr) != null ? ref.extra : void 0) ? formScope.newAttr.extra : formScope.attr.extra;
        attrExtra.push("");
        formScope.$apply();
        formEl.find(".js-edit-custom-field-extra").last().removeClass("hidden");
        formEl.find(".js-view-custom-field-extra").last().addClass("hidden");
        return formEl.find(".js-edit-custom-field-extra input").last().focus();
      };
      removeExtraOption = function(formEl, formExtraEl) {
        var attrExtra;
        attrExtra = formEl.scope().attr.extra;
        attrExtra.splice(formExtraEl.scope().$index, 1);
        return formExtraEl.scope().$apply();
      };
      $el.on("keyup", ".js-edit-custom-field-extra input", function(event) {
        if (event.keyCode === 13) {
          return _manageFormEvent(event, update);
        } else if (event.keyCode === 27) {
          return _manageFormEvent(event, cancelUpdate);
        }
      });
      $el.on("keyup", ".js-new-custom-field-extra input", function(event) {
        if (event.keyCode === 13) {
          return _manageFormEvent(event, create);
        } else if (event.keyCode === 27) {
          return cancelCreate();
        }
      });
      $el.on("click", ".js-add-option-custom-field-extra-button", debounce(500, function(event) {
        return _manageExtraFormEvent(event, addExtraOption);
      }));
      return $el.on("click", ".js-delete-custom-field-extra-button", debounce(500, function(event) {
        return _manageExtraFormEvent(event, removeExtraOption);
      }));
    };
    return {
      link: link
    };
  };

  module.directive("tgProjectCustomAttributes", ["$log", "$tgConfirm", "animationFrame", "$translate", ProjectCustomAttributesDirective]);

  ProjectTagsController = (function(superClass) {
    extend(ProjectTagsController, superClass);

    ProjectTagsController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$tgModel", "tgProjectService"];

    function ProjectTagsController(scope, rootscope, repo, confirm, rs, model, projectService1) {
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.model = model;
      this.projectService = projectService1;
      this.mixingClass = bind(this.mixingClass, this);
      this.cancelMixingTags = bind(this.cancelMixingTags, this);
      this.confirmMixingTags = bind(this.confirmMixingTags, this);
      this.toggleMixingFromTags = bind(this.toggleMixingFromTags, this);
      this.startMixingTags = bind(this.startMixingTags, this);
      this.deleteTag = bind(this.deleteTag, this);
      this.editTag = bind(this.editTag, this);
      this.createTag = bind(this.createTag, this);
      this.filterAndSortTags = bind(this.filterAndSortTags, this);
      this.loadTags = bind(this.loadTags, this);
      this.loading = true;
      this.loadTags();
    }

    ProjectTagsController.prototype.loadTags = function() {
      var project;
      project = this.projectService.project.toJS();
      return this.rs.projects.tagsColors(project.id).then((function(_this) {
        return function(tags) {
          _this.scope.projectTagsAll = _.map(tags.getAttrs(), function(color, name) {
            return _this.model.make_model('tag', {
              name: name,
              color: color
            });
          });
          _this.filterAndSortTags();
          return _this.loading = false;
        };
      })(this));
    };

    ProjectTagsController.prototype.filterAndSortTags = function() {
      this.scope.projectTags = _.sortBy(this.scope.projectTagsAll, function(it) {
        return it.name.toLowerCase();
      });
      return this.scope.projectTags = _.filter(this.scope.projectTags, (function(_this) {
        return function(tag) {
          return tag.name.indexOf(_this.scope.tagsFilter.name) !== -1;
        };
      })(this));
    };

    ProjectTagsController.prototype.createTag = function(tag, color) {
      return this.rs.projects.createTag(this.scope.projectId, tag, color);
    };

    ProjectTagsController.prototype.editTag = function(from_tag, to_tag, color) {
      if (from_tag === to_tag) {
        to_tag = null;
      }
      return this.rs.projects.editTag(this.scope.projectId, from_tag, to_tag, color);
    };

    ProjectTagsController.prototype.deleteTag = function(tag) {
      this.scope.loadingDelete = true;
      return this.rs.projects.deleteTag(this.scope.projectId, tag)["finally"]((function(_this) {
        return function() {
          return _this.scope.loadingDelete = false;
        };
      })(this));
    };

    ProjectTagsController.prototype.startMixingTags = function(tag) {
      return this.scope.mixingTags.toTag = tag.name;
    };

    ProjectTagsController.prototype.toggleMixingFromTags = function(tag) {
      var index;
      if (tag.name !== this.scope.mixingTags.toTag) {
        index = this.scope.mixingTags.fromTags.indexOf(tag.name);
        if (index === -1) {
          return this.scope.mixingTags.fromTags.push(tag.name);
        } else {
          return this.scope.mixingTags.fromTags.splice(index, 1);
        }
      }
    };

    ProjectTagsController.prototype.confirmMixingTags = function() {
      var fromTags, toTag;
      toTag = this.scope.mixingTags.toTag;
      fromTags = this.scope.mixingTags.fromTags;
      this.scope.loadingMixing = true;
      return this.rs.projects.mixTags(this.scope.projectId, toTag, fromTags).then((function(_this) {
        return function() {
          _this.cancelMixingTags();
          return _this.loadTags();
        };
      })(this))["finally"]((function(_this) {
        return function() {
          return _this.scope.loadingMixing = false;
        };
      })(this));
    };

    ProjectTagsController.prototype.cancelMixingTags = function() {
      this.scope.mixingTags.toTag = null;
      return this.scope.mixingTags.fromTags = [];
    };

    ProjectTagsController.prototype.mixingClass = function(tag) {
      if (this.scope.mixingTags.toTag !== null) {
        if (tag.name === this.scope.mixingTags.toTag) {
          return "mixing-tags-to";
        } else if (this.scope.mixingTags.fromTags.indexOf(tag.name) !== -1) {
          return "mixing-tags-from";
        }
      }
    };

    return ProjectTagsController;

  })(taiga.Controller);

  module.controller("ProjectTagsController", ProjectTagsController);

  ProjectTagsDirective = function($log, $repo, $confirm, $location, animationFrame, $translate, $rootscope) {
    var link;
    link = function($scope, $el, $attrs) {
      var $ctrl, $window, cancel, goToBottomList, initializeMixingTags, initializeNewValue, initializeTagsFilter, initializeTextTranslations, objName, saveNewValue, saveValue, valueType;
      $window = $(window);
      $ctrl = $el.controller();
      valueType = $attrs.type;
      objName = $attrs.objname;
      initializeNewValue = function() {
        return $scope.newValue = {
          "tag": "",
          "color": ""
        };
      };
      initializeTagsFilter = function() {
        return $scope.tagsFilter = {
          "name": ""
        };
      };
      initializeMixingTags = function() {
        return $scope.mixingTags = {
          "toTag": null,
          "fromTags": []
        };
      };
      initializeTextTranslations = function() {
        return $scope.addNewElementText = $translate.instant("ADMIN.PROJECT_VALUES_TAGS.ACTION_ADD");
      };
      initializeNewValue();
      initializeTagsFilter();
      initializeMixingTags();
      initializeTextTranslations();
      $rootscope.$on("$translateChangeEnd", function() {
        return $scope.$evalAsync(initializeTextTranslations);
      });
      goToBottomList = (function(_this) {
        return function(focus) {
          var table;
          if (focus == null) {
            focus = false;
          }
          table = $el.find(".table-main");
          $(document.body).scrollTop(table.offset().top + table.height());
          if (focus) {
            return $el.find(".new-value input:visible").first().focus();
          }
        };
      })(this);
      saveValue = function(target) {
        var form, formEl, originalTag, promise, tag;
        formEl = target.parents("form");
        form = formEl.checksley();
        if (!form.validate()) {
          return;
        }
        tag = formEl.scope().tag;
        originalTag = tag.clone();
        originalTag.revert();
        $scope.loadingEdit = true;
        promise = $ctrl.editTag(originalTag.name, tag.name, tag.color);
        promise.then(function() {
          return $ctrl.loadTags().then(function() {
            var row;
            row = target.parents(".row.table-main");
            row.addClass("hidden");
            $scope.loadingEdit = false;
            $rootscope.$broadcast('tags:updated');
            return row.siblings(".visualization").removeClass('hidden');
          });
        });
        return promise.then(null, function(response) {
          $scope.loadingEdit = false;
          return form.setErrors(response.data);
        });
      };
      saveNewValue = function(target) {
        var form, formEl, promise;
        formEl = target.parents("form");
        formEl = target;
        form = formEl.checksley();
        if (!form.validate()) {
          return;
        }
        $scope.loadingCreate = true;
        promise = $ctrl.createTag($scope.newValue.tag, $scope.newValue.color);
        promise.then(function(data) {
          return $ctrl.loadTags().then(function() {
            $scope.loadingCreate = false;
            target.addClass("hidden");
            $rootscope.$broadcast('tags:updated');
            return initializeNewValue();
          });
        });
        return promise.then(null, function(response) {
          $scope.loadingCreate = false;
          return form.setErrors(response.data);
        });
      };
      cancel = function(target) {
        var formEl, row, tag;
        row = target.parents(".row.table-main");
        formEl = target.parents("form");
        tag = formEl.scope().tag;
        return $scope.$apply(function() {
          row.addClass("hidden");
          tag.revert();
          return row.siblings(".visualization").removeClass('hidden');
        });
      };
      $scope.$watch("tagsFilter.name", function(tagsFilter) {
        return $ctrl.filterAndSortTags();
      });
      $window.on("keyup", function(event) {
        if (event.keyCode === 27) {
          return $scope.$apply(function() {
            return initializeMixingTags();
          });
        }
      });
      $el.on("click", ".show-add-new", function(event) {
        event.preventDefault();
        return $el.find(".new-value").removeClass('hidden');
      });
      $el.on("click", ".add-new", debounce(2000, function(event) {
        var target;
        event.preventDefault();
        target = $el.find(".new-value");
        return saveNewValue(target);
      }));
      $el.on("click", ".delete-new", function(event) {
        event.preventDefault();
        $el.find(".new-value").addClass("hidden");
        return initializeNewValue();
      });
      $el.on("click", ".mix-tags", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        return $scope.$apply(function() {
          return $ctrl.startMixingTags(target.parents('form').scope().tag);
        });
      });
      $el.on("click", ".mixing-row", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        return $scope.$apply(function() {
          return $ctrl.toggleMixingFromTags(target.parents('form').scope().tag);
        });
      });
      $el.on("click", ".mixing-confirm", function(event) {
        event.preventDefault();
        event.stopPropagation();
        return $scope.$apply(function() {
          return $ctrl.confirmMixingTags();
        });
      });
      $el.on("click", ".mixing-cancel", function(event) {
        event.preventDefault();
        event.stopPropagation();
        return $scope.$apply(function() {
          return $ctrl.cancelMixingTags();
        });
      });
      $el.on("click", ".edit-value", function(event) {
        var editionRow, row, target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        row = target.parents(".row.table-main");
        row.addClass("hidden");
        editionRow = row.siblings(".edition");
        editionRow.removeClass('hidden');
        return editionRow.find('input:visible').first().focus().select();
      });
      $el.on("keyup", ".new-value input", function(event) {
        var target;
        if (event.keyCode === 13) {
          target = $el.find(".new-value");
          return saveNewValue(target);
        } else if (event.keyCode === 27) {
          $el.find(".new-value").addClass("hidden");
          return initializeNewValue();
        }
      });
      $el.on("keyup", ".status-name input", function(event) {
        var target;
        target = angular.element(event.currentTarget);
        if (event.keyCode === 13) {
          return saveValue(target);
        } else if (event.keyCode === 27) {
          return cancel(target);
        }
      });
      $el.on("click", ".save", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        return saveValue(target);
      });
      $el.on("click", ".cancel", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        return cancel(target);
      });
      $el.on("click", ".delete-tag", function(event) {
        var formEl, tag, target, title;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        formEl = target.parents("form");
        tag = formEl.scope().tag;
        title = $translate.instant("ADMIN.COMMON.TITLE_ACTION_DELETE_TAG");
        return $confirm.askOnDelete(title, tag.name).then(function(response) {
          var onError, onSucces;
          onSucces = function() {
            return $ctrl.loadTags()["finally"](function() {
              $rootscope.$broadcast('tags:updated');
              return response.finish();
            });
          };
          onError = function() {
            return $confirm.notify("error");
          };
          return $ctrl.deleteTag(tag.name).then(onSucces, onError);
        });
      });
      return $scope.$on("$destroy", function() {
        $el.off();
        return $window.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgProjectTags", ["$log", "$tgRepo", "$tgConfirm", "$tgLocation", "animationFrame", "$translate", "$rootScope", ProjectTagsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/admin/roles.coffee
 */

(function() {
  var EditRoleDirective, NewRoleDirective, RolePermissionsDirective, RolesController, RolesDirective, bindMethods, bindOnce, debounce, mixOf, module, taiga,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  bindMethods = this.taiga.bindMethods;

  module = angular.module("taigaAdmin");

  RolesController = (function(superClass) {
    extend(RolesController, superClass);

    RolesController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "$tgModel", "tgAppMetaService", "$translate", "tgErrorHandlingService", "tgProjectService"];

    function RolesController(scope, rootscope, repo, confirm, rs, params, q, location, navUrls, model, appMetaService, translate, errorHandlingService, projectService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.model = model;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService;
      this._disableComputable = bind(this._disableComputable, this);
      this._enableComputable = bind(this._enableComputable, this);
      bindMethods(this);
      this.scope.sectionName = "ADMIN.MENU.PERMISSIONS";
      this.scope.project = {};
      this.scope.anyComputableRole = true;
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("ADMIN.ROLES.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    RolesController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      project = this.model.make_model("projects", project);
      if (!project.i_am_admin) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      this.scope.anyComputableRole = _.some(_.map(project.roles, function(point) {
        return point.computable;
      }));
      return project;
    };

    RolesController.prototype.loadRoles = function() {
      return this.rs.roles.list(this.scope.projectId).then((function(_this) {
        return function(roles) {
          var public_permission;
          roles = roles.map(function(role) {
            role.external_user = false;
            return role;
          });
          public_permission = {
            "name": _this.translate.instant("ADMIN.ROLES.EXTERNAL_USER"),
            "permissions": _this.scope.project.public_permissions,
            "external_user": true
          };
          roles.push(public_permission);
          _this.scope.roles = roles;
          _this.scope.role = _this.scope.roles[0];
          return roles;
        };
      })(this));
    };

    RolesController.prototype.loadInitialData = function() {
      this.loadProject();
      return this.loadRoles();
    };

    RolesController.prototype.forceLoadProject = function() {
      return this.rootscope.$broadcast("admin:project-roles:updated");
    };

    RolesController.prototype.setRole = function(role) {
      this.scope.role = role;
      return this.scope.$broadcast("role:changed", this.scope.role);
    };

    RolesController.prototype["delete"] = function() {
      var choices, i, len, ref, replacement, role, subtitle, title, warning;
      choices = {};
      ref = this.scope.roles;
      for (i = 0, len = ref.length; i < len; i++) {
        role = ref[i];
        if (role.id !== this.scope.role.id) {
          choices[role.id] = role.name;
        }
      }
      if (_.keys(choices).length === 0) {
        return this.confirm.error(this.translate.instant("ADMIN.ROLES.ERROR_DELETE_ALL"));
      }
      title = this.translate.instant("ADMIN.ROLES.TITLE_DELETE_ROLE");
      subtitle = this.scope.role.name;
      replacement = this.translate.instant("ADMIN.ROLES.REPLACEMENT_ROLE");
      warning = this.translate.instant("ADMIN.ROLES.WARNING_DELETE_ROLE");
      return this.confirm.askChoice(title, subtitle, choices, replacement, warning).then((function(_this) {
        return function(response) {
          var onError, onSuccess;
          onSuccess = function() {
            _this.forceLoadProject();
            return _this.loadRoles()["finally"](function() {
              return response.finish();
            });
          };
          onError = function() {
            return _this.confirm.notify('error');
          };
          return _this.repo.remove(_this.scope.role, {
            moveTo: response.selected
          }).then(onSuccess, onError);
        };
      })(this));
    };

    RolesController.prototype._enableComputable = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.confirm.notify("success");
          return _this.forceLoadProject();
        };
      })(this);
      onError = (function(_this) {
        return function() {
          _this.confirm.notify("error");
          return _this.scope.role.revert();
        };
      })(this);
      return this.repo.save(this.scope.role).then(onSuccess, onError);
    };

    RolesController.prototype._disableComputable = function() {
      var askOnError, askOnSuccess, subtitle, title;
      askOnSuccess = (function(_this) {
        return function(response) {
          var onError, onSuccess;
          onSuccess = function() {
            response.finish();
            _this.confirm.notify("success");
            return _this.forceLoadProject();
          };
          onError = function() {
            response.finish();
            _this.confirm.notify("error");
            return _this.scope.role.revert();
          };
          return _this.repo.save(_this.scope.role).then(onSuccess, onError);
        };
      })(this);
      askOnError = (function(_this) {
        return function(response) {
          return _this.scope.role.revert();
        };
      })(this);
      title = this.translate.instant("ADMIN.ROLES.DISABLE_COMPUTABLE_ALERT_TITLE");
      subtitle = this.translate.instant("ADMIN.ROLES.DISABLE_COMPUTABLE_ALERT_SUBTITLE", {
        roleName: this.scope.role.name
      });
      return this.confirm.ask(title, subtitle, "").then(askOnSuccess, askOnError);
    };

    RolesController.prototype.toggleComputable = debounce(2000, function() {
      if (!this.scope.role.computable) {
        return this._disableComputable();
      } else {
        return this._enableComputable();
      }
    });

    return RolesController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  module.controller("RolesController", RolesController);

  EditRoleDirective = function($repo, $confirm) {
    var link;
    link = function($scope, $el, $attrs) {
      var submit, toggleView;
      toggleView = function() {
        $el.find('.total').toggle();
        return $el.find('.edit-role').toggle();
      };
      submit = function() {
        var promise;
        $scope.role.name = $el.find("input").val();
        promise = $repo.save($scope.role);
        promise.then(function() {
          return $confirm.notify("success");
        });
        promise.then(null, function(data) {
          return $confirm.notify("error");
        });
        return toggleView();
      };
      $el.on("click", ".edit-value", function() {
        toggleView();
        $el.find("input").focus();
        return $el.find("input").val($scope.role.name);
      });
      $el.on("click", "a.save", submit);
      $el.on("keyup", "input", function(event) {
        if (event.keyCode === 13) {
          return submit();
        } else if (event.keyCode === 27) {
          return toggleView();
        }
      });
      $scope.$on("role:changed", function() {
        if ($el.find('.edit-role').is(":visible")) {
          return toggleView();
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgEditRole", ["$tgRepo", "$tgConfirm", EditRoleDirective]);

  RolesDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var $ctrl;
      $ctrl = $el.controller();
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgRoles", RolesDirective);

  NewRoleDirective = function($tgrepo, $confirm) {
    var DEFAULT_PERMISSIONS, link;
    DEFAULT_PERMISSIONS = ["view_project", "view_milestones", "view_us", "view_tasks", "view_issues"];
    link = function($scope, $el, $attrs) {
      var $ctrl;
      $ctrl = $el.controller();
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      $el.on("click", "a.add-button", function(event) {
        event.preventDefault();
        $el.find(".new").removeClass("hidden");
        $el.find(".new").focus();
        return $el.find(".add-button").hide();
      });
      return $el.on("keyup", ".new", function(event) {
        var newRole, onError, onSuccess, target;
        event.preventDefault();
        if (event.keyCode === 13) {
          target = angular.element(event.currentTarget);
          newRole = {
            project: $scope.projectId,
            name: target.val(),
            permissions: DEFAULT_PERMISSIONS,
            order: _.maxBy($scope.roles, function(r) {
              return r.order;
            }).order + 1,
            computable: false
          };
          $el.find(".new").addClass("hidden");
          $el.find(".new").val('');
          onSuccess = function(role) {
            var insertPosition;
            insertPosition = $scope.roles.length - 1;
            $scope.roles.splice(insertPosition, 0, role);
            $ctrl.setRole(role);
            $el.find(".add-button").show();
            return $ctrl.forceLoadProject();
          };
          onError = function() {
            return $confirm.notify("error");
          };
          return $tgrepo.create("roles", newRole).then(onSuccess, onError);
        } else if (event.keyCode === 27) {
          target = angular.element(event.currentTarget);
          $el.find(".new").addClass("hidden");
          $el.find(".new").val('');
          return $el.find(".add-button").show();
        }
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgNewRole", ["$tgRepo", "$tgConfirm", NewRoleDirective]);

  RolePermissionsDirective = function($rootscope, $repo, $confirm, $compile) {
    var baseTemplate, categoryTemplate, link, resumeTemplate;
    resumeTemplate = _.template("<div class=\"resume-title\" translate=\"<%- category.name %>\"></div>\n<div class=\"summary-role\">\n    <div class=\"count\"><%- category.activePermissions %>/<%- category.permissions.length %></div>\n    <% _.each(category.permissions, function(permission) { %>\n        <div class=\"role-summary-single check-toggle <% if(permission.active) { %>active<% } %>\"\n             title=\"{{ '<%- permission.name %>' | translate }}\"></div>\n    <% }) %>\n</div>\n<tg-svg svg-icon=\"icon-arrow-right\"></tg-svg>");
    categoryTemplate = _.template("<div class=\"category-config\" data-id=\"<%- index %>\">\n    <div class=\"resume\">\n    </div>\n    <div class=\"category-items\">\n        <div class=\"items-container\">\n        <% _.each(category.permissions, function(permission) { %>\n            <div class=\"category-item\" data-id=\"<%- permission.key %>\">\n                <span translate=\"<%- permission.name %>\"></span>\n                <div class=\"check\">\n                    <input type=\"checkbox\"\n                           <% if(!permission.editable) { %> disabled=\"disabled\" <% } %>\n                           <% if(permission.active) { %> checked=\"checked\" <% } %>/>\n                    <div></div>\n                    <span class=\"check-text check-yes\" translate=\"COMMON.YES\"></span>\n                    <span class=\"check-text check-no\" translate=\"COMMON.NO\"></span>\n                </div>\n            </div>\n        <% }) %>\n        </div>\n    </div>\n</div>");
    baseTemplate = _.template("<div class=\"category-config-list\"></div>");
    link = function($scope, $el, $attrs) {
      var $ctrl, generateCategoriesFromRole, renderCategory, renderPermissions, renderResume;
      $ctrl = $el.controller();
      generateCategoriesFromRole = function(role) {
        var categories, epicPermissions, isPermissionEditable, issuePermissions, milestonePermissions, setActivePermissions, setActivePermissionsPerCategory, taskPermissions, userStoryPermissions, wikiPermissions;
        setActivePermissions = function(permissions) {
          return _.map(permissions, function(x) {
            var ref;
            return _.extend({}, x, {
              active: (ref = x["key"], indexOf.call(role.permissions, ref) >= 0)
            });
          });
        };
        isPermissionEditable = function(permission, role, project) {
          if (role.external_user && !project.is_private && permission.key.indexOf("view_") === 0) {
            return false;
          } else {
            return true;
          }
        };
        setActivePermissionsPerCategory = function(category) {
          return _.map(category, function(cat) {
            cat.permissions = cat.permissions.map(function(permission) {
              permission.editable = isPermissionEditable(permission, role, $scope.project);
              return permission;
            });
            return _.extend({}, cat, {
              activePermissions: _.filter(cat["permissions"], "active").length
            });
          });
        };
        categories = [];
        epicPermissions = [
          {
            key: "view_epics",
            name: "COMMON.PERMISIONS_CATEGORIES.EPICS.VIEW_EPICS"
          }, {
            key: "add_epic",
            name: "COMMON.PERMISIONS_CATEGORIES.EPICS.ADD_EPICS"
          }, {
            key: "modify_epic",
            name: "COMMON.PERMISIONS_CATEGORIES.EPICS.MODIFY_EPICS"
          }, {
            key: "comment_epic",
            name: "COMMON.PERMISIONS_CATEGORIES.EPICS.COMMENT_EPICS"
          }, {
            key: "delete_epic",
            name: "COMMON.PERMISIONS_CATEGORIES.EPICS.DELETE_EPICS"
          }
        ];
        categories.push({
          name: "COMMON.PERMISIONS_CATEGORIES.EPICS.NAME",
          permissions: setActivePermissions(epicPermissions)
        });
        milestonePermissions = [
          {
            key: "view_milestones",
            name: "COMMON.PERMISIONS_CATEGORIES.SPRINTS.VIEW_SPRINTS"
          }, {
            key: "add_milestone",
            name: "COMMON.PERMISIONS_CATEGORIES.SPRINTS.ADD_SPRINTS"
          }, {
            key: "modify_milestone",
            name: "COMMON.PERMISIONS_CATEGORIES.SPRINTS.MODIFY_SPRINTS"
          }, {
            key: "delete_milestone",
            name: "COMMON.PERMISIONS_CATEGORIES.SPRINTS.DELETE_SPRINTS"
          }
        ];
        categories.push({
          name: "COMMON.PERMISIONS_CATEGORIES.SPRINTS.NAME",
          permissions: setActivePermissions(milestonePermissions)
        });
        userStoryPermissions = [
          {
            key: "view_us",
            name: "COMMON.PERMISIONS_CATEGORIES.USER_STORIES.VIEW_USER_STORIES"
          }, {
            key: "add_us",
            name: "COMMON.PERMISIONS_CATEGORIES.USER_STORIES.ADD_USER_STORIES"
          }, {
            key: "modify_us",
            name: "COMMON.PERMISIONS_CATEGORIES.USER_STORIES.MODIFY_USER_STORIES"
          }, {
            key: "comment_us",
            name: "COMMON.PERMISIONS_CATEGORIES.USER_STORIES.COMMENT_USER_STORIES"
          }, {
            key: "delete_us",
            name: "COMMON.PERMISIONS_CATEGORIES.USER_STORIES.DELETE_USER_STORIES"
          }
        ];
        categories.push({
          name: "COMMON.PERMISIONS_CATEGORIES.USER_STORIES.NAME",
          permissions: setActivePermissions(userStoryPermissions)
        });
        taskPermissions = [
          {
            key: "view_tasks",
            name: "COMMON.PERMISIONS_CATEGORIES.TASKS.VIEW_TASKS"
          }, {
            key: "add_task",
            name: "COMMON.PERMISIONS_CATEGORIES.TASKS.ADD_TASKS"
          }, {
            key: "modify_task",
            name: "COMMON.PERMISIONS_CATEGORIES.TASKS.MODIFY_TASKS"
          }, {
            key: "comment_task",
            name: "COMMON.PERMISIONS_CATEGORIES.TASKS.COMMENT_TASKS"
          }, {
            key: "delete_task",
            name: "COMMON.PERMISIONS_CATEGORIES.TASKS.DELETE_TASKS"
          }
        ];
        categories.push({
          name: "COMMON.PERMISIONS_CATEGORIES.TASKS.NAME",
          permissions: setActivePermissions(taskPermissions)
        });
        issuePermissions = [
          {
            key: "view_issues",
            name: "COMMON.PERMISIONS_CATEGORIES.ISSUES.VIEW_ISSUES"
          }, {
            key: "add_issue",
            name: "COMMON.PERMISIONS_CATEGORIES.ISSUES.ADD_ISSUES"
          }, {
            key: "modify_issue",
            name: "COMMON.PERMISIONS_CATEGORIES.ISSUES.MODIFY_ISSUES"
          }, {
            key: "comment_issue",
            name: "COMMON.PERMISIONS_CATEGORIES.ISSUES.COMMENT_ISSUES"
          }, {
            key: "delete_issue",
            name: "COMMON.PERMISIONS_CATEGORIES.ISSUES.DELETE_ISSUES"
          }
        ];
        categories.push({
          name: "COMMON.PERMISIONS_CATEGORIES.ISSUES.NAME",
          permissions: setActivePermissions(issuePermissions)
        });
        wikiPermissions = [
          {
            key: "view_wiki_pages",
            name: "COMMON.PERMISIONS_CATEGORIES.WIKI.VIEW_WIKI_PAGES"
          }, {
            key: "add_wiki_page",
            name: "COMMON.PERMISIONS_CATEGORIES.WIKI.ADD_WIKI_PAGES"
          }, {
            key: "modify_wiki_page",
            name: "COMMON.PERMISIONS_CATEGORIES.WIKI.MODIFY_WIKI_PAGES"
          }, {
            key: "delete_wiki_page",
            name: "COMMON.PERMISIONS_CATEGORIES.WIKI.DELETE_WIKI_PAGES"
          }, {
            key: "view_wiki_links",
            name: "COMMON.PERMISIONS_CATEGORIES.WIKI.VIEW_WIKI_LINKS"
          }, {
            key: "add_wiki_link",
            name: "COMMON.PERMISIONS_CATEGORIES.WIKI.ADD_WIKI_LINKS"
          }, {
            key: "delete_wiki_link",
            name: "COMMON.PERMISIONS_CATEGORIES.WIKI.DELETE_WIKI_LINKS"
          }
        ];
        categories.push({
          name: "COMMON.PERMISIONS_CATEGORIES.WIKI.NAME",
          permissions: setActivePermissions(wikiPermissions)
        });
        return setActivePermissionsPerCategory(categories);
      };
      renderResume = function(element, category) {
        return element.find(".resume").html($compile(resumeTemplate({
          category: category
        }))($scope));
      };
      renderCategory = function(category, index) {
        var html;
        html = categoryTemplate({
          category: category,
          index: index
        });
        html = angular.element(html);
        renderResume(html, category);
        return $compile(html)($scope);
      };
      renderPermissions = function() {
        var html;
        $el.off();
        html = baseTemplate();
        _.each(generateCategoriesFromRole($scope.role), function(category, index) {
          return html = angular.element(html).append(renderCategory(category, index));
        });
        $el.html(html);
        $el.on("click", ".resume", function(event) {
          var target;
          event.preventDefault();
          target = angular.element(event.currentTarget);
          target.toggleClass("open-drawer");
          return target.next().toggleClass("open");
        });
        return $el.on("change", ".category-item input", function(event) {
          var getActivePermissions, onError, onSuccess, target;
          getActivePermissions = function() {
            var activePermissions;
            activePermissions = _.filter($el.find(".category-item input"), function(t) {
              return angular.element(t).is(":checked");
            });
            activePermissions = _.sortBy(_.map(activePermissions, function(t) {
              var permission;
              return permission = angular.element(t).parents(".category-item").data("id");
            }));
            if (activePermissions.length) {
              activePermissions.push("view_project");
            }
            return activePermissions;
          };
          target = angular.element(event.currentTarget);
          $scope.role.permissions = getActivePermissions();
          onSuccess = function() {
            var categories, categoryId;
            categories = generateCategoriesFromRole($scope.role);
            categoryId = target.parents(".category-config").data("id");
            renderResume(target.parents(".category-config"), categories[categoryId]);
            $rootscope.$broadcast("projects:reload");
            $confirm.notify("success");
            return $ctrl.forceLoadProject();
          };
          onError = function() {
            $confirm.notify("error");
            target.prop("checked", !target.prop("checked"));
            return $scope.role.permissions = getActivePermissions();
          };
          if ($scope.role.external_user) {
            $scope.project.public_permissions = $scope.role.permissions;
            $scope.project.anon_permissions = $scope.role.permissions.filter(function(permission) {
              return permission.indexOf("view_") === 0;
            });
            return $repo.save($scope.project).then(onSuccess, onError);
          } else {
            return $repo.save($scope.role).then(onSuccess, onError);
          }
        });
      };
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      $scope.$on("role:changed", function() {
        return renderPermissions();
      });
      return bindOnce($scope, $attrs.ngModel, renderPermissions);
    };
    return {
      link: link
    };
  };

  module.directive("tgRolePermissions", ["$rootScope", "$tgRepo", "$tgConfirm", "$compile", RolePermissionsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/admin/third-parties.coffee
 */

(function() {
  var BitbucketController, BitbucketWebhooksDirective, GithubController, GithubWebhooksDirective, GitlabController, GitlabWebhooksDirective, GogsController, GogsWebhooksDirective, NewWebhookDirective, SelectInputText, ValidOriginIpsDirective, WebhookDirective, WebhooksController, bindMethods, debounce, mixOf, module, taiga, timeout,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  bindMethods = this.taiga.bindMethods;

  debounce = this.taiga.debounce;

  timeout = this.taiga.timeout;

  module = angular.module("taigaAdmin");

  WebhooksController = (function(superClass) {
    extend(WebhooksController, superClass);

    WebhooksController.$inject = ["$scope", "$tgRepo", "$tgResources", "$routeParams", "$tgLocation", "$tgNavUrls", "tgAppMetaService", "$translate", "tgErrorHandlingService", "tgProjectService"];

    function WebhooksController(scope, repo, rs, params, location, navUrls, appMetaService, translate, errorHandlingService, projectService) {
      var promise;
      this.scope = scope;
      this.repo = repo;
      this.rs = rs;
      this.params = params;
      this.location = location;
      this.navUrls = navUrls;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.projectService = projectService;
      bindMethods(this);
      this.scope.sectionName = "ADMIN.WEBHOOKS.SECTION_NAME";
      this.scope.project = {};
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("ADMIN.WEBHOOKS.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
      this.scope.$on("webhooks:reload", this.loadWebhooks);
    }

    WebhooksController.prototype.loadWebhooks = function() {
      return this.rs.webhooks.list(this.scope.projectId).then((function(_this) {
        return function(webhooks) {
          return _this.scope.webhooks = webhooks;
        };
      })(this));
    };

    WebhooksController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      if (!project.i_am_admin) {
        this.errorHandlingService.permissionDenied();
      }
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    WebhooksController.prototype.loadInitialData = function() {
      this.loadProject();
      return this.loadWebhooks();
    };

    return WebhooksController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  module.controller("WebhooksController", WebhooksController);

  WebhookDirective = function($rs, $repo, $confirm, $loading, $translate) {
    var link;
    link = function($scope, $el, $attrs) {
      var cancel, openHistory, save, showEditMode, showVisualizationMode, updateLogs, updateShowHideHistoryText, webhook;
      webhook = $scope.$eval($attrs.tgWebhook);
      updateLogs = function() {
        var prettyDate;
        prettyDate = $translate.instant("ADMIN.WEBHOOKS.DATE");
        return $rs.webhooklogs.list(webhook.id).then((function(_this) {
          return function(webhooklogs) {
            var i, len, log, ref;
            for (i = 0, len = webhooklogs.length; i < len; i++) {
              log = webhooklogs[i];
              log.validStatus = (200 <= (ref = log.status) && ref < 300);
              log.prettySentHeaders = _.map(_.toPairs(log.request_headers), function(arg) {
                var header, value;
                header = arg[0], value = arg[1];
                return header + ": " + value;
              }).join("\n");
              log.prettySentData = JSON.stringify(log.request_data);
              log.prettyDate = moment(log.created).format(prettyDate);
            }
            webhook.logs_counter = webhooklogs.length;
            webhook.logs = webhooklogs;
            return updateShowHideHistoryText();
          };
        })(this));
      };
      updateShowHideHistoryText = function() {
        var historyElement, text, textElement, title;
        textElement = $el.find(".toggle-history");
        historyElement = textElement.parents(".single-webhook-wrapper").find(".webhooks-history");
        if (historyElement.hasClass("open")) {
          text = $translate.instant("ADMIN.WEBHOOKS.ACTION_HIDE_HISTORY");
          title = $translate.instant("ADMIN.WEBHOOKS.ACTION_HIDE_HISTORY_TITLE");
        } else {
          text = $translate.instant("ADMIN.WEBHOOKS.ACTION_SHOW_HISTORY");
          title = $translate.instant("ADMIN.WEBHOOKS.ACTION_SHOW_HISTORY_TITLE");
        }
        textElement.text(text);
        return textElement.prop("title", title);
      };
      showVisualizationMode = function() {
        $el.find(".edition-mode").addClass("hidden");
        return $el.find(".visualization-mode").removeClass("hidden");
      };
      showEditMode = function() {
        $el.find(".visualization-mode").addClass("hidden");
        return $el.find(".edition-mode").removeClass("hidden");
      };
      openHistory = function() {
        return $el.find(".webhooks-history").addClass("open");
      };
      cancel = function() {
        showVisualizationMode();
        return $scope.$apply(function() {
          return webhook.revert();
        });
      };
      save = debounce(2000, function(target) {
        var form, promise;
        form = target.parents("form").checksley();
        if (!form.validate()) {
          return;
        }
        promise = $repo.save(webhook);
        promise.then((function(_this) {
          return function() {
            return showVisualizationMode();
          };
        })(this));
        return promise.then(null, function(data) {
          $confirm.notify("error");
          return form.setErrors(data);
        });
      });
      $el.on("click", ".test-webhook", function() {
        openHistory();
        return $rs.webhooks.test(webhook.id).then((function(_this) {
          return function() {
            return updateLogs();
          };
        })(this));
      });
      $el.on("click", ".edit-webhook", function() {
        return showEditMode();
      });
      $el.on("click", ".cancel-existing", function() {
        return cancel();
      });
      $el.on("click", ".edit-existing", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        return save(target);
      });
      $el.on("keyup", ".edition-mode input", function(event) {
        var target;
        if (event.keyCode === 13) {
          target = angular.element(event.currentTarget);
          return save(target);
        } else if (event.keyCode === 27) {
          target = angular.element(event.currentTarget);
          return cancel(target);
        }
      });
      $el.on("click", ".delete-webhook", function() {
        var message, title;
        title = $translate.instant("ADMIN.WEBHOOKS.DELETE");
        message = $translate.instant("ADMIN.WEBHOOKS.WEBHOOK_NAME", {
          name: webhook.name
        });
        return $confirm.askOnDelete(title, message).then((function(_this) {
          return function(askResponse) {
            var onError, onSucces;
            onSucces = function() {
              askResponse.finish();
              return $scope.$emit("webhooks:reload");
            };
            onError = function() {
              askResponse.finish(false);
              return $confirm.notify("error");
            };
            return $repo.remove(webhook).then(onSucces, onError);
          };
        })(this));
      });
      $el.on("click", ".toggle-history", function(event) {
        var target;
        target = angular.element(event.currentTarget);
        if ((webhook.logs == null) || webhook.logs.length === 0) {
          return updateLogs().then(function() {
            return timeout(0, function() {
              $el.find(".webhooks-history").toggleClass("open").slideToggle();
              return updateShowHideHistoryText();
            });
          });
        } else {
          $el.find(".webhooks-history").toggleClass("open").slideToggle();
          return $scope.$apply(function() {
            return updateShowHideHistoryText();
          });
        }
      });
      $el.on("click", ".history-single", function(event) {
        var target;
        target = angular.element(event.currentTarget);
        target.toggleClass("history-single-open");
        return target.siblings(".history-single-response").toggleClass("open");
      });
      return $el.on("click", ".resend-request", function(event) {
        var log, target;
        target = angular.element(event.currentTarget);
        log = target.data("log");
        return $rs.webhooklogs.resend(log).then((function(_this) {
          return function() {
            return updateLogs();
          };
        })(this));
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgWebhook", ["$tgResources", "$tgRepo", "$tgConfirm", "$tgLoading", "$translate", WebhookDirective]);

  NewWebhookDirective = function($rs, $repo, $confirm, $loading, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var addWebhookDOMNode, formDOMNode, initializeNewValue, save, webhook;
      webhook = $scope.$eval($attrs.tgWebhook);
      formDOMNode = $el.find(".new-webhook-form");
      addWebhookDOMNode = $el.find(".add-webhook");
      initializeNewValue = function() {
        return $scope.newValue = {
          "name": "",
          "url": "",
          "key": ""
        };
      };
      initializeNewValue();
      $scope.$watch("webhooks", function(webhooks) {
        if (webhooks != null) {
          if (webhooks.length === 0) {
            formDOMNode.removeClass("hidden");
            addWebhookDOMNode.addClass("hidden");
            return formDOMNode.find("input")[0].focus();
          } else {
            formDOMNode.addClass("hidden");
            return addWebhookDOMNode.removeClass("hidden");
          }
        }
      });
      save = debounce(2000, function() {
        var form, promise;
        form = formDOMNode.checksley();
        if (!form.validate()) {
          return;
        }
        $scope.newValue.project = $scope.project.id;
        promise = $repo.create("webhooks", $scope.newValue);
        promise.then((function(_this) {
          return function() {
            $analytics.trackEvent("webhooks", "create", "Create new webhook", 1);
            $scope.$emit("webhooks:reload");
            return initializeNewValue();
          };
        })(this));
        return promise.then(null, function(data) {
          $confirm.notify("error");
          return form.setErrors(data);
        });
      });
      formDOMNode.on("click", ".add-new", function(event) {
        event.preventDefault();
        return save();
      });
      formDOMNode.on("keyup", "input", function(event) {
        if (event.keyCode === 13) {
          return save();
        }
      });
      formDOMNode.on("click", ".cancel-new", function(event) {
        return $scope.$apply(function() {
          initializeNewValue();
          if ($scope.webhooks.length >= 1) {
            return formDOMNode.addClass("hidden");
          }
        });
      });
      return addWebhookDOMNode.on("click", function(event) {
        formDOMNode.removeClass("hidden");
        return formDOMNode.find("input")[0].focus();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgNewWebhook", ["$tgResources", "$tgRepo", "$tgConfirm", "$tgLoading", "$tgAnalytics", NewWebhookDirective]);

  GithubController = (function(superClass) {
    extend(GithubController, superClass);

    GithubController.$inject = ["$scope", "$tgRepo", "$tgResources", "$routeParams", "tgAppMetaService", "$translate", "tgProjectService"];

    function GithubController(scope, repo, rs, params, appMetaService, translate, projectService) {
      var promise;
      this.scope = scope;
      this.repo = repo;
      this.rs = rs;
      this.params = params;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.projectService = projectService;
      bindMethods(this);
      this.scope.sectionName = this.translate.instant("ADMIN.GITHUB.SECTION_NAME");
      this.scope.project = {};
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("ADMIN.GITHUB.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    GithubController.prototype.loadModules = function() {
      return this.rs.modules.list(this.scope.projectId, "github").then((function(_this) {
        return function(github) {
          return _this.scope.github = github;
        };
      })(this));
    };

    GithubController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    GithubController.prototype.loadInitialData = function() {
      var promise;
      promise = this.loadProject();
      return this.loadModules();
    };

    return GithubController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  module.controller("GithubController", GithubController);

  GitlabController = (function(superClass) {
    extend(GitlabController, superClass);

    GitlabController.$inject = ["$scope", "$tgRepo", "$tgResources", "$routeParams", "tgAppMetaService", "$translate", "tgProjectService"];

    function GitlabController(scope, repo, rs, params, appMetaService, translate, projectService) {
      var promise;
      this.scope = scope;
      this.repo = repo;
      this.rs = rs;
      this.params = params;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.projectService = projectService;
      bindMethods(this);
      this.scope.sectionName = this.translate.instant("ADMIN.GITLAB.SECTION_NAME");
      this.scope.project = {};
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("ADMIN.GITLAB.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
      this.scope.$on("project:modules:reload", (function(_this) {
        return function() {
          return _this.loadModules();
        };
      })(this));
    }

    GitlabController.prototype.loadModules = function() {
      return this.rs.modules.list(this.scope.projectId, "gitlab").then((function(_this) {
        return function(gitlab) {
          return _this.scope.gitlab = gitlab;
        };
      })(this));
    };

    GitlabController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    GitlabController.prototype.loadInitialData = function() {
      this.loadProject();
      return this.loadModules();
    };

    return GitlabController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  module.controller("GitlabController", GitlabController);

  BitbucketController = (function(superClass) {
    extend(BitbucketController, superClass);

    BitbucketController.$inject = ["$scope", "$tgRepo", "$tgResources", "$routeParams", "tgAppMetaService", "$translate", "tgProjectService"];

    function BitbucketController(scope, repo, rs, params, appMetaService, translate, projectService) {
      var promise;
      this.scope = scope;
      this.repo = repo;
      this.rs = rs;
      this.params = params;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.projectService = projectService;
      bindMethods(this);
      this.scope.sectionName = this.translate.instant("ADMIN.BITBUCKET.SECTION_NAME");
      this.scope.project = {};
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("ADMIN.BITBUCKET.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
      this.scope.$on("project:modules:reload", (function(_this) {
        return function() {
          return _this.loadModules();
        };
      })(this));
    }

    BitbucketController.prototype.loadModules = function() {
      return this.rs.modules.list(this.scope.projectId, "bitbucket").then((function(_this) {
        return function(bitbucket) {
          return _this.scope.bitbucket = bitbucket;
        };
      })(this));
    };

    BitbucketController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    BitbucketController.prototype.loadInitialData = function() {
      this.loadProject();
      return this.loadModules();
    };

    return BitbucketController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  module.controller("BitbucketController", BitbucketController);

  SelectInputText = function($translate, $confirm) {
    var link;
    link = function($scope, $el, $attrs) {
      return $el.on("click", ".select-input-content", function() {
        var source;
        source = $el.find("input");
        if (!source.val()) {
          return;
        }
        source.select();
        document.execCommand('copy');
        return $confirm.notify("success", $translate.instant("COMMON.COPIED_TO_CLIPBOARD"));
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgSelectInputText", ["$translate", "$tgConfirm", SelectInputText]);

  GithubWebhooksDirective = function($repo, $confirm, $loading, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, submit, submitButton;
      form = $el.find("form").checksley({
        "onlyOneErrorElement": true
      });
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          promise = $repo.saveAttribute($scope.github, "github");
          promise.then(function() {
            $analytics.trackEvent("github-webhook", "created-or-changed", "Create or changed github webhook", 1);
            currentLoading.finish();
            return $confirm.notify("success");
          });
          return promise.then(null, function(data) {
            currentLoading.finish();
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("error", data._error_message);
            }
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      return $el.on("submit", "form", submit);
    };
    return {
      link: link
    };
  };

  module.directive("tgGithubWebhooks", ["$tgRepo", "$tgConfirm", "$tgLoading", "$tgAnalytics", GithubWebhooksDirective]);

  GitlabWebhooksDirective = function($repo, $confirm, $loading, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, submit, submitButton;
      form = $el.find("form").checksley({
        "onlyOneErrorElement": true
      });
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          promise = $repo.saveAttribute($scope.gitlab, "gitlab");
          promise.then(function() {
            $analytics.trackEvent("gitlab-webhook", "created-or-changed", "Create or changed gitlab webhook", 1);
            currentLoading.finish();
            $confirm.notify("success");
            return $scope.$emit("project:modules:reload");
          });
          return promise.then(null, function(data) {
            currentLoading.finish();
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("error", data._error_message);
            }
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      return $el.on("submit", "form", submit);
    };
    return {
      link: link
    };
  };

  module.directive("tgGitlabWebhooks", ["$tgRepo", "$tgConfirm", "$tgLoading", "$tgAnalytics", GitlabWebhooksDirective]);

  BitbucketWebhooksDirective = function($repo, $confirm, $loading, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, submit, submitButton;
      form = $el.find("form").checksley({
        "onlyOneErrorElement": true
      });
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          promise = $repo.saveAttribute($scope.bitbucket, "bitbucket");
          promise.then(function() {
            $analytics.trackEvent("bitbucket-webhook", "created-or-changed", "Create or changed bitbucket webhook", 1);
            currentLoading.finish();
            $confirm.notify("success");
            return $scope.$emit("project:modules:reload");
          });
          return promise.then(null, function(data) {
            currentLoading.finish();
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("error", data._error_message);
            }
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      return $el.on("submit", "form", submit);
    };
    return {
      link: link
    };
  };

  module.directive("tgBitbucketWebhooks", ["$tgRepo", "$tgConfirm", "$tgLoading", "$tgAnalytics", BitbucketWebhooksDirective]);

  ValidOriginIpsDirective = function() {
    var link;
    link = function($scope, $el, $attrs, $ngModel) {
      return $ngModel.$parsers.push(function(value) {
        value = $.trim(value);
        if (value === "") {
          return [];
        }
        return value.split(",");
      });
    };
    return {
      link: link,
      restrict: "EA",
      require: "ngModel"
    };
  };

  module.directive("tgValidOriginIps", ValidOriginIpsDirective);

  GogsController = (function(superClass) {
    extend(GogsController, superClass);

    GogsController.$inject = ["$scope", "$tgRepo", "$tgResources", "$routeParams", "tgAppMetaService", "$translate", "tgProjectService"];

    function GogsController(scope, repo, rs, params, appMetaService, translate, projectService) {
      var promise;
      this.scope = scope;
      this.repo = repo;
      this.rs = rs;
      this.params = params;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.projectService = projectService;
      bindMethods(this);
      this.scope.sectionName = this.translate.instant("ADMIN.GOGS.SECTION_NAME");
      this.scope.project = {};
      promise = this.loadInitialData();
      promise.then((function(_this) {
        return function() {
          var description, title;
          title = _this.translate.instant("ADMIN.GOGS.PAGE_TITLE", {
            projectName: _this.scope.project.name
          });
          description = _this.scope.project.description;
          return _this.appMetaService.setAll(title, description);
        };
      })(this));
      promise.then(null, this.onInitialDataError.bind(this));
    }

    GogsController.prototype.loadModules = function() {
      return this.rs.modules.list(this.scope.projectId, "gogs").then((function(_this) {
        return function(gogs) {
          return _this.scope.gogs = gogs;
        };
      })(this));
    };

    GogsController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      return project;
    };

    GogsController.prototype.loadInitialData = function() {
      this.loadProject();
      return this.loadModules();
    };

    return GogsController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  GogsWebhooksDirective = function($repo, $confirm, $loading, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var form, submit, submitButton;
      form = $el.find("form").checksley({
        "onlyOneErrorElement": true
      });
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          promise = $repo.saveAttribute($scope.gogs, "gogs");
          promise.then(function() {
            $analytics.trackEvent("gogs-webhook", "create-or-change", "Create or change gogs webhook", 1);
            currentLoading.finish();
            $confirm.notify("success");
            return $scope.$emit("project:modules:reload");
          });
          return promise.then(null, function(data) {
            currentLoading.finish();
            form.setErrors(data);
            if (data._error_message) {
              return $confirm.notify("error", data._error_message);
            }
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      $el.on("submit", "form", submit);
      return $el.on("click", ".submit-button", submit);
    };
    return {
      link: link
    };
  };

  module.controller("GogsController", GogsController);

  module.directive("tgGogsWebhooks", ["$tgRepo", "$tgConfirm", "$tgLoading", "$tgAnalytics", GogsWebhooksDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/projects/lightboxes.coffee
 */

(function() {
  var DeleteProjectDirective, bindOnce, debounce, module, taiga, timeout;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  timeout = this.taiga.timeout;

  debounce = this.taiga.debounce;

  module = angular.module("taigaProject");

  DeleteProjectDirective = function($repo, $rootscope, $auth, $location, $navUrls, $confirm, lightboxService, tgLoader, currentUserService, $analytics) {
    var link;
    link = function($scope, $el, $attrs) {
      var projectToDelete, submit;
      projectToDelete = null;
      $scope.$on("deletelightbox:new", function(ctx, project) {
        lightboxService.open($el);
        return projectToDelete = project;
      });
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      submit = function() {
        var promise;
        tgLoader.start();
        lightboxService.close($el);
        promise = $repo.remove(projectToDelete);
        promise.then(function(data) {
          $analytics.trackEvent("projects", "delete", "Delete project", 1);
          tgLoader.pageLoaded();
          $rootscope.$broadcast("projects:reload");
          $location.path($navUrls.resolve("home"));
          $confirm.notify("success");
          return currentUserService.loadProjects();
        });
        return promise.then(null, function() {
          $confirm.notify("error");
          return lightboxService.close($el);
        });
      };
      $el.on("click", ".button-red", function(event) {
        event.preventDefault();
        return lightboxService.close($el);
      });
      return $el.on("click", ".button-green", function(event) {
        event.preventDefault();
        return submit();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgLbDeleteProject", ["$tgRepo", "$rootScope", "$tgAuth", "$tgLocation", "$tgNavUrls", "$tgConfirm", "lightboxService", "tgLoader", "tgCurrentUserService", "$tgAnalytics", DeleteProjectDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/bind.coffee
 */

(function() {
  var BindHtmlDirective, BindOnceAltDirective, BindOnceBindDirective, BindOnceHrefDirective, BindOnceHtmlDirective, BindOnceRefDirective, BindOnceSrcDirective, BindOnceTitleDirective, BindTitleDirective, bindOnce, module;

  bindOnce = this.taiga.bindOnce;

  BindOnceBindDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, $attrs.tgBoBind, function(val) {
        return $el.text(val);
      });
    };
    return {
      link: link
    };
  };

  BindOnceHtmlDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, $attrs.tgBoHtml, function(val) {
        return $el.html(val);
      });
    };
    return {
      link: link
    };
  };

  BindOnceRefDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, $attrs.tgBoRef, function(val) {
        return $el.html("#" + val + " ");
      });
    };
    return {
      link: link
    };
  };

  BindOnceSrcDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, $attrs.tgBoSrc, function(val) {
        return $el.attr("src", val);
      });
    };
    return {
      link: link
    };
  };

  BindOnceHrefDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, $attrs.tgBoHref, function(val) {
        return $el.attr("href", val);
      });
    };
    return {
      link: link
    };
  };

  BindOnceAltDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, $attrs.tgBoAlt, function(val) {
        return $el.attr("alt", val);
      });
    };
    return {
      link: link
    };
  };

  BindOnceTitleDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return bindOnce($scope, $attrs.tgBoTitle, function(val) {
        return $el.attr("title", val);
      });
    };
    return {
      link: link
    };
  };

  BindTitleDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return $scope.$watch($attrs.tgTitleHtml, function(val) {
        if (val != null) {
          return $el.attr("title", val);
        }
      });
    };
    return {
      link: link
    };
  };

  BindHtmlDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return $scope.$watch($attrs.tgBindHtml, function(val) {
        if (val != null) {
          return $el.html(val);
        }
      });
    };
    return {
      link: link
    };
  };

  module = angular.module("taigaBase");

  module.directive("tgBoBind", BindOnceBindDirective);

  module.directive("tgBoHtml", BindOnceHtmlDirective);

  module.directive("tgBoRef", BindOnceRefDirective);

  module.directive("tgBoSrc", BindOnceSrcDirective);

  module.directive("tgBoHref", BindOnceHrefDirective);

  module.directive("tgBoAlt", BindOnceAltDirective);

  module.directive("tgBoTitle", BindOnceTitleDirective);

  module.directive("tgBindTitle", BindTitleDirective);

  module.directive("tgBindHtml", BindHtmlDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/conf.coffee
 */

(function() {
  var ConfigurationService, module;

  ConfigurationService = (function() {
    function ConfigurationService() {
      this.config = window.taigaConfig;
    }

    ConfigurationService.prototype.get = function(key, defaultValue) {
      if (defaultValue == null) {
        defaultValue = null;
      }
      if (_.has(this.config, key)) {
        return this.config[key];
      }
      return defaultValue;
    };

    return ConfigurationService;

  })();

  module = angular.module("taigaBase");

  module.service("$tgConfig", ConfigurationService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/contrib.coffee
 */

(function() {
  var ContribController, ContribUserSettingsController, module,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  module = angular.module("taigaBase");

  ContribController = (function(superClass) {
    extend(ContribController, superClass);

    ContribController.$inject = ["$rootScope", "$scope", "$routeParams", "$tgRepo", "$tgResources", "$tgConfirm", "tgProjectService"];

    function ContribController(rootScope, scope, params, repo, rs, confirm, projectService) {
      this.rootScope = rootScope;
      this.scope = scope;
      this.params = params;
      this.repo = repo;
      this.rs = rs;
      this.confirm = confirm;
      this.projectService = projectService;
      this.scope.currentPlugin = _.head(_.filter(this.rootScope.adminPlugins, {
        "slug": this.params.plugin
      }));
      this.scope.projectSlug = this.params.pslug;
      this.loadInitialData();
    }

    ContribController.prototype.loadProject = function() {
      var project;
      project = this.projectService.project.toJS();
      this.scope.projectId = project.id;
      this.scope.project = project;
      this.scope.$emit('project:loaded', project);
      this.scope.$broadcast('project:loaded', project);
      return project;
    };

    ContribController.prototype.loadInitialData = function() {
      return this.loadProject();
    };

    return ContribController;

  })(taiga.Controller);

  module.controller("ContribController", ContribController);

  ContribUserSettingsController = (function(superClass) {
    extend(ContribUserSettingsController, superClass);

    ContribUserSettingsController.$inject = ["$rootScope", "$scope", "$routeParams"];

    function ContribUserSettingsController(rootScope, scope, params) {
      this.rootScope = rootScope;
      this.scope = scope;
      this.params = params;
      this.scope.currentPlugin = _.head(_.filter(this.rootScope.userSettingsPlugins, {
        "slug": this.params.plugin
      }));
    }

    return ContribUserSettingsController;

  })(taiga.Controller);

  module.controller("ContribUserSettingsController", ContribUserSettingsController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/filters.coffee
 */

(function() {
  var FiltersStorageService, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  FiltersStorageService = (function(superClass) {
    extend(FiltersStorageService, superClass);

    FiltersStorageService.$inject = ["$tgStorage", "$routeParams"];

    function FiltersStorageService(storage, params) {
      this.storage = storage;
      this.params = params;
    }

    FiltersStorageService.prototype.generateHash = function(components) {
      if (components == null) {
        components = [];
      }
      components = _.map(components, function(x) {
        return JSON.stringify(x);
      });
      return hex_sha1(components.join(":"));
    };

    return FiltersStorageService;

  })(taiga.Service);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/http.coffee
 */

(function() {
  var HttpService, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  HttpService = (function(superClass) {
    extend(HttpService, superClass);

    HttpService.$inject = ["$http", "$q", "tgLoader", "$tgStorage", "$rootScope", "$cacheFactory", "$translate"];

    function HttpService(http, q, tgLoader, storage, rootScope, cacheFactory, translate) {
      this.http = http;
      this.q = q;
      this.tgLoader = tgLoader;
      this.storage = storage;
      this.rootScope = rootScope;
      this.cacheFactory = cacheFactory;
      this.translate = translate;
      HttpService.__super__.constructor.call(this);
      this.cache = this.cacheFactory("httpget");
    }

    HttpService.prototype.headers = function() {
      var headers, lang, token;
      headers = {};
      token = this.storage.get('token');
      if (token) {
        headers["Authorization"] = "Bearer " + token;
      }
      lang = this.translate.preferredLanguage();
      if (lang) {
        headers["Accept-Language"] = lang;
      }
      return headers;
    };

    HttpService.prototype.request = function(options) {
      options.headers = _.assign({}, options.headers || {}, this.headers());
      return this.http(options);
    };

    HttpService.prototype.get = function(url, params, options) {
      options = _.assign({
        method: "GET",
        url: url
      }, options);
      if (params) {
        options.params = params;
      }
      options.cache = this.cache;
      return this.request(options)["finally"]((function(_this) {
        return function(data) {
          return _this.cache.removeAll();
        };
      })(this));
    };

    HttpService.prototype.post = function(url, data, params, options) {
      options = _.assign({
        method: "POST",
        url: url
      }, options);
      if (data) {
        options.data = data;
      }
      if (params) {
        options.params = params;
      }
      options.responseType = 'text';
      return this.request(options);
    };

    HttpService.prototype.put = function(url, data, params, options) {
      options = _.assign({
        method: "PUT",
        url: url
      }, options);
      if (data) {
        options.data = data;
      }
      if (params) {
        options.params = params;
      }
      return this.request(options);
    };

    HttpService.prototype.patch = function(url, data, params, options) {
      options = _.assign({
        method: "PATCH",
        url: url
      }, options);
      if (data) {
        options.data = data;
      }
      if (params) {
        options.params = params;
      }
      return this.request(options);
    };

    HttpService.prototype["delete"] = function(url, data, params, options) {
      options = _.assign({
        method: "DELETE",
        url: url
      }, options);
      if (data) {
        options.data = data;
      }
      if (params) {
        options.params = params;
      }
      return this.request(options);
    };

    return HttpService;

  })(taiga.Service);

  module = angular.module("taigaBase");

  module.service("$tgHttp", HttpService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/location.coffee
 */

(function() {
  var locationFactory, module;

  locationFactory = function($location, $route, $rootscope) {
    $location.noreload = function(scope) {
      var lastRoute, un;
      lastRoute = $route.current;
      un = scope.$on("$locationChangeSuccess", function() {
        $route.current = lastRoute;
        return un();
      });
      return $location;
    };
    $location.isInCurrentRouteParams = function(name, value) {
      var params;
      params = $location.search() || {};
      return params[name] === value;
    };
    return $location;
  };

  module = angular.module("taigaBase");

  module.factory("$tgLocation", ["$location", "$route", "$rootScope", locationFactory]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/model.coffee
 */

(function() {
  var Model, ModelService, module, provider, taiga,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Model = (function() {
    function Model(name, data, dataTypes) {
      this._attrs = data;
      this._name = name;
      this._dataTypes = dataTypes;
      this.setAttrs(data);
      this.initialize();
    }

    Model.prototype.realClone = function() {
      var attrs, instance;
      attrs = _.cloneDeep(this._attrs);
      instance = new Model(this._name, attrs, this._dataTypes);
      instance._modifiedAttrs = _.cloneDeep(this._modifiedAttrs);
      instance._isModified = _.cloneDeep(this._isModified);
      return instance;
    };

    Model.prototype.clone = function() {
      var instance;
      instance = new Model(this._name, this._attrs, this._dataTypes);
      instance._modifiedAttrs = this._modifiedAttrs;
      instance._isModified = this._isModified;
      return instance;
    };

    Model.prototype.applyCasts = function() {
      var attrName, castMethod, castName, ref, results;
      ref = this._dataTypes;
      results = [];
      for (attrName in ref) {
        castName = ref[attrName];
        castMethod = service.casts[castName];
        if (!castMethod) {
          continue;
        }
        results.push(this._attrs[attrName] = castMethod(this._attrs[attrName]));
      }
      return results;
    };

    Model.prototype.getIdAttrName = function() {
      return "id";
    };

    Model.prototype.getName = function() {
      return this._name;
    };

    Model.prototype.getAttrs = function(patch) {
      if (patch == null) {
        patch = false;
      }
      if (this._attrs.version != null) {
        this._modifiedAttrs.version = this._attrs.version;
      }
      if (patch) {
        return _.extend({}, this._modifiedAttrs);
      }
      return _.extend({}, this._attrs, this._modifiedAttrs);
    };

    Model.prototype.setAttrs = function(attrs) {
      this._attrs = attrs;
      this._modifiedAttrs = {};
      this.applyCasts();
      return this._isModified = false;
    };

    Model.prototype.setAttr = function(name, value) {
      this._modifiedAttrs[name] = value;
      return this._isModified = true;
    };

    Model.prototype.initialize = function() {
      var getter, self, setter;
      self = this;
      getter = function(name) {
        return function() {
          if (typeof name === 'string' && name.substr(0, 2) === "__") {
            return self[name];
          }
          if (indexOf.call(_.keys(self._modifiedAttrs), name) < 0) {
            return self._attrs[name];
          }
          return self._modifiedAttrs[name];
        };
      };
      setter = function(name) {
        return function(value) {
          if (typeof name === 'string' && name.substr(0, 2) === "__") {
            self[name] = value;
            return;
          }
          if (self._attrs[name] !== value) {
            self._modifiedAttrs[name] = value;
            self._isModified = true;
          } else {
            delete self._modifiedAttrs[name];
          }
        };
      };
      return _.each(this._attrs, function(value, name) {
        var options;
        options = {
          get: getter(name),
          set: setter(name),
          enumerable: true,
          configurable: true
        };
        return Object.defineProperty(self, name, options);
      });
    };

    Model.prototype.serialize = function() {
      var data;
      data = {
        "data": _.clone(this._attrs),
        "name": this._name
      };
      return JSON.stringify(data);
    };

    Model.prototype.isModified = function() {
      return this._isModified;
    };

    Model.prototype.isAttributeModified = function(attribute) {
      return this._modifiedAttrs[attribute] != null;
    };

    Model.prototype.markSaved = function() {
      this._isModified = false;
      this._attrs = this.getAttrs();
      return this._modifiedAttrs = {};
    };

    Model.prototype.revert = function() {
      this._modifiedAttrs = {};
      return this._isModified = false;
    };

    Model.desSerialize = function(sdata) {
      var ddata, model;
      ddata = JSON.parse(sdata);
      model = new Model(ddata.url, ddata.data);
      return model;
    };

    return Model;

  })();

  taiga = this.taiga;

  ModelService = (function(superClass) {
    extend(ModelService, superClass);

    ModelService.$inject = ["$q", "$tgUrls", "$tgStorage", "$tgHttp"];

    function ModelService(q, urls, storage, http) {
      this.q = q;
      this.urls = urls;
      this.storage = storage;
      this.http = http;
      ModelService.__super__.constructor.call(this);
    }

    return ModelService;

  })(taiga.Service);

  provider = function($q, $http, $gmUrls, $gmStorage) {
    var service;
    service = {};
    service.make_model = function(name, data, cls, dataTypes) {
      if (cls == null) {
        cls = Model;
      }
      if (dataTypes == null) {
        dataTypes = {};
      }
      return new cls(name, data, dataTypes);
    };
    service.cls = Model;
    service.casts = {
      int: function(value) {
        return parseInt(value, 10);
      },
      float: function(value) {
        return parseFloat(value, 10);
      }
    };
    return service;
  };

  module = angular.module("taigaBase");

  module.factory("$tgModel", ["$q", "$http", "$tgUrls", "$tgStorage", provider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/navurls.coffee
 */

(function() {
  var NavigationUrlsDirective, NavigationUrlsService, bindOnce, module, taiga, trim,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  trim = this.taiga.trim;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaBase");

  NavigationUrlsService = (function(superClass) {
    extend(NavigationUrlsService, superClass);

    function NavigationUrlsService() {
      this.urls = {};
    }

    NavigationUrlsService.prototype.update = function(urls) {
      return this.urls = _.merge({}, this.urls, urls || {});
    };

    NavigationUrlsService.prototype.formatUrl = function(url, ctx) {
      var replacer;
      if (ctx == null) {
        ctx = {};
      }
      replacer = function(match) {
        match = trim(match, ":");
        return ctx[match] || "undefined";
      };
      return url.replace(/(:\w+)/g, replacer);
    };

    NavigationUrlsService.prototype.resolve = function(name, ctx) {
      var url;
      url = this.urls[name];
      if (!url) {
        return "";
      }
      if (ctx) {
        return this.formatUrl(url, ctx);
      }
      return url;
    };

    return NavigationUrlsService;

  })(taiga.Service);

  module.service("$tgNavUrls", NavigationUrlsService);

  NavigationUrlsDirective = function($navurls, $auth, $q, $location, lightboxService, tgSections) {
    var bindOnceP, link, parseNav;
    bindOnceP = function($scope, attr) {
      var defered;
      defered = $q.defer();
      bindOnce($scope, attr, function(v) {
        return defered.resolve(v);
      });
      return defered.promise;
    };
    parseNav = function(data, $scope) {
      var index, name, obj, params, promises, ref, result, values;
      ref = _.map(data.split(":"), trim), name = ref[0], params = ref[1];
      if (params) {
        result = params.split(/(\w+)=/);
        result = _.filter(result, function(str) {
          return str.length;
        });
        result = _.map(result, function(str) {
          return trim(str.replace(/,$/g, ''));
        });
        params = [];
        index = 0;
        while (index < result.length) {
          obj = {};
          obj[result[index]] = result[index + 1];
          params.push(obj);
          index = index + 2;
        }
      } else {
        params = [];
      }
      values = _.map(params, function(param) {
        return _.values(param)[0];
      });
      promises = _.map(values, function(x) {
        return bindOnceP($scope, x);
      });
      return $q.all(promises).then(function() {
        var i, key, len, options, param, value;
        options = {};
        for (i = 0, len = params.length; i < len; i++) {
          param = params[i];
          key = Object.keys(param)[0];
          value = param[key];
          options[key] = $scope.$eval(value);
        }
        return [name, options];
      });
    };
    link = function($scope, $el, $attrs) {
      if ($el.is("a")) {
        $el.attr("href", "#");
      }
      $el.on("mouseenter", function(event) {
        var target;
        target = $(event.currentTarget);
        if (!target.data("fullUrl") || $attrs.tgNavGetParams !== target.data("params")) {
          return parseNav($attrs.tgNav, $scope).then(function(result) {
            var fullUrl, getURLParams, getURLParamsStr, name, options, path, url, user;
            name = result[0], options = result[1];
            user = $auth.getUser();
            if (user) {
              options.user = user.username;
            }
            if (name === 'project') {
              path = tgSections.getPath(options['project'], options['section']);
              name = name + "-" + path;
            }
            url = $navurls.resolve(name);
            fullUrl = $navurls.formatUrl(url, options);
            if ($attrs.tgNavGetParams) {
              getURLParams = JSON.parse($attrs.tgNavGetParams);
              getURLParamsStr = $.param(getURLParams);
              fullUrl = fullUrl + "?" + getURLParamsStr;
              target.data("params", $attrs.tgNavGetParams);
            }
            target.data("fullUrl", fullUrl);
            if (target.is("a")) {
              target.attr("href", fullUrl);
            }
            return $el.on("click", function(event) {
              if (event.metaKey || event.ctrlKey) {
                return;
              }
              event.preventDefault();
              target = $(event.currentTarget);
              if (target.hasClass('noclick')) {
                return;
              }
              fullUrl = target.data("fullUrl");
              switch (event.which) {
                case 1:
                  $location.url(fullUrl);
                  $scope.$apply();
                  break;
                case 2:
                  window.open(fullUrl);
              }
              return lightboxService.closeAll();
            });
          });
        }
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgNav", ["$tgNavUrls", "$tgAuth", "$q", "$tgLocation", "lightboxService", "$tgSections", NavigationUrlsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/repository.coffee
 */

(function() {
  var RepositoryService, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  RepositoryService = (function(superClass) {
    extend(RepositoryService, superClass);

    RepositoryService.$inject = ["$q", "$tgModel", "$tgStorage", "$tgHttp", "$tgUrls"];

    function RepositoryService(q, model1, storage, http, urls) {
      this.q = q;
      this.model = model1;
      this.storage = storage;
      this.http = http;
      this.urls = urls;
      RepositoryService.__super__.constructor.call(this);
    }

    RepositoryService.prototype.resolveUrlForModel = function(model) {
      var idAttrName;
      idAttrName = model.getIdAttrName();
      return (this.urls.resolve(model.getName())) + "/" + model[idAttrName];
    };

    RepositoryService.prototype.resolveUrlForAttributeModel = function(model) {
      return this.urls.resolve(model.getName(), model.parent);
    };

    RepositoryService.prototype.create = function(name, data, dataTypes, extraParams) {
      var defered, promise, url;
      if (dataTypes == null) {
        dataTypes = {};
      }
      if (extraParams == null) {
        extraParams = {};
      }
      defered = this.q.defer();
      url = this.urls.resolve(name);
      promise = this.http.post(url, JSON.stringify(data), extraParams);
      promise.success((function(_this) {
        return function(_data, _status) {
          return defered.resolve(_this.model.make_model(name, _data, null, dataTypes));
        };
      })(this));
      promise.error((function(_this) {
        return function(data, status) {
          return defered.reject(data);
        };
      })(this));
      return defered.promise;
    };

    RepositoryService.prototype.remove = function(model, params) {
      var defered, promise, url;
      if (params == null) {
        params = {};
      }
      defered = this.q.defer();
      url = this.resolveUrlForModel(model);
      promise = this.http["delete"](url, {}, params);
      promise.success(function(data, status) {
        return defered.resolve(model);
      });
      promise.error(function(data, status) {
        return defered.reject(model);
      });
      return defered.promise;
    };

    RepositoryService.prototype.saveAll = function(models, patch) {
      var promises;
      if (patch == null) {
        patch = true;
      }
      promises = _.map(models, (function(_this) {
        return function(x) {
          return _this.save(x, true);
        };
      })(this));
      return this.q.all(promises);
    };

    RepositoryService.prototype.save = function(model, patch, params, options, returnHeaders) {
      var data, defered, promise, url;
      if (patch == null) {
        patch = true;
      }
      if (params == null) {
        params = {};
      }
      if (returnHeaders == null) {
        returnHeaders = false;
      }
      defered = this.q.defer();
      if (!model.isModified() && patch) {
        defered.resolve(model);
        return defered.promise;
      }
      url = this.resolveUrlForModel(model);
      data = JSON.stringify(model.getAttrs(patch));
      if (patch) {
        promise = this.http.patch(url, data, params, options);
      } else {
        promise = this.http.put(url, data, params, options);
      }
      promise.success((function(_this) {
        return function(data, status, headers, response) {
          model._isModified = false;
          model._attrs = _.extend(model.getAttrs(), data);
          model._modifiedAttrs = {};
          model.applyCasts();
          if (returnHeaders) {
            return defered.resolve([model, headers()]);
          } else {
            return defered.resolve(model);
          }
        };
      })(this));
      promise.error(function(data, status) {
        return defered.reject(data);
      });
      return defered.promise;
    };

    RepositoryService.prototype.saveAttribute = function(model, attribute, patch) {
      var data, defered, promise, url;
      if (patch == null) {
        patch = true;
      }
      defered = this.q.defer();
      if (!(model != null ? model.isModified() : void 0) && patch) {
        defered.resolve(model);
        return defered.promise;
      }
      url = this.resolveUrlForAttributeModel(model);
      data = {};
      data[attribute] = model.getAttrs();
      if (patch) {
        promise = this.http.patch(url, data);
      } else {
        promise = this.http.put(url, data);
      }
      promise.success((function(_this) {
        return function(data, status) {
          model._isModified = false;
          model._attrs = _.extend(model.getAttrs(), data);
          model._modifiedAttrs = {};
          model.applyCasts();
          return defered.resolve(model);
        };
      })(this));
      promise.error(function(data, status) {
        return defered.reject(data);
      });
      return defered.promise;
    };

    RepositoryService.prototype.refresh = function(model) {
      var defered, promise, url;
      defered = this.q.defer();
      url = this.resolveUrlForModel(model);
      promise = this.http.get(url);
      promise.success(function(data, status) {
        model._modifiedAttrs = {};
        model._attrs = data;
        model._isModified = false;
        model.applyCasts();
        return defered.resolve(model);
      });
      promise.error(function(data, status) {
        return defered.reject(data);
      });
      return defered.promise;
    };

    RepositoryService.prototype.queryMany = function(name, params, options, headers) {
      var httpOptions, url;
      if (options == null) {
        options = {};
      }
      if (headers == null) {
        headers = false;
      }
      url = this.urls.resolve(name);
      httpOptions = {
        headers: {}
      };
      if (!options.enablePagination) {
        httpOptions.headers["x-disable-pagination"] = "1";
      }
      return this.http.get(url, params, httpOptions).then((function(_this) {
        return function(data) {
          var result;
          result = _.map(data.data, function(x) {
            return _this.model.make_model(name, x);
          });
          if (headers) {
            return [result, data.headers];
          }
          return result;
        };
      })(this));
    };

    RepositoryService.prototype.queryOneAttribute = function(name, id, attribute, params, options) {
      var httpOptions, url;
      if (options == null) {
        options = {};
      }
      url = this.urls.resolve(name, id);
      httpOptions = {
        headers: {}
      };
      if (!options.enablePagination) {
        httpOptions.headers["x-disable-pagination"] = "1";
      }
      return this.http.get(url, params, httpOptions).then((function(_this) {
        return function(data) {
          var model;
          model = _this.model.make_model(name, data.data[attribute]);
          model.parent = id;
          return model;
        };
      })(this));
    };

    RepositoryService.prototype.queryOne = function(name, id, params, options) {
      var httpOptions, url;
      if (options == null) {
        options = {};
      }
      url = this.urls.resolve(name);
      if (id) {
        url = url + "/" + id;
      }
      httpOptions = {
        headers: {}
      };
      if (!options.enablePagination) {
        httpOptions.headers["x-disable-pagination"] = "1";
      }
      return this.http.get(url, params, httpOptions).then((function(_this) {
        return function(data) {
          return _this.model.make_model(name, data.data);
        };
      })(this));
    };

    RepositoryService.prototype.queryOneRaw = function(name, id, params, options) {
      var httpOptions, url;
      if (options == null) {
        options = {};
      }
      url = this.urls.resolve(name);
      if (id) {
        url = url + "/" + id;
      }
      httpOptions = _.merge({
        headers: {}
      }, options);
      if (!options.enablePagination) {
        httpOptions.headers["x-disable-pagination"] = "1";
      }
      return this.http.get(url, params, httpOptions).then((function(_this) {
        return function(data) {
          return data.data;
        };
      })(this));
    };

    RepositoryService.prototype.queryPaginated = function(name, params, options) {
      var httpOptions, url;
      if (options == null) {
        options = {};
      }
      url = this.urls.resolve(name);
      httpOptions = _.merge({
        headers: {}
      }, options);
      return this.http.get(url, params, httpOptions).then((function(_this) {
        return function(data) {
          var headers, result;
          headers = data.headers();
          result = {};
          result.models = _.map(data.data, function(x) {
            return _this.model.make_model(name, x);
          });
          result.count = parseInt(headers["x-pagination-count"], 10);
          result.current = parseInt(headers["x-pagination-current"] || 1, 10);
          result.paginatedBy = parseInt(headers["x-paginated-by"], 10);
          return result;
        };
      })(this));
    };

    RepositoryService.prototype.queryOnePaginatedRaw = function(name, id, params, options) {
      var httpOptions, url;
      if (options == null) {
        options = {};
      }
      url = this.urls.resolve(name);
      if (id) {
        url = url + "/" + id;
      }
      httpOptions = _.merge({
        headers: {}
      }, options);
      return this.http.get(url, params, httpOptions).then((function(_this) {
        return function(data) {
          var headers, result;
          headers = data.headers();
          result = {};
          result.data = data.data;
          result.count = parseInt(headers["x-pagination-count"], 10);
          result.current = parseInt(headers["x-pagination-current"] || 1, 10);
          result.paginatedBy = parseInt(headers["x-paginated-by"], 10);
          return result;
        };
      })(this));
    };

    RepositoryService.prototype.resolve = function(options) {
      var cache, params;
      params = {};
      if (options.pslug != null) {
        params.project = options.pslug;
      }
      if (options.usref != null) {
        params.us = options.usref;
      }
      if (options.taskref != null) {
        params.task = options.taskref;
      }
      if (options.issueref != null) {
        params.issue = options.issueref;
      }
      if (options.sslug != null) {
        params.milestone = options.sslug;
      }
      if (options.wikipage != null) {
        params.wikipage = options.wikipage;
      }
      if (options.ref != null) {
        params.ref = options.ref;
      }
      cache = !(options.wikipage || options.sslug);
      return this.queryOneRaw("resolver", null, params, {
        cache: cache
      });
    };

    return RepositoryService;

  })(taiga.Service);

  module = angular.module("taigaBase");

  module.service("$tgRepo", RepositoryService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/storage.coffee
 */

(function() {
  var StorageService, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  StorageService = (function(superClass) {
    extend(StorageService, superClass);

    StorageService.$inject = ["$rootScope"];

    function StorageService($rootScope) {
      StorageService.__super__.constructor.call(this);
    }

    StorageService.prototype.get = function(key, _default) {
      var serializedValue;
      serializedValue = localStorage.getItem(key);
      if (serializedValue === null) {
        return _default || null;
      }
      return JSON.parse(serializedValue);
    };

    StorageService.prototype.set = function(key, val) {
      if (_.isObject(key)) {
        return _.each(key, (function(_this) {
          return function(val, key) {
            return _this.set(key, val);
          };
        })(this));
      } else {
        return localStorage.setItem(key, JSON.stringify(val));
      }
    };

    StorageService.prototype.contains = function(key) {
      var value;
      value = this.get(key);
      return value !== null;
    };

    StorageService.prototype.remove = function(key) {
      return localStorage.removeItem(key);
    };

    StorageService.prototype.clear = function() {
      return localStorage.clear();
    };

    return StorageService;

  })(taiga.Service);

  module = angular.module("taigaBase");

  module.service("$tgStorage", StorageService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/base/urls.coffee
 */

(function() {
  var UrlsService, format, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  format = function(fmt, obj) {
    obj = _.clone(obj);
    return fmt.replace(/%s/g, function(match) {
      return String(obj.shift());
    });
  };

  taiga = this.taiga;

  UrlsService = (function(superClass) {
    extend(UrlsService, superClass);

    UrlsService.$inject = ["$tgConfig"];

    function UrlsService(config) {
      this.config = config;
      this.urls = {};
      this.mainUrl = this.config.get("api");
    }

    UrlsService.prototype.update = function(urls) {
      return this.urls = _.merge(this.urls, urls);
    };

    UrlsService.prototype.resolve = function() {
      var args, name, url;
      args = _.toArray(arguments);
      if (args.length === 0) {
        throw Error("wrong arguments to setUrls");
      }
      name = args.slice(0, 1)[0];
      url = format(this.urls[name], args.slice(1));
      return format("%s/%s", [_.trimEnd(this.mainUrl, "/"), _.trimStart(url, "/")]);
    };

    UrlsService.prototype.resolveAbsolute = function() {
      var url;
      url = this.resolve.apply(this, arguments);
      if (/^https?:\/\//i.test(url)) {
        return url;
      }
      if (/^\//.test(url)) {
        return window.location.protocol + "//" + window.location.host + url;
      }
      return window.location.protocol + "//" + window.location.host + "/" + url;
    };

    return UrlsService;

  })(taiga.Service);

  module = angular.module("taigaBase");

  module.service('$tgUrls', UrlsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/custom-attributes-values.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo) {
    var _get, service;
    _get = function(objectId, resource) {
      return $repo.queryOne(resource, objectId);
    };
    service = {
      epic: {
        get: function(objectId) {
          return _get(objectId, "custom-attributes-values/epic");
        }
      },
      userstory: {
        get: function(objectId) {
          return _get(objectId, "custom-attributes-values/userstory");
        }
      },
      task: {
        get: function(objectId) {
          return _get(objectId, "custom-attributes-values/task");
        }
      },
      issue: {
        get: function(objectId) {
          return _get(objectId, "custom-attributes-values/issue");
        }
      }
    };
    return function(instance) {
      return instance.customAttributesValues = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgCustomAttributesValuesResourcesProvider", ["$tgRepo", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/custom-attributes.coffee
 */

(function() {
  var module, resourceProvider, sizeFormat, taiga;

  taiga = this.taiga;

  sizeFormat = this.taiga.sizeFormat;

  resourceProvider = function($repo) {
    var _list, service;
    _list = function(projectId, resource) {
      return $repo.queryMany(resource, {
        project: projectId
      });
    };
    service = {
      epic: {
        list: function(projectId) {
          return _list(projectId, "custom-attributes/epic");
        }
      },
      userstory: {
        list: function(projectId) {
          return _list(projectId, "custom-attributes/userstory");
        }
      },
      task: {
        list: function(projectId) {
          return _list(projectId, "custom-attributes/task");
        }
      },
      issue: {
        list: function(projectId) {
          return _list(projectId, "custom-attributes/issue");
        }
      }
    };
    return function(instance) {
      return instance.customAttributes = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgCustomAttributesResourcesProvider", ["$tgRepo", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/epics.coffee
 */

(function() {
  var generateHash, module, resourceProvider, taiga;

  taiga = this.taiga;

  generateHash = taiga.generateHash;

  resourceProvider = function($repo, $http, $urls, $storage) {
    var hashSuffix, service;
    service = {};
    hashSuffix = "epics-queryparams";
    service.getByRef = function(projectId, ref) {
      var params;
      params = service.getQueryParams(projectId);
      params.project = projectId;
      params.ref = ref;
      return $repo.queryOne("epics", "by_ref", params);
    };
    service.listValues = function(projectId, type) {
      var params;
      params = {
        "project": projectId
      };
      service.storeQueryParams(projectId, params);
      return $repo.queryMany(type, params);
    };
    service.storeQueryParams = function(projectId, params) {
      var hash, ns;
      ns = projectId + ":" + hashSuffix;
      hash = generateHash([projectId, ns]);
      return $storage.set(hash, params);
    };
    service.getQueryParams = function(projectId) {
      var hash, ns;
      ns = projectId + ":" + hashSuffix;
      hash = generateHash([projectId, ns]);
      return $storage.get(hash) || {};
    };
    service.upvote = function(epicId) {
      var url;
      url = $urls.resolve("epic-upvote", epicId);
      return $http.post(url);
    };
    service.downvote = function(epicId) {
      var url;
      url = $urls.resolve("epic-downvote", epicId);
      return $http.post(url);
    };
    service.watch = function(epicId) {
      var url;
      url = $urls.resolve("epic-watch", epicId);
      return $http.post(url);
    };
    service.unwatch = function(epicId) {
      var url;
      url = $urls.resolve("epic-unwatch", epicId);
      return $http.post(url);
    };
    return function(instance) {
      return instance.epics = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgEpicsResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", "$tgStorage", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/history.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo, $http, $urls) {
    var service;
    service = {};
    service.get = function(contentType, objectId, entryType) {
      return $repo.queryOneRaw("history/" + contentType, objectId, {
        type: entryType
      });
    };
    service.editComment = function(type, objectId, activityId, comment) {
      var commentData, params, url;
      url = $urls.resolve("history/" + type);
      url = url + "/" + objectId + "/edit_comment";
      params = {
        id: activityId
      };
      commentData = {
        comment: comment
      };
      return $http.post(url, commentData, params).then((function(_this) {
        return function(data) {
          return data.data;
        };
      })(this));
    };
    service.getCommentHistory = function(type, objectId, activityId) {
      var params, url;
      url = $urls.resolve("history/" + type);
      url = url + "/" + objectId + "/comment_versions";
      params = {
        id: activityId
      };
      return $http.get(url, params).then((function(_this) {
        return function(data) {
          return data.data;
        };
      })(this));
    };
    service.deleteComment = function(type, objectId, activityId) {
      var params, url;
      url = $urls.resolve("history/" + type);
      url = url + "/" + objectId + "/delete_comment";
      params = {
        id: activityId
      };
      return $http.post(url, null, params).then((function(_this) {
        return function(data) {
          return data.data;
        };
      })(this));
    };
    service.undeleteComment = function(type, objectId, activityId) {
      var params, url;
      url = $urls.resolve("history/" + type);
      url = url + "/" + objectId + "/undelete_comment";
      params = {
        id: activityId
      };
      return $http.post(url, null, params).then((function(_this) {
        return function(data) {
          return data.data;
        };
      })(this));
    };
    return function(instance) {
      return instance.history = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgHistoryResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/invitations.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo) {
    var service;
    service = {};
    service.get = function(token) {
      return $repo.queryOne("invitations", token);
    };
    return function(instance) {
      return instance.invitations = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgInvitationsResourcesProvider", ["$tgRepo", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/issues.coffee
 */

(function() {
  var generateHash, module, resourceProvider, taiga;

  taiga = this.taiga;

  generateHash = taiga.generateHash;

  resourceProvider = function($repo, $http, $urls, $storage, $q) {
    var hashSuffix, service;
    service = {};
    hashSuffix = "issues-queryparams";
    service.get = function(projectId, issueId) {
      var params;
      params = service.getQueryParams(projectId);
      params.project = projectId;
      return $repo.queryOne("issues", issueId, params);
    };
    service.getByRef = function(projectId, ref) {
      var params;
      params = service.getQueryParams(projectId);
      params.project = projectId;
      params.ref = ref;
      return $repo.queryOne("issues", "by_ref", params);
    };
    service.listInAllProjects = function(filters) {
      return $repo.queryMany("issues", filters);
    };
    service.list = function(projectId, filters, options) {
      var params;
      params = {
        project: projectId
      };
      params = _.extend({}, params, filters || {});
      service.storeQueryParams(projectId, params);
      return $repo.queryPaginated("issues", params, options);
    };
    service.listInProject = function(projectId, sprintId, params) {
      if (sprintId == null) {
        sprintId = null;
      }
      params = _.merge(params, {
        project: projectId
      });
      if (sprintId) {
        params.milestone = sprintId;
      }
      service.storeQueryParams(projectId, params);
      return $repo.queryMany("issues", params);
    };
    service.bulkCreate = function(projectId, milestoneId, data) {
      var params, url;
      url = $urls.resolve("bulk-create-issues");
      params = {
        project_id: projectId,
        milestone_id: milestoneId,
        bulk_issues: data
      };
      return $http.post(url, params);
    };
    service.upvote = function(issueId) {
      var url;
      url = $urls.resolve("issue-upvote", issueId);
      return $http.post(url);
    };
    service.downvote = function(issueId) {
      var url;
      url = $urls.resolve("issue-downvote", issueId);
      return $http.post(url);
    };
    service.watch = function(issueId) {
      var url;
      url = $urls.resolve("issue-watch", issueId);
      return $http.post(url);
    };
    service.unwatch = function(issueId) {
      var url;
      url = $urls.resolve("issue-unwatch", issueId);
      return $http.post(url);
    };
    service.stats = function(projectId) {
      return $repo.queryOneRaw("projects", projectId + "/issues_stats");
    };
    service.filtersData = function(params) {
      return $repo.queryOneRaw("issues-filters", null, params);
    };
    service.listValues = function(projectId, type) {
      var params;
      params = {
        "project": projectId
      };
      service.storeQueryParams(projectId, params);
      return $repo.queryMany(type, params);
    };
    service.createDefaultValues = function(projectId, type) {
      var data, url;
      data = {
        "project_id": projectId
      };
      url = $urls.resolve(type + "-create-default");
      return $http.post(url, data);
    };
    service.storeQueryParams = function(projectId, params) {
      var hash, ns;
      ns = projectId + ":" + hashSuffix;
      hash = generateHash([projectId, ns]);
      return $storage.set(hash, params);
    };
    service.getQueryParams = function(projectId) {
      var hash, ns;
      ns = projectId + ":" + hashSuffix;
      hash = generateHash([projectId, ns]);
      return $storage.get(hash) || {};
    };
    service.bulkUpdateMilestone = function(projectId, milestoneId, data) {
      var params, url;
      url = $urls.resolve("bulk-update-issue-milestone");
      params = {
        project_id: projectId,
        milestone_id: milestoneId,
        bulk_issues: data
      };
      return $http.post(url, params);
    };
    service.promoteToUserStory = function(issueId, projectId) {
      var data, url;
      url = $urls.resolve("promote-issue-to-us", issueId);
      data = {
        project_id: projectId
      };
      return $http.post(url, data);
    };
    return function(instance) {
      return instance.issues = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgIssuesResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", "$tgStorage", "$q", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/kanban.coffee
 */

(function() {
  var generateHash, module, resourceProvider, taiga;

  taiga = this.taiga;

  generateHash = taiga.generateHash;

  resourceProvider = function($storage) {
    var hashSuffixStatusColumnModes, hashSuffixStatusViewModes, service;
    service = {};
    hashSuffixStatusViewModes = "kanban-statusviewmodels";
    hashSuffixStatusColumnModes = "kanban-statuscolumnmodels";
    service.storeStatusColumnModes = function(projectId, params) {
      var hash, ns;
      ns = projectId + ":" + hashSuffixStatusColumnModes;
      hash = generateHash([projectId, ns]);
      return $storage.set(hash, params);
    };
    service.getStatusColumnModes = function(projectId) {
      var hash, ns;
      ns = projectId + ":" + hashSuffixStatusColumnModes;
      hash = generateHash([projectId, ns]);
      return $storage.get(hash) || {};
    };
    return function(instance) {
      return instance.kanban = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgKanbanResourcesProvider", ["$tgStorage", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/locales.coffee
 */

(function() {
  var module, resourceProvider, sizeFormat, taiga;

  taiga = this.taiga;

  sizeFormat = this.taiga.sizeFormat;

  resourceProvider = function($repo) {
    var service;
    service = {
      list: function() {
        return $repo.queryMany("locales");
      }
    };
    return function(instance) {
      return instance.locales = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgLocalesResourcesProvider", ["$tgRepo", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/mdrender.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo, $urls, $http) {
    var service;
    service = {};
    service.render = function(projectId, content) {
      var params, url;
      if ((content == null) || content === "") {
        content = ' ';
      }
      params = {
        project_id: projectId,
        content: content
      };
      url = $urls.resolve("wiki");
      return $http.post(url + "/render", params).then((function(_this) {
        return function(data) {
          return data.data;
        };
      })(this));
    };
    return function(instance) {
      return instance.mdrender = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgMdRenderResourcesProvider", ["$tgRepo", "$tgUrls", "$tgHttp", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/memberships.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo, $http, $urls) {
    var service;
    service = {};
    service.get = function(id) {
      return $repo.queryOne("memberships", id);
    };
    service.list = function(projectId, filters, enablePagination) {
      var options, params;
      if (enablePagination == null) {
        enablePagination = true;
      }
      params = {
        project: projectId
      };
      params = _.extend({}, params, filters || {});
      if (enablePagination) {
        return $repo.queryPaginated("memberships", params);
      }
      return $repo.queryMany("memberships", params, options = {
        enablePagination: enablePagination
      });
    };
    service.listByUser = function(userId, filters) {
      var params;
      params = {
        user: userId
      };
      params = _.extend({}, params, filters || {});
      return $repo.queryPaginated("memberships", params);
    };
    service.resendInvitation = function(id) {
      var url;
      url = $urls.resolve("memberships");
      return $http.post(url + "/" + id + "/resend_invitation", {});
    };
    service.bulkCreateMemberships = function(projectId, data, invitation_extra_text) {
      var params, url;
      url = $urls.resolve("bulk-create-memberships");
      params = {
        project_id: projectId,
        bulk_memberships: data,
        invitation_extra_text: invitation_extra_text
      };
      return $http.post(url, params);
    };
    return function(instance) {
      return instance.memberships = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgMembershipsResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/modules.coffee
 */

(function() {
  var module, resourceProvider;

  resourceProvider = function($repo) {
    var service;
    service = {};
    service.list = function(projectId, module) {
      return $repo.queryOneAttribute("project-modules", projectId, module);
    };
    return function(instance) {
      return instance.modules = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgModulesResourcesProvider", ["$tgRepo", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/notify-policies.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo, $http, $urls) {
    var service;
    service = {};
    service.get = function(id) {
      return $repo.queryOne("notify-policies", id);
    };
    service.list = function(filters) {
      var params;
      params = _.extend({}, params, filters || {});
      return $repo.queryMany("notify-policies", params);
    };
    return function(instance) {
      return instance.notifyPolicies = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgNotifyPoliciesResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/projects.coffee
 */

(function() {
  var module, resourceProvider, sizeFormat, taiga;

  taiga = this.taiga;

  sizeFormat = this.taiga.sizeFormat;

  resourceProvider = function($config, $repo, $http, $urls, $auth, $q, $translate) {
    var service;
    service = {};
    service.get = function(projectId) {
      return $repo.queryOne("projects", projectId);
    };
    service.getBySlug = function(projectSlug) {
      return $repo.queryOne("projects", "by_slug?slug=" + projectSlug);
    };
    service.list = function(filters) {
      var params;
      params = {
        "order_by": "user_order"
      };
      params = _.extend({}, params, filters || {});
      return $repo.queryMany("projects", params);
    };
    service.listByMember = function(memberId) {
      var params;
      params = {
        "member": memberId,
        "order_by": "user_order"
      };
      return $repo.queryMany("projects", params);
    };
    service.templates = function() {
      return $repo.queryMany("project-templates");
    };
    service.usersList = function(projectId) {
      var params;
      params = {
        "project": projectId
      };
      return $repo.queryMany("users", params);
    };
    service.rolesList = function(projectId) {
      var params;
      params = {
        "project": projectId
      };
      return $repo.queryMany("roles", params);
    };
    service.stats = function(projectId) {
      return $repo.queryOneRaw("projects", projectId + "/stats");
    };
    service.bulkUpdateOrder = function(bulkData) {
      var url;
      url = $urls.resolve("bulk-update-projects-order");
      return $http.post(url, bulkData);
    };
    service.regenerate_epics_csv_uuid = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/regenerate_epics_csv_uuid";
      return $http.post(url);
    };
    service.regenerate_userstories_csv_uuid = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/regenerate_userstories_csv_uuid";
      return $http.post(url);
    };
    service.regenerate_tasks_csv_uuid = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/regenerate_tasks_csv_uuid";
      return $http.post(url);
    };
    service.regenerate_issues_csv_uuid = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/regenerate_issues_csv_uuid";
      return $http.post(url);
    };
    service.delete_epics_csv_uuid = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/delete_epics_csv_uuid";
      return $http.post(url);
    };
    service.delete_userstories_csv_uuid = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/delete_userstories_csv_uuid";
      return $http.post(url);
    };
    service.delete_tasks_csv_uuid = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/delete_tasks_csv_uuid";
      return $http.post(url);
    };
    service.delete_issues_csv_uuid = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/delete_issues_csv_uuid";
      return $http.post(url);
    };
    service.leave = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/leave";
      return $http.post(url);
    };
    service.memberStats = function(projectId) {
      return $repo.queryOneRaw("projects", projectId + "/member_stats");
    };
    service.tagsColors = function(projectId) {
      return $repo.queryOne("projects", projectId + "/tags_colors");
    };
    service.deleteTag = function(projectId, tag) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/delete_tag";
      return $http.post(url, {
        tag: tag
      });
    };
    service.createTag = function(projectId, tag, color) {
      var data, url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/create_tag";
      data = {};
      data.tag = tag;
      data.color = null;
      if (color) {
        data.color = color;
      }
      return $http.post(url, data);
    };
    service.editTag = function(projectId, from_tag, to_tag, color) {
      var data, url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/edit_tag";
      data = {};
      data.from_tag = from_tag;
      if (to_tag) {
        data.to_tag = to_tag;
      }
      data.color = null;
      if (color) {
        data.color = color;
      }
      return $http.post(url, data);
    };
    service.mixTags = function(projectId, to_tag, from_tags) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/mix_tags";
      return $http.post(url, {
        to_tag: to_tag,
        from_tags: from_tags
      });
    };
    service["export"] = function(projectId) {
      var url;
      url = ($urls.resolve("exporter")) + "/" + projectId;
      return $http.get(url);
    };
    service["import"] = function(file, statusUpdater) {
      var complete, data, defered, errorMsg, failed, maxFileSize, response, uploadComplete, uploadFailed, uploadProgress, xhr;
      defered = $q.defer();
      maxFileSize = $config.get("maxUploadFileSize", null);
      if (maxFileSize && file.size > maxFileSize) {
        errorMsg = $translate.instant("PROJECT.IMPORT.ERROR_MAX_SIZE_EXCEEDED", {
          fileName: file.name,
          fileSize: sizeFormat(file.size),
          maxFileSize: sizeFormat(maxFileSize)
        });
        response = {
          status: 413,
          data: {
            _error_message: errorMsg
          }
        };
        defered.reject(response);
        return defered.promise;
      }
      uploadProgress = (function(_this) {
        return function(evt) {
          var message, percent;
          percent = Math.round((evt.loaded / evt.total) * 100);
          message = $translate.instant("PROJECT.IMPORT.UPLOAD_IN_PROGRESS_MESSAGE", {
            uploadedSize: sizeFormat(evt.loaded),
            totalSize: sizeFormat(evt.total)
          });
          return statusUpdater("in-progress", null, message, percent);
        };
      })(this);
      uploadComplete = (function(_this) {
        return function(evt) {
          return statusUpdater("done", $translate.instant("PROJECT.IMPORT.TITLE"), $translate.instant("PROJECT.IMPORT.DESCRIPTION"));
        };
      })(this);
      uploadFailed = (function(_this) {
        return function(evt) {
          return statusUpdater("error");
        };
      })(this);
      complete = (function(_this) {
        return function(evt) {
          var ref;
          response = {};
          try {
            response.data = JSON.parse(evt.target.responseText);
          } catch (error) {
            response.data = {};
          }
          response.status = evt.target.status;
          if (evt.target.getResponseHeader('Taiga-Info-Project-Is-Private')) {
            response.headers = {
              isPrivate: evt.target.getResponseHeader('Taiga-Info-Project-Is-Private') === 'True',
              memberships: parseInt(evt.target.getResponseHeader('Taiga-Info-Project-Memberships'))
            };
          }
          if ((ref = response.status) === 201 || ref === 202) {
            defered.resolve(response);
          }
          return defered.reject(response);
        };
      })(this);
      failed = (function(_this) {
        return function(evt) {
          return defered.reject("fail");
        };
      })(this);
      data = new FormData();
      data.append('dump', file);
      xhr = new XMLHttpRequest();
      xhr.upload.addEventListener("progress", uploadProgress, false);
      xhr.upload.addEventListener("load", uploadComplete, false);
      xhr.upload.addEventListener("error", uploadFailed, false);
      xhr.upload.addEventListener("abort", uploadFailed, false);
      xhr.addEventListener("load", complete, false);
      xhr.addEventListener("error", failed, false);
      xhr.open("POST", $urls.resolve("importer"));
      xhr.setRequestHeader("Authorization", "Bearer " + ($auth.getToken()));
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send(data);
      return defered.promise;
    };
    service.changeLogo = function(projectId, file) {
      var data, defered, maxFileSize, options, response, url;
      maxFileSize = $config.get("maxUploadFileSize", null);
      if (maxFileSize && file.size > maxFileSize) {
        response = {
          status: 413,
          data: {
            _error_message: "'" + file.name + "' (" + (sizeFormat(file.size)) + ") is too heavy for our oompa loompas, try it with a smaller than (" + (sizeFormat(maxFileSize)) + ")"
          }
        };
        defered = $q.defer();
        defered.reject(response);
        return defered.promise;
      }
      data = new FormData();
      data.append('logo', file);
      options = {
        transformRequest: angular.identity,
        headers: {
          'Content-Type': void 0
        }
      };
      url = ($urls.resolve("projects")) + "/" + projectId + "/change_logo";
      return $http.post(url, data, {}, options);
    };
    service.removeLogo = function(projectId) {
      var url;
      url = ($urls.resolve("projects")) + "/" + projectId + "/remove_logo";
      return $http.post(url);
    };
    return function(instance) {
      return instance.projects = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgProjectsResourcesProvider", ["$tgConfig", "$tgRepo", "$tgHttp", "$tgUrls", "$tgAuth", "$q", "$translate", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/roles.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo, $http, $urls) {
    var service;
    service = {};
    service.get = function(id) {
      return $repo.queryOne("roles", id);
    };
    service.list = function(projectId) {
      return $repo.queryMany("roles", {
        project: projectId
      });
    };
    return function(instance) {
      return instance.roles = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgRolesResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/search.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo, $urls, $http, $q) {
    var service;
    service = {};
    service["do"] = function(projectId, term) {
      var deferredAbort, params, request, url;
      deferredAbort = $q.defer();
      url = $urls.resolve("search");
      params = {
        url: url,
        method: "GET",
        timeout: deferredAbort.promise,
        cancelable: true,
        params: {
          project: projectId,
          text: term,
          get_all: false
        }
      };
      request = $http.request(params).then(function(data) {
        return data.data;
      });
      request.abort = function() {
        return deferredAbort.resolve();
      };
      request["finally"] = function() {
        request.abort = angular.noop;
        return deferredAbort = request = null;
      };
      return request;
    };
    return function(instance) {
      return instance.search = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgSearchResourcesProvider", ["$tgRepo", "$tgUrls", "$tgHttp", "$q", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/sprints.coffee
 */

(function() {
  var generateHash, module, resourceProvider, taiga;

  taiga = this.taiga;

  generateHash = taiga.generateHash;

  resourceProvider = function($repo, $model, $storage, $http, $urls) {
    var service;
    service = {};
    service.get = function(projectId, sprintId) {
      return $repo.queryOne("milestones", sprintId).then(function(sprint) {
        var uses;
        uses = sprint.user_stories;
        uses = _.map(uses, function(u) {
          return $model.make_model("userstories", u);
        });
        sprint._attrs.user_stories = uses;
        return sprint;
      });
    };
    service.stats = function(projectId, sprintId) {
      return $repo.queryOneRaw("milestones", sprintId + "/stats");
    };
    service.list = function(projectId, filters) {
      var params;
      params = {
        "project": projectId
      };
      params = _.extend({}, params, filters || {});
      return $repo.queryMany("milestones", params, {}, true).then((function(_this) {
        return function(result) {
          var headers, i, len, m, milestones, uses;
          milestones = result[0];
          headers = result[1];
          for (i = 0, len = milestones.length; i < len; i++) {
            m = milestones[i];
            uses = m.user_stories;
            uses = _.map(uses, function(u) {
              return $model.make_model("userstories", u);
            });
            m._attrs.user_stories = uses;
          }
          return {
            milestones: milestones,
            closed: parseInt(headers("Taiga-Info-Total-Closed-Milestones"), 10),
            open: parseInt(headers("Taiga-Info-Total-Opened-Milestones"), 10)
          };
        };
      })(this));
    };
    service.moveUserStoriesMilestone = function(currentMilestoneId, projectId, milestoneId, data) {
      var params, url;
      url = $urls.resolve("move-userstories-to-milestone", currentMilestoneId);
      params = {
        project_id: projectId,
        milestone_id: milestoneId,
        bulk_stories: data
      };
      return $http.post(url, params);
    };
    service.moveTasksMilestone = function(currentMilestoneId, projectId, milestoneId, data) {
      var params, url;
      url = $urls.resolve("move-tasks-to-milestone", currentMilestoneId);
      params = {
        project_id: projectId,
        milestone_id: milestoneId,
        bulk_tasks: data
      };
      return $http.post(url, params);
    };
    service.moveIssuesMilestone = function(currentMilestoneId, projectId, milestoneId, data) {
      var params, url;
      url = $urls.resolve("move-issues-to-milestone", currentMilestoneId);
      params = {
        project_id: projectId,
        milestone_id: milestoneId,
        bulk_issues: data
      };
      return $http.post(url, params);
    };
    return function(instance) {
      return instance.sprints = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgSprintsResourcesProvider", ["$tgRepo", "$tgModel", "$tgStorage", "$tgHttp", "$tgUrls", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/tasks.coffee
 */

(function() {
  var generateHash, module, resourceProvider, taiga;

  taiga = this.taiga;

  generateHash = taiga.generateHash;

  resourceProvider = function($repo, $http, $urls, $storage) {
    var hashSuffix, hashSuffixStatusColumnModes, hashSuffixUsRowModes, service;
    service = {};
    hashSuffix = "tasks-queryparams";
    hashSuffixStatusColumnModes = "tasks-statuscolumnmodels";
    hashSuffixUsRowModes = "tasks-usrowmodels";
    service.get = function(projectId, taskId, extraParams) {
      var params;
      params = service.getQueryParams(projectId);
      params.project = projectId;
      params = _.extend({}, params, extraParams);
      return $repo.queryOne("tasks", taskId, params);
    };
    service.getByRef = function(projectId, ref, extraParams) {
      var params;
      params = service.getQueryParams(projectId);
      params.project = projectId;
      params.ref = ref;
      params = _.extend({}, params, extraParams);
      return $repo.queryOne("tasks", "by_ref", params);
    };
    service.listInAllProjects = function(filters) {
      return $repo.queryMany("tasks", filters);
    };
    service.filtersData = function(params) {
      return $repo.queryOneRaw("task-filters", null, params);
    };
    service.list = function(projectId, sprintId, userStoryId, params) {
      if (sprintId == null) {
        sprintId = null;
      }
      if (userStoryId == null) {
        userStoryId = null;
      }
      params = _.merge(params, {
        project: projectId,
        order_by: 'us_order'
      });
      if (sprintId) {
        params.milestone = sprintId;
      }
      if (userStoryId) {
        params.user_story = userStoryId;
      }
      service.storeQueryParams(projectId, params);
      return $repo.queryMany("tasks", params);
    };
    service.bulkCreate = function(projectId, sprintId, usId, data) {
      var params, url;
      url = $urls.resolve("bulk-create-tasks");
      params = {
        project_id: projectId,
        milestone_id: sprintId,
        us_id: usId,
        bulk_tasks: data
      };
      return $http.post(url, params).then(function(result) {
        return result.data;
      });
    };
    service.upvote = function(taskId) {
      var url;
      url = $urls.resolve("task-upvote", taskId);
      return $http.post(url);
    };
    service.downvote = function(taskId) {
      var url;
      url = $urls.resolve("task-downvote", taskId);
      return $http.post(url);
    };
    service.watch = function(taskId) {
      var url;
      url = $urls.resolve("task-watch", taskId);
      return $http.post(url);
    };
    service.unwatch = function(taskId) {
      var url;
      url = $urls.resolve("task-unwatch", taskId);
      return $http.post(url);
    };
    service.bulkUpdateTaskTaskboardOrder = function(projectId, data) {
      var params, url;
      url = $urls.resolve("bulk-update-task-taskboard-order");
      params = {
        project_id: projectId,
        bulk_tasks: data
      };
      return $http.post(url, params);
    };
    service.bulkUpdateMilestone = function(projectId, milestoneId, data) {
      var params, url;
      url = $urls.resolve("bulk-update-task-milestone");
      params = {
        project_id: projectId,
        milestone_id: milestoneId,
        bulk_tasks: data
      };
      return $http.post(url, params);
    };
    service.reorder = function(id, data, setOrders) {
      var options, url;
      url = $urls.resolve("tasks") + ("/" + id);
      options = {
        "headers": {
          "set-orders": JSON.stringify(setOrders)
        }
      };
      return $http.patch(url, data, null, options).then(function(result) {
        return result.data;
      });
    };
    service.listValues = function(projectId, type) {
      var params;
      params = {
        "project": projectId
      };
      return $repo.queryMany(type, params);
    };
    service.createDefaultValues = function(projectId, type) {
      var data, url;
      data = {
        "project_id": projectId
      };
      url = $urls.resolve(type + "-create-default");
      return $http.post(url, data);
    };
    service.storeQueryParams = function(projectId, params) {
      var hash, ns;
      ns = projectId + ":" + hashSuffix;
      hash = generateHash([projectId, ns]);
      return $storage.set(hash, params);
    };
    service.getQueryParams = function(projectId) {
      var hash, ns;
      ns = projectId + ":" + hashSuffix;
      hash = generateHash([projectId, ns]);
      return $storage.get(hash) || {};
    };
    service.storeStatusColumnModes = function(projectId, params) {
      var hash, ns;
      ns = projectId + ":" + hashSuffixStatusColumnModes;
      hash = generateHash([projectId, ns]);
      return $storage.set(hash, params);
    };
    service.getStatusColumnModes = function(projectId) {
      var hash, ns;
      ns = projectId + ":" + hashSuffixStatusColumnModes;
      hash = generateHash([projectId, ns]);
      return $storage.get(hash) || {};
    };
    service.storeUsRowModes = function(projectId, sprintId, params) {
      var hash, ns;
      ns = projectId + ":" + hashSuffixUsRowModes;
      hash = generateHash([projectId, sprintId, ns]);
      return $storage.set(hash, params);
    };
    service.getUsRowModes = function(projectId, sprintId) {
      var hash, ns;
      ns = projectId + ":" + hashSuffixUsRowModes;
      hash = generateHash([projectId, sprintId, ns]);
      return $storage.get(hash) || {};
    };
    service.promoteToUserStory = function(taskId, projectId) {
      var data, url;
      url = $urls.resolve("promote-task-to-us", taskId);
      data = {
        project_id: projectId
      };
      return $http.post(url, data);
    };
    return function(instance) {
      return instance.tasks = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgTasksResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", "$tgStorage", resourceProvider]);

}).call(this);


/*
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/user-project-settings.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo, $http, $urls) {
    var service;
    service = {};
    service.get = function(id) {
      return $repo.queryOne("user-project-settings", id);
    };
    service.list = function(filters) {
      var params;
      params = _.extend({}, params, filters || {});
      return $repo.queryMany("user-project-settings", params);
    };
    return function(instance) {
      return instance.userProjectSettings = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgUserProjectSettingsResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/user-settings.coffee
 */

(function() {
  var module, resourceProvider, sizeFormat, taiga;

  taiga = this.taiga;

  sizeFormat = this.taiga.sizeFormat;

  resourceProvider = function($config, $repo, $http, $urls, $q) {
    var service;
    service = {};
    service.changeAvatar = function(file) {
      var data, defered, maxFileSize, options, response, url;
      maxFileSize = $config.get("maxUploadFileSize", null);
      if (maxFileSize && file.size > maxFileSize) {
        response = {
          status: 413,
          data: {
            _error_message: "'" + file.name + "' (" + (sizeFormat(file.size)) + ") is too heavy for our oompa loompas, try it with a smaller than (" + (sizeFormat(maxFileSize)) + ")"
          }
        };
        defered = $q.defer();
        defered.reject(response);
        return defered.promise;
      }
      data = new FormData();
      data.append('avatar', file);
      options = {
        transformRequest: angular.identity,
        headers: {
          'Content-Type': void 0
        }
      };
      url = ($urls.resolve("users")) + "/change_avatar";
      return $http.post(url, data, {}, options);
    };
    service.removeAvatar = function() {
      var url;
      url = ($urls.resolve("users")) + "/remove_avatar";
      return $http.post(url);
    };
    service.changePassword = function(currentPassword, newPassword) {
      var data, url;
      url = ($urls.resolve("users")) + "/change_password";
      data = {
        current_password: currentPassword,
        password: newPassword
      };
      return $http.post(url, data);
    };
    return function(instance) {
      return instance.userSettings = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgUserSettingsResourcesProvider", ["$tgConfig", "$tgRepo", "$tgHttp", "$tgUrls", "$q", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/users.coffee
 */

(function() {
  var module, resourceProvider, sizeFormat, taiga;

  taiga = this.taiga;

  sizeFormat = this.taiga.sizeFormat;

  resourceProvider = function($http, $urls) {
    var service;
    service = {};
    service.contacts = function(userId, options) {
      var httpOptions, url;
      if (options == null) {
        options = {};
      }
      url = $urls.resolve("user-contacts", userId);
      httpOptions = {
        headers: {}
      };
      if (!options.enablePagination) {
        httpOptions.headers["x-disable-pagination"] = "1";
      }
      return $http.get(url, {}, httpOptions).then(function(result) {
        return result.data;
      });
    };
    return function(instance) {
      return instance.users = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgUsersResourcesProvider", ["$tgHttp", "$tgUrls", "$q", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/userstories.coffee
 */

(function() {
  var generateHash, module, resourceProvider, taiga;

  taiga = this.taiga;

  generateHash = taiga.generateHash;

  resourceProvider = function($repo, $http, $urls, $storage, $q) {
    var hashSuffix, service;
    service = {};
    hashSuffix = "userstories-queryparams";
    service.get = function(projectId, usId, extraParams) {
      var params;
      params = service.getQueryParams(projectId);
      params.project = projectId;
      params = _.extend({}, params, extraParams);
      return $repo.queryOne("userstories", usId, params);
    };
    service.getByRef = function(projectId, ref, extraParams) {
      var params;
      if (extraParams == null) {
        extraParams = {};
      }
      params = service.getQueryParams(projectId);
      params.project = projectId;
      params.ref = ref;
      params = _.extend({}, params, extraParams);
      return $repo.queryOne("userstories", "by_ref", params);
    };
    service.listInAllProjects = function(filters) {
      return $repo.queryMany("userstories", filters);
    };
    service.filtersData = function(params) {
      return $repo.queryOneRaw("userstories-filters", null, params);
    };
    service.listUnassigned = function(projectId, filters, pageSize) {
      var params;
      params = {
        "project": projectId,
        "milestone": "null"
      };
      params = _.extend({}, params, filters || {});
      service.storeQueryParams(projectId, params);
      return $repo.queryMany("userstories", _.extend(params, {
        page_size: pageSize
      }), {
        enablePagination: true
      }, true);
    };
    service.listAll = function(projectId, filters) {
      var params;
      params = {
        "project": projectId
      };
      params = _.extend({}, params, filters || {});
      service.storeQueryParams(projectId, params);
      return $repo.queryMany("userstories", params);
    };
    service.bulkCreate = function(projectId, status, bulk) {
      var data, url;
      data = {
        project_id: projectId,
        status_id: status,
        bulk_stories: bulk
      };
      url = $urls.resolve("bulk-create-us");
      return $http.post(url, data);
    };
    service.upvote = function(userStoryId) {
      var url;
      url = $urls.resolve("userstory-upvote", userStoryId);
      return $http.post(url);
    };
    service.downvote = function(userStoryId) {
      var url;
      url = $urls.resolve("userstory-downvote", userStoryId);
      return $http.post(url);
    };
    service.watch = function(userStoryId) {
      var url;
      url = $urls.resolve("userstory-watch", userStoryId);
      return $http.post(url);
    };
    service.unwatch = function(userStoryId) {
      var url;
      url = $urls.resolve("userstory-unwatch", userStoryId);
      return $http.post(url);
    };
    service.bulkUpdateBacklogOrder = function(projectId, data) {
      var params, url;
      url = $urls.resolve("bulk-update-us-backlog-order");
      params = {
        project_id: projectId,
        bulk_stories: data
      };
      return $http.post(url, params);
    };
    service.bulkUpdateMilestone = function(projectId, milestoneId, data) {
      var params, url;
      url = $urls.resolve("bulk-update-us-milestone");
      params = {
        project_id: projectId,
        milestone_id: milestoneId,
        bulk_stories: data
      };
      return $http.post(url, params);
    };
    service.bulkUpdateKanbanOrder = function(projectId, statusId, data) {
      var params, url;
      url = $urls.resolve("bulk-update-us-kanban-order");
      params = {
        project_id: projectId,
        status_id: statusId,
        bulk_stories: data
      };
      return $http.post(url, params);
    };
    service.listValues = function(projectId, type) {
      var params;
      params = {
        "project": projectId
      };
      service.storeQueryParams(projectId, params);
      return $repo.queryMany(type, params);
    };
    service.createDefaultValues = function(projectId, type) {
      var data, url;
      data = {
        "project_id": projectId
      };
      url = $urls.resolve(type + "-create-default");
      return $http.post(url, data);
    };
    service.storeQueryParams = function(projectId, params) {
      var hash, ns;
      ns = projectId + ":" + hashSuffix;
      hash = generateHash([projectId, ns]);
      return $storage.set(hash, params);
    };
    service.getQueryParams = function(projectId) {
      var hash, ns;
      ns = projectId + ":" + hashSuffix;
      hash = generateHash([projectId, ns]);
      return $storage.get(hash) || {};
    };
    service.storeShowTags = function(projectId, showTags) {
      var hash;
      hash = generateHash([projectId, 'showTags']);
      return $storage.set(hash, showTags);
    };
    service.getShowTags = function(projectId) {
      var hash;
      hash = generateHash([projectId, 'showTags']);
      return $storage.get(hash) || null;
    };
    return function(instance) {
      return instance.userstories = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgUserstoriesResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", "$tgStorage", "$q", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/webhooklogs.coffee
 */

(function() {
  var module, resourceProvider;

  resourceProvider = function($repo, $urls, $http) {
    var service;
    service = {};
    service.list = function(webhookId) {
      var params;
      params = {
        webhook: webhookId
      };
      return $repo.queryMany("webhooklogs", params);
    };
    service.resend = function(webhooklogId) {
      var url;
      url = $urls.resolve("webhooklogs-resend", webhooklogId);
      return $http.post(url);
    };
    return function(instance) {
      return instance.webhooklogs = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgWebhookLogsResourcesProvider", ["$tgRepo", "$tgUrls", "$tgHttp", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/webhooks.coffee
 */

(function() {
  var module, resourceProvider;

  resourceProvider = function($repo, $urls, $http) {
    var service;
    service = {};
    service.list = function(projectId) {
      var params;
      params = {
        project: projectId
      };
      return $repo.queryMany("webhooks", params);
    };
    service.test = function(webhookId) {
      var url;
      url = $urls.resolve("webhooks-test", webhookId);
      return $http.post(url);
    };
    return function(instance) {
      return instance.webhooks = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgWebhooksResourcesProvider", ["$tgRepo", "$tgUrls", "$tgHttp", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/resources/wiki.coffee
 */

(function() {
  var module, resourceProvider, taiga;

  taiga = this.taiga;

  resourceProvider = function($repo, $http, $urls) {
    var service;
    service = {};
    service.get = function(wikiId) {
      return $repo.queryOne("wiki", wikiId);
    };
    service.getBySlug = function(projectId, slug) {
      return $repo.queryOne("wiki", "by_slug?project=" + projectId + "&slug=" + slug);
    };
    service.list = function(projectId) {
      return $repo.queryMany("wiki", {
        project: projectId
      });
    };
    service.listLinks = function(projectId) {
      return $repo.queryMany("wiki-links", {
        project: projectId
      });
    };
    return function(instance) {
      return instance.wiki = service;
    };
  };

  module = angular.module("taigaResources");

  module.factory("$tgWikiResourcesProvider", ["$tgRepo", "$tgHttp", "$tgUrls", resourceProvider]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings/change-password.coffee
 */

(function() {
  var UserChangePasswordController, UserChangePasswordDirective, debounce, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  debounce = this.taiga.debounce;

  module = angular.module("taigaUserSettings");

  UserChangePasswordController = (function(superClass) {
    extend(UserChangePasswordController, superClass);

    UserChangePasswordController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "$tgAuth", "$translate"];

    function UserChangePasswordController(scope, rootscope, repo, confirm, rs, params, q, location, navUrls, auth, translate) {
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.auth = auth;
      this.translate = translate;
      this.scope.sectionName = this.translate.instant("CHANGE_PASSWORD.SECTION_NAME");
      this.scope.user = this.auth.getUser();
    }

    return UserChangePasswordController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("UserChangePasswordController", UserChangePasswordController);

  UserChangePasswordDirective = function($rs, $confirm, $loading, $translate) {
    var link;
    link = function($scope, $el, $attrs, ctrl) {
      var form, submit, submitButton;
      form = new checksley.Form($el.find("form"));
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var currentLoading, promise;
          event.preventDefault();
          if (!form.validate()) {
            return;
          }
          if ($scope.newPassword1 !== $scope.newPassword2) {
            $confirm.notify('error', $translate.instant("CHANGE_PASSWORD.ERROR_PASSWORD_MATCH"));
            return;
          }
          currentLoading = $loading().target(submitButton).start();
          promise = $rs.userSettings.changePassword($scope.currentPassword, $scope.newPassword1);
          promise.then(function() {
            currentLoading.finish();
            return $confirm.notify('success');
          });
          return promise.then(null, function(response) {
            currentLoading.finish();
            return $confirm.notify('error', response.data._error_message);
          });
        };
      })(this));
      submitButton = $el.find(".submit-button");
      $el.on("submit", "form", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgUserChangePassword", ["$tgResources", "$tgConfirm", "$tgLoading", "$translate", UserChangePasswordDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings/lightboxes.coffee
 */

(function() {
  var DeleteUserDirective, bindOnce, debounce, module, taiga;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  debounce = this.taiga.debounce;

  module = angular.module("taigaUserSettings");

  DeleteUserDirective = function($repo, $rootscope, $auth, $location, $navUrls, lightboxService, $loading) {
    var link;
    link = function($scope, $el, $attrs) {
      var submit, submitButton;
      $scope.$on("deletelightbox:new", function(ctx, user) {
        return lightboxService.open($el);
      });
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      submit = function() {
        var currentLoading, promise;
        currentLoading = $loading().target(submitButton).start();
        promise = $repo.remove($scope.user);
        promise.then(function(data) {
          currentLoading.finish();
          lightboxService.close($el);
          $auth.logout();
          return $location.path($navUrls.resolve("login"));
        });
        return promise.then(null, function() {
          currentLoading.finish();
          return console.log("FAIL");
        });
      };
      $el.on("click", ".button-green", function(event) {
        event.preventDefault();
        return lightboxService.close($el);
      });
      $el.on("click", ".button-red", debounce(2000, function(event) {
        event.preventDefault();
        return submit();
      }));
      return submitButton = $el.find(".button-red");
    };
    return {
      link: link,
      templateUrl: "user/lightbox/lightbox-delete-account.html"
    };
  };

  module.directive("tgLbDeleteUser", ["$tgRepo", "$rootScope", "$tgAuth", "$tgLocation", "$tgNavUrls", "lightboxService", "$tgLoading", DeleteUserDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings/live-notifications.coffee
 */

(function() {
  var UserLiveNotificationsController, UserLiveNotificationsDirective, UserLiveNotificationsListDirective, bindOnce, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaUserSettings");

  UserLiveNotificationsController = (function(superClass) {
    extend(UserLiveNotificationsController, superClass);

    UserLiveNotificationsController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "$tgAuth", "tgErrorHandlingService"];

    function UserLiveNotificationsController(scope, rootscope, repo, confirm, rs, params, q, location, navUrls, auth, errorHandlingService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.auth = auth;
      this.errorHandlingService = errorHandlingService;
      this.scope.sectionName = "USER_SETTINGS.NOTIFICATIONS.LIVE_SECTION_NAME";
      this.scope.user = this.auth.getUser();
      promise = this.loadInitialData();
      promise.then(null, this.onInitialDataError.bind(this));
    }

    UserLiveNotificationsController.prototype.loadInitialData = function() {
      return this.rs.notifyPolicies.list().then((function(_this) {
        return function(notifyPolicies) {
          _this.scope.notifyPolicies = notifyPolicies;
          return notifyPolicies;
        };
      })(this));
    };

    return UserLiveNotificationsController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("UserLiveNotificationsController", UserLiveNotificationsController);

  UserLiveNotificationsDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgUserLiveNotifications", UserLiveNotificationsDirective);

  UserLiveNotificationsListDirective = function($repo, $confirm, $compile) {
    var link, template;
    template = _.template("<% _.each(notifyPolicies, function (notifyPolicy, index) { %>\n<div class=\"policy-table-row\" data-index=\"<%- index %>\">\n  <div class=\"policy-table-project\"><span><%- notifyPolicy.project_name %></span></div>\n  <div class=\"policy-table-all\">\n    <div class=\"button-check\">\n      <input type=\"radio\"\n             name=\"policy-<%- notifyPolicy.id %>\" id=\"policy-all-<%- notifyPolicy.id %>\"\n             value=\"2\" <% if (notifyPolicy.live_notify_level == 2) { %>checked=\"checked\"<% } %>/>\n      <label for=\"policy-all-<%- notifyPolicy.id %>\"\n             translate=\"USER_SETTINGS.NOTIFICATIONS.OPTION_ALL\"></label>\n    </div>\n  </div>\n  <div class=\"policy-table-involved\">\n    <div class=\"button-check\">\n      <input type=\"radio\"\n             name=\"policy-<%- notifyPolicy.id %>\" id=\"policy-involved-<%- notifyPolicy.id %>\"\n             value=\"1\" <% if (notifyPolicy.live_notify_level == 1) { %>checked=\"checked\"<% } %> />\n      <label for=\"policy-involved-<%- notifyPolicy.id %>\"\n             translate=\"USER_SETTINGS.NOTIFICATIONS.OPTION_INVOLVED\"></label>\n    </div>\n  </div>\n  <div class=\"policy-table-none\">\n    <div class=\"button-check\">\n      <input type=\"radio\"\n             name=\"policy-<%- notifyPolicy.id %>\" id=\"policy-none-<%- notifyPolicy.id %>\"\n             value=\"3\" <% if (notifyPolicy.live_notify_level == 3) { %>checked=\"checked\"<% } %> />\n      <label for=\"policy-none-<%- notifyPolicy.id %>\"\n             translate=\"USER_SETTINGS.NOTIFICATIONS.OPTION_NONE\"></label>\n    </div>\n  </div>\n</div>\n<% }) %>");
    link = function($scope, $el, $attrs) {
      var render;
      render = function() {
        var ctx, html;
        $el.off();
        ctx = {
          notifyPolicies: $scope.notifyPolicies
        };
        html = template(ctx);
        $el.html($compile(html)($scope));
        return $el.on("change", "input[type=radio]", function(event) {
          var onError, onSuccess, policy, policyIndex, prev_level, target;
          target = angular.element(event.currentTarget);
          policyIndex = target.parents(".policy-table-row").data('index');
          policy = $scope.notifyPolicies[policyIndex];
          prev_level = policy.live_notify_level;
          policy.live_notify_level = parseInt(target.val(), 10);
          onSuccess = function() {
            return $confirm.notify("success");
          };
          onError = function() {
            $confirm.notify("error");
            return target.parents(".policy-table-row").find("input[value=" + prev_level + "]").prop("checked", true);
          };
          return $repo.save(policy).then(onSuccess, onError);
        });
      };
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return bindOnce($scope, $attrs.ngModel, render);
    };
    return {
      link: link
    };
  };

  module.directive("tgUserLiveNotificationsList", ["$tgRepo", "$tgConfirm", "$compile", UserLiveNotificationsListDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings/main.coffee
 */

(function() {
  var TaigaAvatarModelDirective, UserAvatarDirective, UserProfileDirective, UserSettingsController, debounce, mixOf, module, sizeFormat, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  sizeFormat = this.taiga.sizeFormat;

  module = angular.module("taigaUserSettings");

  debounce = this.taiga.debounce;

  UserSettingsController = (function(superClass) {
    extend(UserSettingsController, superClass);

    UserSettingsController.$inject = ["$scope", "$rootScope", "$tgConfig", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "$tgAuth", "$translate", "tgErrorHandlingService", "$window"];

    function UserSettingsController(scope, rootscope, config, repo, confirm, rs, params, q, location, navUrls, auth, translate, errorHandlingService, window) {
      var maxFileSize, promise, text;
      this.scope = scope;
      this.rootscope = rootscope;
      this.config = config;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.auth = auth;
      this.translate = translate;
      this.errorHandlingService = errorHandlingService;
      this.window = window;
      this.scope.sectionName = "USER_SETTINGS.MENU.SECTION_TITLE";
      this.scope.project = {};
      this.scope.user = this.auth.getUser();
      if (!this.scope.user) {
        this.errorHandlingService.permissionDenied();
      } else {
        this.scope.lang = this.getLan();
        this.scope.theme = this.getTheme();
      }
      maxFileSize = this.config.get("maxUploadFileSize", null);
      if (maxFileSize) {
        text = this.translate.instant("USER_SETTINGS.AVATAR_MAX_SIZE", {
          "maxFileSize": sizeFormat(maxFileSize)
        });
        this.scope.maxFileSizeMsg = text;
      }
      promise = this.loadInitialData();
      promise.then(null, this.onInitialDataError.bind(this));
    }

    UserSettingsController.prototype.loadInitialData = function() {
      this.scope.availableThemes = this.config.get("themes", []);
      return this.rs.locales.list().then((function(_this) {
        return function(locales) {
          _this.scope.locales = locales;
          return locales;
        };
      })(this));
    };

    UserSettingsController.prototype.openDeleteLightbox = function() {
      return this.rootscope.$broadcast("deletelightbox:new", this.scope.user);
    };

    UserSettingsController.prototype.getLan = function() {
      return this.scope.user.lang || this.translate.preferredLanguage();
    };

    UserSettingsController.prototype.getTheme = function() {
      return this.scope.user.theme || this.config.get("defaultTheme") || "taiga";
    };

    UserSettingsController.prototype.exportProfile = function() {
      var onError, onSuccess;
      onSuccess = function(result) {
        var dumpUrl;
        dumpUrl = result.data.url;
        return this.window.open(dumpUrl, "_blank");
      };
      onError = (function(_this) {
        return function(response) {
          var ref;
          if ((ref = response.data) != null ? ref._error_message : void 0) {
            return _this.confirm.notify("error", response.data._error_message);
          }
        };
      })(this);
      return this.auth.exportProfile().then(onSuccess, onError);
    };

    UserSettingsController.prototype.verifyEmail = function() {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function(result) {
          var text;
          text = _this.translate.instant("USER_PROFILE.VERIFY_EMAIL_SUCCESS");
          return _this.confirm.notify("success", text);
        };
      })(this);
      onError = (function(_this) {
        return function(response) {
          var ref;
          if ((ref = response.data) != null ? ref._error_message : void 0) {
            return _this.confirm.notify("error", response.data._error_message);
          }
        };
      })(this);
      return this.auth.sendVerificationEmail().then(onSuccess, onError);
    };

    return UserSettingsController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("UserSettingsController", UserSettingsController);

  UserProfileDirective = function($confirm, $auth, $repo, $translate) {
    var link;
    link = function($scope, $el, $attrs) {
      var submit;
      submit = debounce(2000, (function(_this) {
        return function(event) {
          var changeEmail, form, onError, onSuccess;
          event.preventDefault();
          form = $el.find("form").checksley();
          if (!form.validate()) {
            return;
          }
          changeEmail = $scope.user.isAttributeModified("email");
          $scope.user.lang = $scope.lang;
          $scope.user.theme = $scope.theme;
          onSuccess = function(data) {
            var text;
            $auth.setUser(data);
            if (changeEmail) {
              text = $translate.instant("USER_PROFILE.CHANGE_EMAIL_SUCCESS");
              return $confirm.success(text);
            } else {
              return $confirm.notify('success');
            }
          };
          onError = function(data) {
            form.setErrors(data);
            return $confirm.notify('error', data._error_message);
          };
          return $repo.save($scope.user).then(onSuccess, onError);
        };
      })(this));
      $el.on("submit", "form", submit);
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgUserProfile", ["$tgConfirm", "$tgAuth", "$tgRepo", "$translate", UserProfileDirective]);

  UserAvatarDirective = function($auth, $model, $rs, $confirm) {
    var link;
    link = function($scope, $el, $attrs) {
      var onError, onSuccess, showSizeInfo;
      showSizeInfo = function() {
        return $el.find(".size-info").removeClass("hidden");
      };
      onSuccess = function(response) {
        var user;
        user = $model.make_model("users", response.data);
        $auth.setUser(user);
        $scope.user = user;
        $el.find('.loading-overlay').removeClass('active');
        return $confirm.notify('success');
      };
      onError = function(response) {
        if (response.status === 413) {
          showSizeInfo();
        }
        $el.find('.loading-overlay').removeClass('active');
        return $confirm.notify('error', response.data._error_message);
      };
      $el.on("click", ".js-change-avatar", function() {
        return $el.find("#avatar-field").click();
      });
      $el.on("change", "#avatar-field", function(event) {
        if ($scope.avatarAttachment) {
          $el.find('.loading-overlay').addClass("active");
          return $rs.userSettings.changeAvatar($scope.avatarAttachment).then(onSuccess, onError);
        }
      });
      $el.on("click", "a.js-use-gravatar", function(event) {
        $el.find('.loading-overlay').addClass("active");
        return $rs.userSettings.removeAvatar().then(onSuccess, onError);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgUserAvatar", ["$tgAuth", "$tgModel", "$tgResources", "$tgConfirm", UserAvatarDirective]);

  TaigaAvatarModelDirective = function($parse) {
    var link;
    link = function($scope, $el, $attrs) {
      var model, modelSetter;
      model = $parse($attrs.tgAvatarModel);
      modelSetter = model.assign;
      return $el.bind('change', function() {
        return $scope.$apply(function() {
          return modelSetter($scope, $el[0].files[0]);
        });
      });
    };
    return {
      link: link
    };
  };

  module.directive('tgAvatarModel', ['$parse', TaigaAvatarModelDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings/nav.coffee
 */

(function() {
  var UserSettingsNavigationDirective, module;

  UserSettingsNavigationDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      var section;
      section = $attrs.tgUserSettingsNavigation;
      $el.find(".active").removeClass("active");
      $el.find("#usersettingsmenu-" + section + " a").addClass("active");
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module = angular.module("taigaUserSettings");

  module.directive("tgUserSettingsNavigation", UserSettingsNavigationDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings/notifications.coffee
 */

(function() {
  var UserNotificationsController, UserNotificationsDirective, UserNotificationsListDirective, bindOnce, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaUserSettings");

  UserNotificationsController = (function(superClass) {
    extend(UserNotificationsController, superClass);

    UserNotificationsController.$inject = ["$scope", "$rootScope", "$tgRepo", "$tgConfirm", "$tgResources", "$routeParams", "$q", "$tgLocation", "$tgNavUrls", "$tgAuth", "tgErrorHandlingService"];

    function UserNotificationsController(scope, rootscope, repo, confirm, rs, params, q, location, navUrls, auth, errorHandlingService) {
      var promise;
      this.scope = scope;
      this.rootscope = rootscope;
      this.repo = repo;
      this.confirm = confirm;
      this.rs = rs;
      this.params = params;
      this.q = q;
      this.location = location;
      this.navUrls = navUrls;
      this.auth = auth;
      this.errorHandlingService = errorHandlingService;
      this.scope.sectionName = "USER_SETTINGS.NOTIFICATIONS.SECTION_NAME";
      this.scope.user = this.auth.getUser();
      promise = this.loadInitialData();
      promise.then(null, this.onInitialDataError.bind(this));
    }

    UserNotificationsController.prototype.loadInitialData = function() {
      return this.rs.notifyPolicies.list().then((function(_this) {
        return function(notifyPolicies) {
          _this.scope.notifyPolicies = notifyPolicies;
          return notifyPolicies;
        };
      })(this));
    };

    return UserNotificationsController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("UserNotificationsController", UserNotificationsController);

  UserNotificationsDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgUserNotifications", UserNotificationsDirective);

  UserNotificationsListDirective = function($repo, $confirm, $compile) {
    var link, template;
    template = _.template("<% _.each(notifyPolicies, function (notifyPolicy, index) { %>\n<div class=\"policy-table-row\" data-index=\"<%- index %>\">\n  <div class=\"policy-table-project\"><span><%- notifyPolicy.project_name %></span></div>\n  <div class=\"policy-table-all\">\n    <div class=\"button-check\">\n      <input type=\"radio\"\n             name=\"policy-<%- notifyPolicy.id %>\" id=\"policy-all-<%- notifyPolicy.id %>\"\n             value=\"2\" <% if (notifyPolicy.notify_level == 2) { %>checked=\"checked\"<% } %>/>\n      <label for=\"policy-all-<%- notifyPolicy.id %>\"\n             translate=\"USER_SETTINGS.NOTIFICATIONS.OPTION_ALL\"></label>\n    </div>\n  </div>\n  <div class=\"policy-table-involved\">\n    <div class=\"button-check\">\n      <input type=\"radio\"\n             name=\"policy-<%- notifyPolicy.id %>\" id=\"policy-involved-<%- notifyPolicy.id %>\"\n             value=\"1\" <% if (notifyPolicy.notify_level == 1) { %>checked=\"checked\"<% } %> />\n      <label for=\"policy-involved-<%- notifyPolicy.id %>\"\n             translate=\"USER_SETTINGS.NOTIFICATIONS.OPTION_INVOLVED\"></label>\n    </div>\n  </div>\n  <div class=\"policy-table-none\">\n    <div class=\"button-check\">\n      <input type=\"radio\"\n             name=\"policy-<%- notifyPolicy.id %>\" id=\"policy-none-<%- notifyPolicy.id %>\"\n             value=\"3\" <% if (notifyPolicy.notify_level == 3) { %>checked=\"checked\"<% } %> />\n      <label for=\"policy-none-<%- notifyPolicy.id %>\"\n             translate=\"USER_SETTINGS.NOTIFICATIONS.OPTION_NONE\"></label>\n    </div>\n  </div>\n</div>\n<% }) %>");
    link = function($scope, $el, $attrs) {
      var render;
      render = function() {
        var ctx, html;
        $el.off();
        ctx = {
          notifyPolicies: $scope.notifyPolicies
        };
        html = template(ctx);
        $el.html($compile(html)($scope));
        return $el.on("change", "input[type=radio]", function(event) {
          var onError, onSuccess, policy, policyIndex, prev_level, target;
          target = angular.element(event.currentTarget);
          policyIndex = target.parents(".policy-table-row").data('index');
          policy = $scope.notifyPolicies[policyIndex];
          prev_level = policy.notify_level;
          policy.notify_level = parseInt(target.val(), 10);
          onSuccess = function() {
            return $confirm.notify("success");
          };
          onError = function() {
            $confirm.notify("error");
            return target.parents(".policy-table-row").find("input[value=" + prev_level + "]").prop("checked", true);
          };
          return $repo.save(policy).then(onSuccess, onError);
        });
      };
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return bindOnce($scope, $attrs.ngModel, render);
    };
    return {
      link: link
    };
  };

  module.directive("tgUserNotificationsList", ["$tgRepo", "$tgConfirm", "$compile", UserNotificationsListDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2017 Andrey Antukh <niwi@niwi.nz>
 * Copyright (C) 2014-2017 Jesús Espino Garcia <jespinog@gmail.com>
 * Copyright (C) 2014-2017 David Barragán Merino <bameda@dbarragan.com>
 * Copyright (C) 2014-2017 Alejandro Alonso <alejandro.alonso@kaleidos.net>
 * Copyright (C) 2014-2017 Juan Francisco Alcántara <juanfran.alcantara@kaleidos.net>
 * Copyright (C) 2014-2017 Xavi Julian <xavier.julian@kaleidos.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings/user-project-settings.coffee
 */

(function() {
  var UserProjectSettingsController, bindOnce, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaUserSettings");

  UserProjectSettingsController = (function(superClass) {
    extend(UserProjectSettingsController, superClass);

    UserProjectSettingsController.$inject = ["$rootScope", "$scope", "$tgSections", "$tgResources", "$tgRepo", "$tgConfirm", "tgCurrentUserService"];

    function UserProjectSettingsController(rootScope, scope, tgSections, rs, repo, confirm, currentUserService) {
      var promise;
      this.rootScope = rootScope;
      this.scope = scope;
      this.tgSections = tgSections;
      this.rs = rs;
      this.repo = repo;
      this.confirm = confirm;
      this.currentUserService = currentUserService;
      this.scope.sections = this.tgSections.list();
      promise = this.loadInitialData();
      promise.then(null, this.onInitialDataError.bind(this));
    }

    UserProjectSettingsController.prototype.loadInitialData = function() {
      return this.rs.userProjectSettings.list().then((function(_this) {
        return function(userProjectSettings) {
          return _this.scope.userProjectSettings = userProjectSettings;
        };
      })(this));
    };

    UserProjectSettingsController.prototype.updateCustomHomePage = function(projectSettings) {
      var onError, onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this.currentUserService.loadProjects();
          _this.rootScope.$broadcast("dropdown-project-list:updated");
          return _this.confirm.notify("success");
        };
      })(this);
      onError = (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this);
      return this.repo.save(projectSettings).then(onSuccess, onError);
    };

    UserProjectSettingsController.prototype.filteredSections = function(projectSettings) {
      return _.filter(this.scope.sections, function(section) {
        var ref;
        return ref = section.id, indexOf.call(projectSettings.allowed_sections, ref) >= 0;
      });
    };

    return UserProjectSettingsController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("UserProjectSettingsController", UserProjectSettingsController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: modules/user-settings/live-notifications.coffee
 */

(function() {
  var UserWebNotificationsController, UserWebNotificationsDirective, UserWebNotificationsListDirective, bindOnce, mixOf, module, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  bindOnce = this.taiga.bindOnce;

  module = angular.module("taigaUserSettings");

  UserWebNotificationsController = (function(superClass) {
    extend(UserWebNotificationsController, superClass);

    UserWebNotificationsController.$inject = ["$scope", "$tgResources", "$tgAuth"];

    function UserWebNotificationsController(scope, rs, auth) {
      var promise;
      this.scope = scope;
      this.rs = rs;
      this.auth = auth;
      this.scope.sectionName = "USER_SETTINGS.EVENTS.SECTION_NAME";
      this.scope.user = this.auth.getUser();
      promise = this.loadInitialData();
      promise.then(null, this.onInitialDataError.bind(this));
    }

    UserWebNotificationsController.prototype.loadInitialData = function() {
      return this.rs.notifyPolicies.list().then((function(_this) {
        return function(notifyPolicies) {
          _this.scope.notifyPolicies = notifyPolicies;
          return notifyPolicies;
        };
      })(this));
    };

    return UserWebNotificationsController;

  })(mixOf(taiga.Controller, taiga.PageMixin));

  module.controller("UserWebNotificationsController", UserWebNotificationsController);

  UserWebNotificationsDirective = function() {
    var link;
    link = function($scope, $el, $attrs) {
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link
    };
  };

  module.directive("tgUserWebNotifications", UserWebNotificationsDirective);

  UserWebNotificationsListDirective = function($repo, $confirm, $compile) {
    var link, template;
    template = _.template("<% _.each(notifyPolicies, function (notifyPolicy, index) { %>\n<div class=\"policy-table-row\">\n  <div class=\"policy-table-project\"><span><%- notifyPolicy.project_name %></span></div>\n  <div class=\"policy-table-all\">\n    <div class=\"check\" data-index=\"<%- index %>\">\n      <input type=\"checkbox\"\n        <% if(notifyPolicy.web_notify_level) { %> checked=\"checked\" <% } %>\n        name=\"policy-<%- notifyPolicy.id %>\" id=\"policy-<%- notifyPolicy.id %>\"/>\n      <div></div>\n      <span class=\"check-text check-yes\" translate=\"COMMON.YES\"></span>\n      <span class=\"check-text check-no\"\" translate=\"COMMON.NO\"></span>\n    </div>\n  </div>\n</div>\n<% }) %>");
    link = function($scope, $el, $attrs) {
      var render;
      render = function() {
        var ctx, html;
        $el.off();
        ctx = {
          notifyPolicies: $scope.notifyPolicies
        };
        html = template(ctx);
        $el.html($compile(html)($scope));
        return $el.on("click", ".check", function(event) {
          var onError, onSuccess, policy, policyIndex, target;
          target = angular.element(event.currentTarget);
          policyIndex = target.data('index');
          policy = $scope.notifyPolicies[policyIndex];
          policy.web_notify_level = !policy.web_notify_level;
          onSuccess = function() {
            $confirm.notify("success");
            return target.find("input").prop("checked", policy.web_notify_level);
          };
          onError = function() {
            return $confirm.notify("error");
          };
          return $repo.save(policy).then(onSuccess, onError);
        });
      };
      $scope.$on("$destroy", function() {
        return $el.off();
      });
      return bindOnce($scope, $attrs.ngModel, render);
    };
    return {
      link: link
    };
  };

  module.directive("tgUserWebNotificationsList", ["$tgRepo", "$tgConfirm", "$compile", UserWebNotificationsListDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/components.module.coffee
 */

(function() {
  angular.module("taigaComponents", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/discover.module.coffee
 */

(function() {
  var module;

  module = angular.module("taigaDiscover", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: external-apps/external-apps.module.coffee
 */

(function() {
  var module;

  module = angular.module("taigaExternalApps", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history.module.coffee
 */

(function() {
  angular.module("taigaHistory", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: home/home.module.coffee
 */

(function() {
  var module;

  module = angular.module("taigaHome", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: navigation-bar/navigation-bar.module.coffee
 */

(function() {
  angular.module("taigaNavigationBar", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/projects.module.coffee
 */

(function() {
  angular.module("taigaNotifications", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile.module.coffee
 */

(function() {
  var module;

  module = angular.module("taigaProfile", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/projects.module.coffee
 */

(function() {
  angular.module("taigaProjects", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/resources.module.coffee
 */

(function() {
  angular.module("taigaResources2", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline.module.coffee
 */

(function() {
  angular.module("taigaUserTimeline", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: utils/utils.module.coffee
 */

(function() {
  var module;

  module = angular.module("taigaUtils", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: wiki/history/wiki-history.module.coffee
 */

(function() {
  angular.module("taigaWikiHistory", []);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/assigned/assigned-to-inline.directive.coffee
 */

(function() {
  var AssignedToInlineDirective;

  AssignedToInlineDirective = function($rootscope, $confirm, $repo, $loading, $modelTransform, $template, $translate, $compile, $currentUserService, avatarService, $userListService) {
    var link;
    link = function($scope, $el, $attr, $model) {
      var isEditable, renderUser, renderUserList;
      isEditable = function() {
        var ref, ref1;
        return ((ref = $scope.project) != null ? (ref1 = ref.my_permissions) != null ? ref1.indexOf($attr.requiredPerm) : void 0 : void 0) !== -1;
      };
      renderUserList = function(text) {
        var selectedId, users, visibleUsers;
        selectedId = $model.$modelValue.assigned_to;
        users = $userListService.searchUsers(text);
        if (selectedId) {
          users = _.reject(users, {
            "id": selectedId
          });
        }
        visibleUsers = _.slice(users, 0, 5);
        visibleUsers = _.map(visibleUsers, function(user) {
          return user.avatar = avatarService.getAvatar(user);
        });
        $scope.users = _.slice(users, 0, 5);
        return $scope.showMore = users.length > 5;
      };
      renderUser = function(assignedObject) {
        var assigned_to_extra_info;
        if (assignedObject != null ? assignedObject.assigned_to : void 0) {
          $scope.selected = assignedObject.assigned_to;
          assigned_to_extra_info = $scope.usersById[$scope.selected];
          $scope.fullName = assigned_to_extra_info != null ? assigned_to_extra_info.full_name_display : void 0;
          $scope.isUnassigned = false;
          $scope.avatar = avatarService.getAvatar(assigned_to_extra_info);
          $scope.bg = $scope.avatar.bg;
          $scope.isIocaine = assignedObject != null ? assignedObject.is_iocaine : void 0;
        } else {
          $scope.fullName = $translate.instant("COMMON.ASSIGNED_TO.ASSIGN");
          $scope.isUnassigned = true;
          $scope.avatar = avatarService.getAvatar(null);
          $scope.bg = null;
          $scope.isIocaine = false;
        }
        $scope.fullNameVisible = !($scope.isUnassigned && !$currentUserService.isAuthenticated());
        return $scope.isEditable = isEditable();
      };
      $el.on("click", ".users-search", function(event) {
        return event.stopPropagation();
      });
      $el.on("click", ".users-dropdown", function(event) {
        event.preventDefault();
        event.stopPropagation();
        $scope.usersSearch = "";
        renderUserList();
        $scope.$apply();
        return $el.find(".pop-users").popover().open();
      });
      $scope.selfAssign = function() {
        $model.$modelValue.assigned_to = $currentUserService.getUser().get('id');
        return renderUser($model.$modelValue);
      };
      $scope.unassign = function() {
        $model.$modelValue.assigned_to = null;
        return renderUser();
      };
      $scope.$watch("usersSearch", function(searchingText) {
        if (searchingText != null) {
          renderUserList(searchingText);
          return $el.find('input').focus();
        }
      });
      $el.on("click", ".user-list-single", function(event) {
        var target;
        event.preventDefault();
        target = angular.element(event.currentTarget);
        $model.$modelValue.assigned_to = target.data("user-id");
        renderUser($model.$modelValue);
        return $scope.$apply();
      });
      $scope.$watch($attr.ngModel, function(instance) {
        return renderUser(instance);
      });
      $scope.$on("isiocaine:changed", function(ctx, instance) {
        return renderUser(instance);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      templateUrl: "components/assigned-inline/assigned-to-inline.html",
      require: "ngModel"
    };
  };

  angular.module('taigaComponents').directive("tgAssignedToInline", ["$rootScope", "$tgConfirm", "$tgRepo", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$translate", "$compile", "tgCurrentUserService", "tgAvatarService", "tgUserListService", AssignedToInlineDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/assigned/assigned-users-inline.directive.coffee
 */

(function() {
  var AssignedUsersInlineDirective,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  AssignedUsersInlineDirective = function($rootscope, $confirm, $repo, $loading, $modelTransform, $template, $translate, $compile, $currentUserService, avatarService, $userListService) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var applyToModel, currentAssignedIds, currentAssignedTo, isAssigned, renderUsers, renderUsersList;
      currentAssignedIds = [];
      currentAssignedTo = null;
      isAssigned = function() {
        return currentAssignedIds.length > 0;
      };
      renderUsersList = function(text) {
        var selected, users, visible;
        users = $userListService.searchUsers(text);
        selected = [];
        _.map(users, function(user) {
          var ref;
          if (ref = user.id, indexOf.call(currentAssignedIds, ref) >= 0) {
            user.avatar = avatarService.getAvatar(user);
            return selected.push(user);
          }
        });
        visible = [];
        _.map(users, function(user) {
          var ref;
          if (ref = user.id, indexOf.call(currentAssignedIds, ref) < 0) {
            user.avatar = avatarService.getAvatar(user);
            return visible.push(user);
          }
        });
        $scope.selected = _.slice(selected, 0, 5);
        if ($scope.selected.length < 5) {
          $scope.users = _.slice(visible, 0, 5 - $scope.selected.length);
        } else {
          $scope.users = [];
        }
        return $scope.showMore = users.length > 5;
      };
      renderUsers = function() {
        var assignedUsers;
        assignedUsers = _.map(currentAssignedIds, function(assignedUserId) {
          return $scope.usersById[assignedUserId];
        });
        assignedUsers = _.filter(assignedUsers, function(it) {
          return !!it;
        });
        $scope.hiddenUsers = currentAssignedIds.length > 3 ? currentAssignedIds.length - 3 : 0;
        $scope.assignedUsers = _.slice(assignedUsers, 0, 3);
        return $scope.isAssigned = isAssigned();
      };
      applyToModel = function() {
        _.map(currentAssignedIds, function(userId) {
          if (!$scope.usersById[userId]) {
            return currentAssignedIds.splice(currentAssignedIds.indexOf(userId), 1);
          }
        });
        if (currentAssignedIds.length === 0) {
          currentAssignedTo = null;
        } else if (currentAssignedIds.indexOf(currentAssignedTo) === -1 || !currentAssignedTo) {
          currentAssignedTo = currentAssignedIds[0];
        }
        if (!$model.$modelValue.assigned_users) {
          $model.$modelValue.assigned_users = currentAssignedIds;
        } else {
          $model.$modelValue.setAttr('assigned_users', currentAssignedIds);
        }
        return $model.$modelValue.assigned_to = currentAssignedTo;
      };
      $el.on("click", ".users-dropdown", function(event) {
        event.preventDefault();
        event.stopPropagation();
        $scope.usersSearch = null;
        renderUsersList();
        $scope.$apply();
        return $el.find(".pop-users").popover().open();
      });
      $scope.assign = function(user) {
        currentAssignedIds.push(user.id);
        renderUsers();
        return applyToModel();
      };
      $scope.selfAssign = function() {
        currentAssignedIds.push($currentUserService.getUser().get('id'));
        renderUsers();
        return applyToModel();
      };
      $scope.unassign = function(user) {
        var index;
        index = currentAssignedIds.indexOf(user.id);
        currentAssignedIds.splice(index, 1);
        renderUsers();
        return applyToModel();
      };
      $el.on("click", ".users-search", function(event) {
        return event.stopPropagation();
      });
      $scope.$watch("usersSearch", function(searchingText) {
        if (searchingText != null) {
          renderUsersList(searchingText);
          return $el.find('input').focus();
        }
      });
      $scope.$watch($attrs.ngModel, function(item) {
        var assigned_to;
        if (item == null) {
          return;
        }
        currentAssignedIds = [];
        assigned_to = null;
        if (item.assigned_users != null) {
          currentAssignedIds = item.assigned_users;
        }
        assigned_to = item.assigned_to;
        return renderUsers();
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      scope: true,
      link: link,
      templateUrl: "components/assigned-inline/assigned-users-inline.html",
      require: "ngModel"
    };
  };

  angular.module('taigaComponents').directive("tgAssignedUsersInline", ["$rootScope", "$tgConfirm", "$tgRepo", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$translate", "$compile", "tgCurrentUserService", "tgAvatarService", "tgUserListService", AssignedUsersInlineDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachment-link/attachment-link.directive.coffee
 */

(function() {
  var AttachmentLinkDirective;

  AttachmentLinkDirective = function($parse, attachmentsPreviewService, lightboxService) {
    var link;
    link = function(scope, el, attrs) {
      var attachment;
      attachment = $parse(attrs.tgAttachmentLink)(scope);
      el.on("click", function(event) {
        if (taiga.isImage(attachment.getIn(['file', 'name']))) {
          event.preventDefault();
          return scope.$apply(function() {
            lightboxService.open($('tg-attachments-preview'));
            return attachmentsPreviewService.fileId = attachment.getIn(['file', 'id']);
          });
        } else if (taiga.isPdf(attachment.getIn(['file', 'name']))) {
          event.preventDefault();
          return window.open(attachment.getIn(['file', 'url']));
        }
      });
      return scope.$on("$destroy", function() {
        return el.off();
      });
    };
    return {
      link: link
    };
  };

  AttachmentLinkDirective.$inject = ["$parse", "tgAttachmentsPreviewService", "lightboxService"];

  angular.module("taigaComponents").directive("tgAttachmentLink", AttachmentLinkDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachment/attachment-gallery.directive.coffee
 */

(function() {
  var AttachmentGalleryDirective;

  AttachmentGalleryDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {};
    return {
      scope: {},
      bindToController: {
        attachment: "=",
        onDelete: "&",
        onUpdate: "&",
        type: "="
      },
      controller: "Attachment",
      controllerAs: "vm",
      templateUrl: "components/attachment/attachment-gallery.html",
      link: link
    };
  };

  AttachmentGalleryDirective.$inject = [];

  angular.module("taigaComponents").directive("tgAttachmentGallery", AttachmentGalleryDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachment/attachment.controller.coffee
 */

(function() {
  var AttachmentController;

  AttachmentController = (function() {
    AttachmentController.$inject = ['tgAttachmentsService', '$translate'];

    function AttachmentController(attachmentsService, translate) {
      this.attachmentsService = attachmentsService;
      this.translate = translate;
      this.form = {};
      this.form.description = this.attachment.getIn(['file', 'description']);
      this.form.is_deprecated = this.attachment.get(['file', 'is_deprecated']);
      this.title = this.translate.instant("ATTACHMENT.TITLE", {
        fileName: this.attachment.get('name'),
        date: moment(this.attachment.get('created_date')).format(this.translate.instant("ATTACHMENT.DATE"))
      });
    }

    AttachmentController.prototype.editMode = function(mode) {
      var attachment;
      attachment = this.attachment.set('editable', mode);
      return this.onUpdate({
        attachment: attachment
      });
    };

    AttachmentController.prototype["delete"] = function() {
      return this.onDelete({
        attachment: this.attachment
      });
    };

    AttachmentController.prototype.save = function() {
      var attachment;
      attachment = this.attachment.set('loading', true);
      this.onUpdate({
        attachment: attachment
      });
      attachment = this.attachment.merge({
        editable: false,
        loading: false
      });
      attachment = attachment.mergeIn(['file'], {
        description: this.form.description,
        is_deprecated: !!this.form.is_deprecated
      });
      return this.onUpdate({
        attachment: attachment
      });
    };

    return AttachmentController;

  })();

  angular.module('taigaComponents').controller('Attachment', AttachmentController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachment/attachment.directive.coffee
 */

(function() {
  var AttachmentDirective;

  AttachmentDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {};
    return {
      scope: {},
      bindToController: {
        attachment: "=",
        onDelete: "&",
        onUpdate: "&",
        type: "="
      },
      controller: "Attachment",
      controllerAs: "vm",
      templateUrl: "components/attachment/attachment.html",
      link: link
    };
  };

  AttachmentDirective.$inject = [];

  angular.module("taigaComponents").directive("tgAttachment", AttachmentDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-drop/attachments-drop.directive.coffee
 */

(function() {
  var AttachmentsDropDirective;

  AttachmentsDropDirective = function($parse) {
    var link;
    link = function(scope, el, attrs) {
      var eventAttr;
      eventAttr = $parse(attrs.tgAttachmentsDrop);
      el.on('dragover', function(e) {
        e.preventDefault();
        return false;
      });
      el.on('drop', function(e) {
        var dataTransfer;
        e.stopPropagation();
        e.preventDefault();
        dataTransfer = e.dataTransfer || (e.originalEvent && e.originalEvent.dataTransfer);
        return scope.$apply(function() {
          return eventAttr(scope, {
            files: dataTransfer.files
          });
        });
      });
      return scope.$on("$destroy", function() {
        return el.off();
      });
    };
    return {
      link: link
    };
  };

  AttachmentsDropDirective.$inject = ["$parse"];

  angular.module("taigaComponents").directive("tgAttachmentsDrop", AttachmentsDropDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-full/attachments-full.controller.coffee
 */

(function() {
  var AttachmentsFullController, sizeFormat;

  sizeFormat = this.taiga.sizeFormat;

  AttachmentsFullController = (function() {
    AttachmentsFullController.$inject = ["$translate", "$tgConfirm", "$tgConfig", "$tgStorage", "tgAttachmentsFullService", "tgProjectService", "tgAttachmentsPreviewService"];

    function AttachmentsFullController(translate, confirm, config, storage, attachmentsFullService, projectService, attachmentsPreviewService) {
      this.translate = translate;
      this.confirm = confirm;
      this.config = config;
      this.storage = storage;
      this.attachmentsFullService = attachmentsFullService;
      this.projectService = projectService;
      this.attachmentsPreviewService = attachmentsPreviewService;
      this.mode = this.storage.get('attachment-mode', 'list');
      this.maxFileSize = this.config.get("maxUploadFileSize", null);
      if (this.maxFileSize) {
        this.maxFileSize = sizeFormat(this.maxFileSize);
      }
      this.maxFileSizeMsg = this.maxFileSize ? this.translate.instant("ATTACHMENT.MAX_UPLOAD_SIZE", {
        maxFileSize: this.maxFileSize
      }) : "";
      taiga.defineImmutableProperty(this, 'attachments', (function(_this) {
        return function() {
          return _this.attachmentsFullService.attachments;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'deprecatedsCount', (function(_this) {
        return function() {
          return _this.attachmentsFullService.deprecatedsCount;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'attachmentsVisible', (function(_this) {
        return function() {
          return _this.attachmentsFullService.attachmentsVisible;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'deprecatedsVisible', (function(_this) {
        return function() {
          return _this.attachmentsFullService.deprecatedsVisible;
        };
      })(this));
    }

    AttachmentsFullController.prototype.uploadingAttachments = function() {
      return this.attachmentsFullService.uploadingAttachments;
    };

    AttachmentsFullController.prototype.addAttachment = function(file) {
      var editable;
      editable = this.mode === 'list';
      return this.attachmentsFullService.addAttachment(this.projectId, this.objId, this.type, file, editable);
    };

    AttachmentsFullController.prototype.setMode = function(mode) {
      this.mode = mode;
      return this.storage.set('attachment-mode', mode);
    };

    AttachmentsFullController.prototype.toggleDeprecatedsVisible = function() {
      return this.attachmentsFullService.toggleDeprecatedsVisible();
    };

    AttachmentsFullController.prototype.addAttachments = function(files) {
      return _.forEach(files, (function(_this) {
        return function(file) {
          return _this.addAttachment(file);
        };
      })(this));
    };

    AttachmentsFullController.prototype.loadAttachments = function() {
      return this.attachmentsFullService.loadAttachments(this.type, this.objId, this.projectId);
    };

    AttachmentsFullController.prototype.deleteAttachment = function(toDeleteAttachment) {
      var message, title;
      this.attachmentsPreviewService.fileId = null;
      title = this.translate.instant("ATTACHMENT.TITLE_LIGHTBOX_DELETE_ATTACHMENT");
      message = this.translate.instant("ATTACHMENT.MSG_LIGHTBOX_DELETE_ATTACHMENT", {
        fileName: toDeleteAttachment.getIn(['file', 'name'])
      });
      return this.confirm.askOnDelete(title, message).then((function(_this) {
        return function(askResponse) {
          var onError, onSuccess;
          onError = function() {
            message = _this.translate.instant("ATTACHMENT.ERROR_DELETE_ATTACHMENT", {
              errorMessage: message
            });
            _this.confirm.notify("error", null, message);
            return askResponse.finish(false);
          };
          onSuccess = function() {
            return askResponse.finish();
          };
          return _this.attachmentsFullService.deleteAttachment(toDeleteAttachment, _this.type).then(onSuccess, onError);
        };
      })(this));
    };

    AttachmentsFullController.prototype.reorderAttachment = function(attachment, newIndex) {
      return this.attachmentsFullService.reorderAttachment(this.type, attachment, newIndex);
    };

    AttachmentsFullController.prototype.updateAttachment = function(toUpdateAttachment) {
      return this.attachmentsFullService.updateAttachment(toUpdateAttachment, this.type);
    };

    AttachmentsFullController.prototype._isEditable = function() {
      if (this.projectService.project) {
        return this.projectService.hasPermission(this.editPermission);
      }
      return false;
    };

    AttachmentsFullController.prototype.showAttachments = function() {
      return this._isEditable() || this.attachmentsFullService.attachments.size;
    };

    return AttachmentsFullController;

  })();

  angular.module("taigaComponents").controller("AttachmentsFull", AttachmentsFullController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-full/attachments-full.directive.coffee
 */

(function() {
  var AttachmentsFullDirective, bindOnce;

  bindOnce = this.taiga.bindOnce;

  AttachmentsFullDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return bindOnce(scope, 'vm.objId', function(value) {
        return ctrl.loadAttachments();
      });
    };
    return {
      scope: {},
      bindToController: {
        type: "@",
        objId: "=",
        projectId: "=",
        editPermission: "@"
      },
      controller: "AttachmentsFull",
      controllerAs: "vm",
      templateUrl: "components/attachments-full/attachments-full.html",
      link: link
    };
  };

  AttachmentsFullDirective.$inject = [];

  angular.module("taigaComponents").directive("tgAttachmentsFull", AttachmentsFullDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-full/attachments-full.service.coffee
 */

(function() {
  var AttachmentsFullService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  AttachmentsFullService = (function(superClass) {
    extend(AttachmentsFullService, superClass);

    AttachmentsFullService.$inject = ["tgAttachmentsService", "$rootScope"];

    function AttachmentsFullService(attachmentsService, rootScope) {
      this.attachmentsService = attachmentsService;
      this.rootScope = rootScope;
      this._attachments = Immutable.List();
      this._deprecatedsCount = 0;
      this._attachmentsVisible = Immutable.List();
      this._deprecatedsVisible = false;
      this.uploadingAttachments = [];
      taiga.defineImmutableProperty(this, 'attachments', (function(_this) {
        return function() {
          return _this._attachments;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'deprecatedsCount', (function(_this) {
        return function() {
          return _this._deprecatedsCount;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'attachmentsVisible', (function(_this) {
        return function() {
          return _this._attachmentsVisible;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'deprecatedsVisible', (function(_this) {
        return function() {
          return _this._deprecatedsVisible;
        };
      })(this));
    }

    AttachmentsFullService.prototype.toggleDeprecatedsVisible = function() {
      this._deprecatedsVisible = !this._deprecatedsVisible;
      return this.regenerate();
    };

    AttachmentsFullService.prototype.regenerate = function() {
      this._deprecatedsCount = this._attachments.count(function(it) {
        return it.getIn(['file', 'is_deprecated']);
      });
      if (this._deprecatedsVisible) {
        return this._attachmentsVisible = this._attachments;
      } else {
        return this._attachmentsVisible = this._attachments.filter(function(it) {
          return !it.getIn(['file', 'is_deprecated']);
        });
      }
    };

    AttachmentsFullService.prototype.addAttachment = function(projectId, objId, type, file, editable, comment) {
      if (editable == null) {
        editable = true;
      }
      if (comment == null) {
        comment = false;
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var promise;
          if (_this.attachmentsService.validate(file)) {
            _this.uploadingAttachments.push(file);
            promise = _this.attachmentsService.upload(file, objId, projectId, type, comment);
            return promise.then(function(file) {
              var attachment;
              _this.uploadingAttachments = _this.uploadingAttachments.filter(function(uploading) {
                return uploading.name !== file.get('name');
              });
              attachment = Immutable.Map();
              attachment = attachment.merge({
                file: file,
                editable: editable,
                loading: false,
                from_comment: comment
              });
              _this._attachments = _this._attachments.push(attachment);
              _this.regenerate();
              _this.rootScope.$broadcast("attachment:create");
              return resolve(attachment);
            });
          } else {
            return reject(new Error(file));
          }
        };
      })(this));
    };

    AttachmentsFullService.prototype.loadAttachments = function(type, objId, projectId) {
      return this.attachmentsService.list(type, objId, projectId).then((function(_this) {
        return function(files) {
          _this._attachments = files.map(function(file) {
            var attachment;
            attachment = Immutable.Map();
            return attachment.merge({
              loading: false,
              editable: false,
              file: file
            });
          });
          return _this.regenerate();
        };
      })(this));
    };

    AttachmentsFullService.prototype.deleteAttachment = function(toDeleteAttachment, type) {
      var onSuccess;
      onSuccess = (function(_this) {
        return function() {
          _this._attachments = _this._attachments.filter(function(attachment) {
            return attachment !== toDeleteAttachment;
          });
          return _this.regenerate();
        };
      })(this);
      return this.attachmentsService["delete"](type, toDeleteAttachment.getIn(['file', 'id'])).then(onSuccess);
    };

    AttachmentsFullService.prototype.reorderAttachment = function(type, attachment, newIndex) {
      var attachments, oldIndex, promises;
      oldIndex = this.attachments.findIndex(function(it) {
        return it === attachment;
      });
      if (oldIndex === newIndex) {
        return;
      }
      attachments = this.attachments.remove(oldIndex);
      attachments = attachments.splice(newIndex, 0, attachment);
      attachments = attachments.map(function(x, i) {
        return x.setIn(['file', 'order'], i + 1);
      });
      promises = [];
      attachments.forEach((function(_this) {
        return function(attachment) {
          var patch;
          patch = {
            order: attachment.getIn(['file', 'order'])
          };
          return promises.push(_this.attachmentsService.patch(attachment.getIn(['file', 'id']), type, patch));
        };
      })(this));
      return Promise.all(promises).then((function(_this) {
        return function() {
          _this._attachments = attachments;
          return _this.regenerate();
        };
      })(this));
    };

    AttachmentsFullService.prototype.updateAttachment = function(toUpdateAttachment, type) {
      var index, oldAttachment, patch;
      index = this._attachments.findIndex(function(attachment) {
        return attachment.getIn(['file', 'id']) === toUpdateAttachment.getIn(['file', 'id']);
      });
      oldAttachment = this._attachments.get(index);
      patch = taiga.patch(oldAttachment.get('file'), toUpdateAttachment.get('file'));
      if (toUpdateAttachment.get('loading')) {
        this._attachments = this._attachments.set(index, toUpdateAttachment);
        return this.regenerate();
      } else {
        return this.attachmentsService.patch(toUpdateAttachment.getIn(['file', 'id']), type, patch).then((function(_this) {
          return function() {
            _this._attachments = _this._attachments.set(index, toUpdateAttachment);
            return _this.regenerate();
          };
        })(this));
      }
    };

    return AttachmentsFullService;

  })(taiga.Service);

  angular.module("taigaComponents").service("tgAttachmentsFullService", AttachmentsFullService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-preview/attachments-preview.controller.coffee
 */

(function() {
  var AttachmentsPreviewController;

  AttachmentsPreviewController = (function() {
    AttachmentsPreviewController.$inject = ["tgAttachmentsPreviewService"];

    function AttachmentsPreviewController(attachmentsPreviewService) {
      this.attachmentsPreviewService = attachmentsPreviewService;
      taiga.defineImmutableProperty(this, "current", (function(_this) {
        return function() {
          if (!_this.attachmentsPreviewService.fileId) {
            return null;
          }
          return _this.getCurrent();
        };
      })(this));
    }

    AttachmentsPreviewController.prototype.hasPagination = function() {
      var images;
      images = this.attachments.filter((function(_this) {
        return function(attachment) {
          return taiga.isImage(attachment.getIn(['file', 'name']));
        };
      })(this));
      return images.size > 1;
    };

    AttachmentsPreviewController.prototype.getCurrent = function() {
      var attachment, file;
      attachment = this.attachments.find((function(_this) {
        return function(attachment) {
          return _this.attachmentsPreviewService.fileId === attachment.getIn(['file', 'id']);
        };
      })(this));
      if (!attachment) {
        return null;
      }
      file = attachment.get('file');
      return file;
    };

    AttachmentsPreviewController.prototype.getIndex = function() {
      return this.attachments.findIndex((function(_this) {
        return function(attachment) {
          return _this.attachmentsPreviewService.fileId === attachment.getIn(['file', 'id']);
        };
      })(this));
    };

    AttachmentsPreviewController.prototype.next = function() {
      var attachmentIndex, image;
      attachmentIndex = this.getIndex();
      image = this.attachments.slice(attachmentIndex + 1).find(function(attachment) {
        return taiga.isImage(attachment.getIn(['file', 'name']));
      });
      if (!image) {
        image = this.attachments.find(function(attachment) {
          return taiga.isImage(attachment.getIn(['file', 'name']));
        });
      }
      return this.attachmentsPreviewService.fileId = image.getIn(['file', 'id']);
    };

    AttachmentsPreviewController.prototype.previous = function() {
      var attachmentIndex, image;
      attachmentIndex = this.getIndex();
      image = this.attachments.slice(0, attachmentIndex).findLast(function(attachment) {
        return taiga.isImage(attachment.getIn(['file', 'name']));
      });
      if (!image) {
        image = this.attachments.findLast(function(attachment) {
          return taiga.isImage(attachment.getIn(['file', 'name']));
        });
      }
      return this.attachmentsPreviewService.fileId = image.getIn(['file', 'id']);
    };

    return AttachmentsPreviewController;

  })();

  angular.module('taigaComponents').controller('AttachmentsPreview', AttachmentsPreviewController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-preview/attachments-preview.directive.coffee
 */

(function() {
  var AttachmentPreviewLightboxDirective;

  AttachmentPreviewLightboxDirective = function(lightboxService, attachmentsPreviewService) {
    var link;
    link = function($scope, el, attrs, ctrl) {
      $(document.body).on("keydown.image-preview", function(e) {
        if (attachmentsPreviewService.fileId) {
          if (e.keyCode === 39) {
            ctrl.next();
          } else if (e.keyCode === 37) {
            ctrl.previous();
          }
        }
        return $scope.$digest();
      });
      return $scope.$on('$destroy', function() {
        return $(document.body).off('.image-preview');
      });
    };
    return {
      scope: {},
      controller: 'AttachmentsPreview',
      templateUrl: 'components/attachments-preview/attachments-preview.html',
      link: link,
      controllerAs: "vm",
      bindToController: {
        attachments: "="
      }
    };
  };

  angular.module('taigaComponents').directive("tgAttachmentsPreview", ["lightboxService", "tgAttachmentsPreviewService", AttachmentPreviewLightboxDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-preview/attachments-preview.service.coffee
 */

(function() {
  var AttachmentsPreviewService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  AttachmentsPreviewService = (function(superClass) {
    extend(AttachmentsPreviewService, superClass);

    AttachmentsPreviewService.$inject = [];

    function AttachmentsPreviewService() {}

    return AttachmentsPreviewService;

  })(taiga.Service);

  angular.module("taigaComponents").service("tgAttachmentsPreviewService", AttachmentsPreviewService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-simple/attachments-simple.controller.coffee
 */

(function() {
  var AttachmentsSimpleController;

  AttachmentsSimpleController = (function() {
    AttachmentsSimpleController.$inject = ["tgAttachmentsService"];

    function AttachmentsSimpleController(attachmentsService) {
      this.attachmentsService = attachmentsService;
    }

    AttachmentsSimpleController.prototype.addAttachment = function(file) {
      var attachment;
      attachment = Immutable.fromJS({
        file: file,
        name: file.name,
        size: file.size
      });
      if (this.attachmentsService.validate(file)) {
        this.attachments = this.attachments.push(attachment);
        if (this.onAdd) {
          return this.onAdd({
            attachment: attachment
          });
        }
      }
    };

    AttachmentsSimpleController.prototype.addAttachments = function(files) {
      return _.forEach(files, this.addAttachment.bind(this));
    };

    AttachmentsSimpleController.prototype.deleteAttachment = function(toDeleteAttachment) {
      this.attachments = this.attachments.filter(function(attachment) {
        return attachment !== toDeleteAttachment;
      });
      if (this.onDelete) {
        return this.onDelete({
          attachment: toDeleteAttachment
        });
      }
    };

    return AttachmentsSimpleController;

  })();

  angular.module("taigaComponents").controller("AttachmentsSimple", AttachmentsSimpleController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-simple/attachments-simple.directive.coffee
 */

(function() {
  var AttachmentsSimpleDirective;

  AttachmentsSimpleDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {};
    return {
      scope: {},
      bindToController: {
        attachments: "=",
        onAdd: "&",
        onDelete: "&"
      },
      controller: "AttachmentsSimple",
      controllerAs: "vm",
      templateUrl: "components/attachments-simple/attachments-simple.html",
      link: link
    };
  };

  AttachmentsSimpleDirective.$inject = [];

  angular.module("taigaComponents").directive("tgAttachmentsSimple", AttachmentsSimpleDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/attachments-sortable/attachments-sortable.directive.coffee
 */

(function() {
  var AttachmentSortableDirective;

  AttachmentSortableDirective = function($parse) {
    var link;
    link = function(scope, el, attrs) {
      var callback, drake, scroll;
      callback = $parse(attrs.tgAttachmentsSortable);
      drake = dragula([el[0]], {
        copySortSource: false,
        copy: false,
        mirrorContainer: el[0],
        moves: function(item) {
          return $(item).is('div[tg-bind-scope]');
        }
      });
      drake.on('dragend', function(item) {
        var attachment, newIndex;
        item = $(item);
        attachment = item.scope().attachment;
        newIndex = item.index();
        return scope.$apply(function() {
          return callback(scope, {
            attachment: attachment,
            index: newIndex
          });
        });
      });
      scroll = autoScroll(window, {
        margin: 20,
        pixels: 30,
        scrollWhenOutside: true,
        autoScroll: function() {
          return this.down && drake.dragging;
        }
      });
      return scope.$on("$destroy", function() {
        el.off();
        return drake.destroy();
      });
    };
    return {
      link: link
    };
  };

  AttachmentSortableDirective.$inject = ["$parse"];

  angular.module("taigaComponents").directive("tgAttachmentsSortable", AttachmentSortableDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/auto-select/auto-select.directive.coffee
 */

(function() {
  var AutoSelectDirective;

  AutoSelectDirective = function($timeout) {
    return {
      link: function(scope, elm) {
        return $timeout(function() {
          return elm[0].select();
        });
      }
    };
  };

  AutoSelectDirective.$inject = ['$timeout'];

  angular.module("taigaComponents").directive("tgAutoSelect", AutoSelectDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/avatar/avatar.directive.coffee
 */

(function() {
  var AvatarDirective;

  AvatarDirective = function(avatarService) {
    var link;
    link = function(scope, el, attrs) {
      var attributeName;
      if (attrs.tgAvatarBig) {
        attributeName = 'avatarBig';
      } else {
        attributeName = 'avatar';
      }
      return scope.$watch(attributeName, function(user) {
        var avatar;
        avatar = avatarService.getAvatar(user, attributeName);
        el.attr('src', avatar.url);
        el.attr('title', "" + avatar.username);
        el.attr('alt', "" + avatar.username);
        return el.css('background', avatar.bg || "");
      });
    };
    return {
      link: link,
      scope: {
        avatar: "=tgAvatar",
        avatarBig: "=tgAvatarBig"
      }
    };
  };

  AvatarDirective.$inject = ['tgAvatarService'];

  angular.module("taigaComponents").directive("tgAvatar", AvatarDirective);

  angular.module("taigaComponents").directive("tgAvatarBig", AvatarDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/belong-to-epics/belong-to-epics.directive.coffee
 */

(function() {
  var BelongToEpicsDirective, module;

  module = angular.module('taigaEpics');

  BelongToEpicsDirective = function($translate, $confirm, $rs, $rs2, lightboxService) {
    var link, templateUrl;
    link = function(scope, el, attrs) {
      var updateEpics;
      scope.$watch('epics', function(epics) {
        return updateEpics(epics);
      });
      scope.$on("related-epics:changed", function(ctx, userStory) {
        return $rs.userstories.getByRef(userStory.project, userStory.ref, {}).then(function(us) {
          scope.item.epics = us.epics;
          return updateEpics(us.epics);
        });
      });
      scope.removeEpicRelationship = function(epic) {
        var message, title;
        title = $translate.instant("LIGHTBOX.REMOVE_RELATIONSHIP_WITH_EPIC.TITLE");
        message = $translate.instant("LIGHTBOX.REMOVE_RELATIONSHIP_WITH_EPIC.MESSAGE", {
          epicSubject: epic.get('subject')
        });
        return $confirm.ask(title, null, message).then(function(askResponse) {
          var epicId, onError, onSuccess, usId;
          onSuccess = function() {
            askResponse.finish();
            return scope.$broadcast("related-epics:changed", scope.item);
          };
          onError = function() {
            askResponse.finish(false);
            return $confirm.notify("error");
          };
          epicId = epic.get('id');
          usId = scope.item.id;
          return $rs2.epics.deleteRelatedUserstory(epicId, usId).then(onSuccess, onError);
        });
      };
      return updateEpics = function(epics) {
        scope.epicsLength = 0;
        scope.immutable_epics = [];
        if (epics && !epics.isIterable) {
          scope.epicsLength = epics.length;
          return scope.immutable_epics = Immutable.fromJS(epics);
        }
      };
    };
    templateUrl = function(el, attrs) {
      if (attrs.format) {
        return "components/belong-to-epics/belong-to-epics-" + attrs.format + ".html";
      }
      return "components/belong-to-epics/belong-to-epics-pill.html";
    };
    return {
      link: link,
      scope: {
        epics: '=',
        item: "="
      },
      templateUrl: templateUrl
    };
  };

  module.directive("tgBelongToEpics", ["$translate", "$tgConfirm", "$tgResources", "tgResources", "lightboxService", BelongToEpicsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/bind-code.directive.coffee
 */

(function() {
  var BindCode;

  BindCode = function($sce, $parse, $compile, wysiwygService, wysiwygCodeHightlighterService) {
    return {
      restrict: 'A',
      compile: function(tElement, tAttrs) {
        var tgBindCodeGetter, tgBindCodeWatch;
        tgBindCodeGetter = $parse(tAttrs.tgBindCode);
        tgBindCodeWatch = $parse(tAttrs.tgBindCode, function(value) {
          return (value || '').toString();
        });
        $compile.$$addBindingClass(tElement);
        return function(scope, element, attr) {
          $compile.$$addBindingInfo(element, attr.tgBindCode);
          return scope.$watch(tgBindCodeWatch, function() {
            var html;
            html = wysiwygService.getHTML(tgBindCodeGetter(scope));
            element.html($sce.getTrustedHtml(html) || '');
            return wysiwygCodeHightlighterService.addHightlighter(element);
          });
        };
      }
    };
  };

  angular.module("taigaComponents").directive("tgBindCode", ["$sce", "$parse", "$compile", "tgWysiwygService", "tgWysiwygCodeHightlighterService", BindCode]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/board-zoom/board-zoom.directive.coffee
 */

(function() {
  var BoardZoomDirective;

  BoardZoomDirective = function() {
    return {
      scope: {
        levels: "=",
        value: "="
      },
      templateUrl: 'components/board-zoom/board-zoom.html'
    };
  };

  angular.module('taigaComponents').directive("tgBoardZoom", [BoardZoomDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/card-slideshow/card-slideshow.controller.coffee
 */

(function() {
  var CardSlideshowController;

  CardSlideshowController = (function() {
    CardSlideshowController.$inject = [];

    function CardSlideshowController() {
      this.index = 0;
    }

    CardSlideshowController.prototype.next = function() {
      this.index++;
      if (this.index >= this.images.size) {
        return this.index = 0;
      }
    };

    CardSlideshowController.prototype.previous = function() {
      this.index--;
      if (this.index < 0) {
        return this.index = this.images.size - 1;
      }
    };

    return CardSlideshowController;

  })();

  angular.module('taigaComponents').controller('CardSlideshow', CardSlideshowController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/card-slideshow/card-slideshow.directive.coffee
 */

(function() {
  var cardSlideshowDirective, module;

  module = angular.module("taigaComponents");

  cardSlideshowDirective = function() {
    return {
      controller: "CardSlideshow",
      templateUrl: "components/card-slideshow/card-slideshow.html",
      bindToController: true,
      controllerAs: "vm",
      scope: {
        images: "="
      }
    };
  };

  module.directive('tgCardSlideshow', cardSlideshowDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/card/card.controller.coffee
 */

(function() {
  var CardController;

  CardController = (function() {
    function CardController() {}

    CardController.$inject = [];

    CardController.prototype.visible = function(name) {
      return this.zoom.indexOf(name) !== -1;
    };

    CardController.prototype.hasTasks = function() {
      var tasks;
      tasks = this.item.getIn(['model', 'tasks']);
      return tasks && tasks.size > 0;
    };

    CardController.prototype.hasMultipleAssignedUsers = function() {
      var assignedUsers;
      assignedUsers = this.item.getIn(['model', 'assigned_users']);
      return assignedUsers && assignedUsers.size > 1;
    };

    CardController.prototype.hasVisibleAttachments = function() {
      return this.item.get('images').size > 0;
    };

    CardController.prototype.toggleFold = function() {
      return this.onToggleFold({
        id: this.item.get('id')
      });
    };

    CardController.prototype.getClosedTasks = function() {
      return this.item.getIn(['model', 'tasks']).filter(function(task) {
        return task.get('is_closed');
      });
    };

    CardController.prototype.closedTasksPercent = function() {
      return this.getClosedTasks().size * 100 / this.item.getIn(['model', 'tasks']).size;
    };

    CardController.prototype.getModifyPermisionKey = function() {
      if (this.type === 'task') {
        return 'modify_task';
      } else {
        return 'modify_us';
      }
    };

    CardController.prototype.getDeletePermisionKey = function() {
      if (this.type === 'task') {
        return 'delete_task';
      } else {
        return 'delete_us';
      }
    };

    CardController.prototype._setVisibility = function() {
      var visibility;
      visibility = {
        related: this.visible('related_tasks'),
        slides: this.visible('attachments')
      };
      if (!_.isUndefined(this.item.get('foldStatusChanged'))) {
        if (this.visible('related_tasks') && this.visible('attachments')) {
          visibility.related = !this.item.get('foldStatusChanged');
          visibility.slides = !this.item.get('foldStatusChanged');
        } else if (this.visible('attachments')) {
          visibility.related = this.item.get('foldStatusChanged');
          visibility.slides = this.item.get('foldStatusChanged');
        } else if (!this.visible('related_tasks') && !this.visible('attachments')) {
          visibility.related = this.item.get('foldStatusChanged');
          visibility.slides = this.item.get('foldStatusChanged');
        }
      }
      if (!this.item.getIn(['model', 'tasks']) || !this.item.getIn(['model', 'tasks']).size) {
        visibility.related = false;
      }
      if (!this.item.get('images') || !this.item.get('images').size) {
        visibility.slides = false;
      }
      return visibility;
    };

    CardController.prototype.isRelatedTasksVisible = function() {
      var visibility;
      visibility = this._setVisibility();
      return visibility.related;
    };

    CardController.prototype.isSlideshowVisible = function() {
      var visibility;
      visibility = this._setVisibility();
      return visibility.slides;
    };

    CardController.prototype.getNavKey = function() {
      if (this.type === 'task') {
        return 'project-tasks-detail';
      } else if (this.type === 'issue') {
        return 'project-issues-detail';
      } else {
        return 'project-userstories-detail';
      }
    };

    return CardController;

  })();

  angular.module('taigaComponents').controller('Card', CardController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/card/card.directive.coffee
 */

(function() {
  var cardDirective, module;

  module = angular.module("taigaComponents");

  cardDirective = function() {
    return {
      link: function(scope) {},
      controller: "Card",
      controllerAs: "vm",
      bindToController: true,
      templateUrl: "components/card/card.html",
      scope: {
        onToggleFold: "&",
        onClickAssignedTo: "&",
        onClickEdit: "&",
        onClickRemove: "&",
        onClickDelete: "&",
        project: "=",
        item: "=",
        zoom: "=",
        zoomLevel: "=",
        archived: "=",
        type: "@"
      }
    };
  };

  module.directive('tgCard', cardDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/click-input-file.directive.coffee
 */

(function() {
  var ClickInputFile;

  ClickInputFile = function() {
    return {
      link: function(scope, el) {
        el.on('click', function(e) {
          var inputFile;
          if (!$(e.target).is('input')) {
            e.preventDefault();
            inputFile = el.find('input[type="file"]');
            inputFile.val('');
            return inputFile.trigger('click');
          }
        });
        return scope.$on("$destroy", function() {
          return el.off();
        });
      }
    };
  };

  angular.module("taigaComponents").directive("tgClickInputFile", [ClickInputFile]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/color-selector/color-selector.controller.coffee
 */

(function() {
  var ColorSelectorController, getDefaulColorList, taiga;

  taiga = this.taiga;

  getDefaulColorList = taiga.getDefaulColorList;

  ColorSelectorController = (function() {
    ColorSelectorController.$inject = ["tgProjectService"];

    function ColorSelectorController(projectService) {
      this.projectService = projectService;
      this.colorList = getDefaulColorList();
      this.checkIsColorRequired();
      this.displayColorList = false;
    }

    ColorSelectorController.prototype.userCanChangeColor = function() {
      if (!this.requiredPerm) {
        return true;
      }
      return this.projectService.hasPermission(this.requiredPerm);
    };

    ColorSelectorController.prototype.checkIsColorRequired = function() {
      if (!this.isColorRequired) {
        return this.colorList = _.dropRight(this.colorList);
      }
    };

    ColorSelectorController.prototype.setColor = function(color) {
      this.color = color;
      return this.customColor = color;
    };

    ColorSelectorController.prototype.resetColor = function() {
      if (this.isColorRequired && !this.color) {
        return this.color = this.initColor;
      }
    };

    ColorSelectorController.prototype.toggleColorList = function() {
      this.displayColorList = !this.displayColorList;
      this.customColor = this.color;
      return this.resetColor();
    };

    ColorSelectorController.prototype.onSelectDropdownColor = function(color) {
      this.color = color;
      this.onSelectColor({
        color: color
      });
      return this.toggleColorList();
    };

    ColorSelectorController.prototype.onKeyDown = function(event) {
      if (event.which === 13) {
        if (this.customColor || !this.isColorRequired) {
          this.onSelectDropdownColor(this.customColor);
        }
        return event.preventDefault();
      }
    };

    return ColorSelectorController;

  })();

  angular.module('taigaComponents').controller("ColorSelectorCtrl", ColorSelectorController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/color-selector/color-selector.directive.coffee
 */

(function() {
  var ColorSelectorDirective, bindOnce;

  bindOnce = this.taiga.bindOnce;

  ColorSelectorDirective = function($timeout) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var _timeout, cancel, close;
      _timeout = null;
      cancel = function() {
        $timeout.cancel(_timeout);
        return _timeout = null;
      };
      close = function() {
        if (_timeout) {
          return;
        }
        return _timeout = $timeout((function() {
          ctrl.displayColorList = false;
          return ctrl.resetColor();
        }), 400);
      };
      el.find('.color-selector').mouseenter(cancel).mouseleave(close);
      el.find('.color-selector-dropdown').mouseenter(cancel).mouseleave(close);
      return scope.$watch('vm.initColor', function(color) {
        return ctrl.setColor(color);
      });
    };
    return {
      link: link,
      templateUrl: "components/color-selector/color-selector.html",
      controller: "ColorSelectorCtrl",
      controllerAs: "vm",
      bindToController: {
        isColorRequired: "=",
        onSelectColor: "&",
        initColor: "=",
        requiredPerm: "@"
      },
      scope: {}
    };
  };

  ColorSelectorDirective.$inject = ["$timeout"];

  angular.module('taigaComponents').directive("tgColorSelector", ColorSelectorDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/detail/header/detail-header.controller.coffee
 */

(function() {
  var DetailHeaderController, module;

  module = angular.module('taigaBase');

  DetailHeaderController = (function() {
    DetailHeaderController.$inject = ["$rootScope", "$tgConfirm", "$tgQueueModelTransformation", "$tgNavUrls", "$window"];

    function DetailHeaderController(rootScope, confirm, modelTransform, navUrls, window) {
      this.rootScope = rootScope;
      this.confirm = confirm;
      this.modelTransform = modelTransform;
      this.navUrls = navUrls;
      this.window = window;
      this.editMode = false;
      this.loadingSubject = false;
      this.originalSubject = this.item.subject;
      this.objType = {
        'tasks': 'task',
        'issues': 'issue',
        'userstories': 'us'
      }[this.item._name];
    }

    DetailHeaderController.prototype._checkPermissions = function() {
      return this.permissions = {
        canEdit: _.includes(this.project.my_permissions, this.requiredPerm)
      };
    };

    DetailHeaderController.prototype.cancelEdit = function() {
      this.editMode = false;
      return this.item.subject = this.originalSubject;
    };

    DetailHeaderController.prototype.editSubject = function(value) {
      var selection;
      selection = this.window.getSelection();
      if (selection.type !== "Range") {
        if (value) {
          this.editMode = true;
        }
        if (!value) {
          return this.editMode = false;
        }
      }
    };

    DetailHeaderController.prototype.onKeyDown = function(event) {
      if (event.which === 13) {
        this.saveSubject();
      }
      if (event.which === 27) {
        this.item.subject = this.originalSubject;
        return this.editSubject(false);
      }
    };

    DetailHeaderController.prototype.saveSubject = function() {
      var item, onEditSubjectError, onEditSubjectSuccess, transform;
      onEditSubjectSuccess = (function(_this) {
        return function() {
          _this.loadingSubject = false;
          _this.rootScope.$broadcast("object:updated");
          _this.confirm.notify('success');
          return _this.originalSubject = _this.item.subject;
        };
      })(this);
      onEditSubjectError = (function(_this) {
        return function() {
          _this.loadingSubject = false;
          return _this.confirm.notify('error');
        };
      })(this);
      this.editMode = false;
      this.loadingSubject = true;
      item = this.item;
      transform = this.modelTransform.save(function(item) {
        return item;
      });
      return transform.then(onEditSubjectSuccess, onEditSubjectError);
    };

    return DetailHeaderController;

  })();

  module.controller("DetailHeaderCtrl", DetailHeaderController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/detail/header/detail-header.directive.coffee
 */

(function() {
  var DetailHeaderDirective, module;

  module = angular.module('taigaBase');

  DetailHeaderDirective = function() {
    var link;
    this.$inject = [];
    link = function(scope, el, attrs, ctrl) {
      return ctrl._checkPermissions();
    };
    return {
      link: link,
      controller: "DetailHeaderCtrl",
      bindToController: true,
      scope: {
        item: "=",
        project: "=",
        sectionName: "=",
        requiredPerm: "@"
      },
      controllerAs: "vm",
      templateUrl: "components/detail/header/detail-header.html"
    };
  };

  module.directive("tgDetailHeader", DetailHeaderDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/detail/nav/detail-nav.controller.coffee
 */

(function() {
  var DetailNavController, module;

  module = angular.module("taigaBase");

  DetailNavController = (function() {
    DetailNavController.$inject = ["$tgNavUrls"];

    function DetailNavController(navUrls) {
      this.navUrls = navUrls;
      return;
    }

    DetailNavController.prototype._checkNav = function() {
      var ctx, ref, ref1;
      if (((ref = this.item.neighbors.previous) != null ? ref.ref : void 0) != null) {
        ctx = {
          project: this.item.project_extra_info.slug,
          ref: this.item.neighbors.previous.ref
        };
        this.previousUrl = this.navUrls.resolve("project-" + this.item._name + "-detail", ctx);
      }
      if (((ref1 = this.item.neighbors.next) != null ? ref1.ref : void 0) != null) {
        ctx = {
          project: this.item.project_extra_info.slug,
          ref: this.item.neighbors.next.ref
        };
        return this.nextUrl = this.navUrls.resolve("project-" + this.item._name + "-detail", ctx);
      }
    };

    return DetailNavController;

  })();

  module.controller("DetailNavCtrl", DetailNavController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/detail/nav/detail-nav.directive.coffee
 */

(function() {
  var DetailNavDirective, module;

  module = angular.module('taigaBase');

  DetailNavDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return scope.$watch("vm.item", function(value) {
        if (!value) {
          return;
        }
        return ctrl._checkNav();
      });
    };
    return {
      link: link,
      controller: "DetailNavCtrl",
      bindToController: true,
      scope: {
        item: "="
      },
      controllerAs: "vm",
      templateUrl: "components/detail/nav/detail-nav.html"
    };
  };

  module.directive("tgDetailNav", DetailNavDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/due-date/due-date-controller.coffee
 */

(function() {
  var DueDateController;

  DueDateController = (function() {
    DueDateController.$inject = ["$translate", "tgLightboxFactory", "tgProjectService", "$rootScope"];

    function DueDateController(translate, tgLightboxFactory, projectService, rootscope) {
      this.translate = translate;
      this.tgLightboxFactory = tgLightboxFactory;
      this.projectService = projectService;
      this.rootscope = rootscope;
      this.defaultConfig = [
        {
          "color": "#9dce0a",
          "name": "normal due",
          "days_to_due": null,
          "by_default": true
        }, {
          "color": "#ff9900",
          "name": "due soon",
          "days_to_due": 14,
          "by_default": false
        }, {
          "color": "#ff8a84",
          "name": "past due",
          "days_to_due": 0,
          "by_default": false
        }
      ];
    }

    DueDateController.prototype.visible = function() {
      return this.format === 'button' || (this.dueDate != null);
    };

    DueDateController.prototype.disabled = function() {
      return this.isClosed;
    };

    DueDateController.prototype.color = function() {
      var ref;
      return ((ref = this.getStatus()) != null ? ref.color : void 0) || null;
    };

    DueDateController.prototype.title = function() {
      if (this.dueDate) {
        return this._formatTitle();
      } else if (this.format === 'button') {
        return this.translate.instant('COMMON.DUE_DATE.TITLE_ACTION_SET_DUE_DATE');
      }
      return '';
    };

    DueDateController.prototype.getStatus = function(options) {
      var project;
      if (!this.dueDate) {
        return null;
      }
      project = this.projectService.project.toJS();
      options = project[this.objType + "_duedates"];
      if (!options) {
        options = this.defaultConfig;
      }
      return this._getAppearance(options);
    };

    DueDateController.prototype._getDefaultAppearance = function(options) {
      var defaultAppearance;
      defaultAppearance = null;
      _.map(options, function(option) {
        if (option.by_default === true) {
          return defaultAppearance = option;
        }
      });
      return defaultAppearance;
    };

    DueDateController.prototype._getAppearance = function(options) {
      var currentAppearance, dueDate, now;
      currentAppearance = this._getDefaultAppearance(options);
      options = _.sortBy(options, function(o) {
        return -o.days_to_due;
      });
      dueDate = moment(this.dueDate);
      now = moment();
      _.map(options, function(appearance) {
        var limitDate;
        if (appearance.days_to_due === null) {
          return;
        }
        limitDate = moment(dueDate - moment.duration(appearance.days_to_due, "days"));
        if (now >= limitDate) {
          return currentAppearance = appearance;
        }
      });
      return currentAppearance;
    };

    DueDateController.prototype._formatTitle = function() {
      var formatedDate, prettyDate, status;
      prettyDate = this.translate.instant("COMMON.PICKERDATE.FORMAT");
      formatedDate = moment(this.dueDate).format(prettyDate);
      status = this.getStatus();
      if (status != null ? status.name : void 0) {
        return formatedDate + " (" + status.name + ")";
      }
      return formatedDate;
    };

    DueDateController.prototype.setDueDate = function() {
      if (this.disabled()) {
        return;
      }
      return this.tgLightboxFactory.create("tg-lb-set-due-date", {
        "class": "lightbox lightbox-set-due-date"
      }, {
        "object": this.item,
        "notAutoSave": this.notAutoSave
      });
    };

    return DueDateController;

  })();

  angular.module('taigaComponents').controller('DueDateCtrl', DueDateController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/due-date/due-date-popover.directive.coffee
 */

(function() {
  var dueDatePopoverDirective, module;

  module = angular.module("taigaComponents");

  dueDatePopoverDirective = function($translate, datePickerConfigService) {
    return {
      link: function(scope, el, attrs, ctrl) {
        var datePickerConfig;
        scope.open = false;
        datePickerConfig = datePickerConfigService.get();
        _.merge(datePickerConfig, {
          field: el.find('.due-date-button')[0],
          container: el.find('.date-picker-container')[0],
          bound: true,
          onClose: function() {
            scope.open = false;
            return scope.$apply();
          },
          onSelect: function() {
            return ctrl.dueDate = this.getMoment().format('YYYY-MM-DD');
          }
        });
        el.picker = new Pikaday(datePickerConfig);
        el.on("click", ".due-date-button", function(event) {
          if (scope.open) {
            el.picker.hide();
            return;
          }
          if (!el.picker.getDate() && ctrl.dueDate) {
            el.picker.setDate(moment(ctrl.dueDate).format('YYYY-MM-DD'));
          }
          el.picker.show();
          scope.open = true;
          return scope.$apply();
        });
        el.on("click", ".date-picker-clean", function(event) {
          event.preventDefault();
          event.stopPropagation();
          ctrl.dueDate = null;
          el.picker.setDate(ctrl.dueDate);
          scope.open = false;
          el.picker.hide();
          return scope.$apply();
        });
        return scope.$on("status:changed", function(ctx, status) {
          return ctrl.isClosed = ctrl.item.is_closed;
        });
      },
      controller: "DueDateCtrl",
      controllerAs: "vm",
      bindToController: true,
      templateUrl: "components/due-date/due-date-popover.html",
      scope: {
        dueDate: '=',
        isClosed: '=',
        item: '=',
        objType: '@',
        format: '@',
        notAutoSave: '='
      }
    };
  };

  module.directive('tgDueDatePopover', ['$translate', 'tgDatePickerConfigService', dueDatePopoverDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/due-date/due-date.directive.coffee
 */

(function() {
  var dueDateDirective, module;

  module = angular.module("taigaComponents");

  dueDateDirective = function($translate, datePickerConfigService) {
    var templateUrl;
    templateUrl = function(el, attrs) {
      if (attrs.format) {
        return "components/due-date/due-date-" + attrs.format + ".html";
      }
      return "components/due-date/due-date-icon.html";
    };
    return {
      link: function(scope, el, attrs, ctrl) {
        var renderDatePicker;
        renderDatePicker = function() {
          var datePickerConfig, prettyDate;
          prettyDate = $translate.instant("COMMON.PICKERDATE.FORMAT");
          if (ctrl.dueDate) {
            ctrl.dueDate = moment(ctrl.dueDate, prettyDate);
          }
          el.on("click", ".date-picker-popover-trigger", function(event) {
            if (ctrl.disabled()) {
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            return el.find(".date-picker-popover").popover().open();
          });
          el.on("click", ".date-picker-clean", function(event) {
            event.preventDefault();
            event.stopPropagation();
            ctrl.dueDate = null;
            scope.$apply();
            return el.find(".date-picker-popover").popover().close();
          });
          datePickerConfig = datePickerConfigService.get();
          _.merge(datePickerConfig, {
            field: el.find('input.due-date')[0],
            container: el.find('.date-picker-container')[0],
            bound: false,
            onSelect: function() {
              ctrl.dueDate = this.getMoment().format('YYYY-MM-DD');
              el.find(".date-picker-popover").popover().close();
              return scope.$apply();
            }
          });
          return el.picker = new Pikaday(datePickerConfig);
        };
        if (attrs.format === 'button-popover') {
          return renderDatePicker();
        }
      },
      controller: "DueDateCtrl",
      controllerAs: "vm",
      bindToController: true,
      templateUrl: templateUrl,
      scope: {
        dueDate: '=',
        isClosed: '=',
        item: '=',
        objType: '@',
        format: '@',
        notAutoSave: '='
      }
    };
  };

  module.directive('tgDueDate', ['$translate', 'tgDatePickerConfigService', dueDateDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/file-change/file-change.directive.coffee
 */

(function() {
  var FileChangeDirective;

  FileChangeDirective = function($parse) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var eventAttr;
      eventAttr = $parse(attrs.tgFileChange);
      el.on('change', function(event) {
        return scope.$apply(function() {
          return eventAttr(scope, {
            files: event.currentTarget.files
          });
        });
      });
      return scope.$on("$destroy", function() {
        return el.off();
      });
    };
    return {
      restrict: "A",
      link: link
    };
  };

  FileChangeDirective.$inject = ["$parse"];

  angular.module("taigaComponents").directive("tgFileChange", FileChangeDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/filter/filter-remote.service.coffee
 */

(function() {
  var FilterRemoteStorageService, generateHash,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  generateHash = taiga.generateHash;

  FilterRemoteStorageService = (function(superClass) {
    extend(FilterRemoteStorageService, superClass);

    FilterRemoteStorageService.$inject = ["$q", "$tgUrls", "$tgHttp"];

    function FilterRemoteStorageService(q, urls, http) {
      this.q = q;
      this.urls = urls;
      this.http = http;
    }

    FilterRemoteStorageService.prototype.storeFilters = function(projectId, myFilters, filtersHashSuffix) {
      var deferred, hash, ns, promise, url;
      deferred = this.q.defer();
      url = this.urls.resolve("user-storage");
      ns = projectId + ":" + filtersHashSuffix;
      hash = generateHash([projectId, ns]);
      if (_.isEmpty(myFilters)) {
        promise = this.http["delete"](url + "/" + hash, {
          key: hash,
          value: myFilters
        });
        promise.then(function() {
          return deferred.resolve();
        });
        promise.then(null, function() {
          return deferred.reject();
        });
      } else {
        promise = this.http.put(url + "/" + hash, {
          key: hash,
          value: myFilters
        });
        promise.then(function(data) {
          return deferred.resolve();
        });
        promise.then(null, (function(_this) {
          return function(data) {
            var innerPromise;
            innerPromise = _this.http.post("" + url, {
              key: hash,
              value: myFilters
            });
            innerPromise.then(function() {
              return deferred.resolve();
            });
            return innerPromise.then(null, function() {
              return deferred.reject();
            });
          };
        })(this));
      }
      return deferred.promise;
    };

    FilterRemoteStorageService.prototype.getFilters = function(projectId, filtersHashSuffix) {
      var deferred, hash, ns, promise, url;
      deferred = this.q.defer();
      url = this.urls.resolve("user-storage");
      ns = projectId + ":" + filtersHashSuffix;
      hash = generateHash([projectId, ns]);
      promise = this.http.get(url + "/" + hash);
      promise.then(function(data) {
        return deferred.resolve(data.data.value);
      });
      promise.then(null, function(data) {
        return deferred.resolve({});
      });
      return deferred.promise;
    };

    return FilterRemoteStorageService;

  })(taiga.Service);

  angular.module("taigaComponents").service("tgFilterRemoteStorageService", FilterRemoteStorageService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/filter/filter-slide-down.directive.coffee
 */

(function() {
  var FilterSlideDownDirective;

  FilterSlideDownDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var filter;
      filter = $('tg-filter');
      return scope.$watch(attrs.ngIf, function(value) {
        var contentHeight, wrapperHeight;
        if (value) {
          filter.find('.filter-list').hide();
          wrapperHeight = filter.height();
          contentHeight = 0;
          filter.children().each(function() {
            return contentHeight += $(this).outerHeight(true);
          });
          return $(el.context.nextSibling).css({
            "display": "block"
          });
        }
      });
    };
    return {
      priority: 900,
      link: link
    };
  };

  angular.module('taigaComponents').directive("tgFilterSlideDown", [FilterSlideDownDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/filter/filter.controller.coffee
 */

(function() {
  var FilterController;

  FilterController = (function() {
    FilterController.$inject = ['$translate'];

    function FilterController(translate) {
      this.translate = translate;
      this.opened = null;
      this.filterModeOptions = ["include", "exclude"];
      this.filterModeLabels = {
        "include": this.translate.instant("COMMON.FILTERS.ADVANCED_FILTERS.INCLUDE"),
        "exclude": this.translate.instant("COMMON.FILTERS.ADVANCED_FILTERS.EXCLUDE")
      };
      this.filterMode = 'include';
      this.showAdvancedFilter = false;
      this.customFilterForm = false;
      this.customFilterName = '';
    }

    FilterController.prototype.toggleAdvancedFilter = function() {
      return this.showAdvancedFilter = !this.showAdvancedFilter;
    };

    FilterController.prototype.toggleFilterCategory = function(filterName) {
      if (this.opened === filterName) {
        return this.opened = null;
      } else {
        return this.opened = filterName;
      }
    };

    FilterController.prototype.isOpen = function(filterName) {
      return this.opened === filterName;
    };

    FilterController.prototype.saveCustomFilter = function() {
      this.onSaveCustomFilter({
        name: this.customFilterName
      });
      this.customFilterForm = false;
      this.opened = 'custom-filter';
      return this.customFilterName = '';
    };

    FilterController.prototype.changeQ = function() {
      return this.onChangeQ({
        q: this.q
      });
    };

    FilterController.prototype.unselectFilter = function(filter) {
      return this.onRemoveFilter({
        filter: filter
      });
    };

    FilterController.prototype.unselectFilter = function(filter) {
      return this.onRemoveFilter({
        filter: filter
      });
    };

    FilterController.prototype.selectFilter = function(filterCategory, filter) {
      filter = {
        category: filterCategory,
        filter: filter,
        mode: this.filterMode
      };
      return this.onAddFilter({
        filter: filter
      });
    };

    FilterController.prototype.removeCustomFilter = function(filter) {
      return this.onRemoveCustomFilter({
        filter: filter
      });
    };

    FilterController.prototype.selectCustomFilter = function(filter) {
      return this.onSelectCustomFilter({
        filter: filter
      });
    };

    FilterController.prototype.isFilterSelected = function(filterCategory, filter) {
      return !!_.find(this.selectedFilters, function(it) {
        return filter.id === it.id && filterCategory.dataType === it.dataType;
      });
    };

    return FilterController;

  })();

  angular.module('taigaComponents').controller('Filter', FilterController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/filter/filter.directive.coffee
 */

(function() {
  var FilterDirective;

  FilterDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var unwatch;
      unwatch = scope.$watch("vm.defaultQ", function(q) {
        if (q && !scope.vm.filtersForm.$dirty) {
          scope.vm.q = q;
          return unwatch();
        } else if (scope.vm.filtersForm.$dirty) {
          return unwatch();
        }
      });
      return attrs.$observe("open", function(open) {
        open = scope.$eval(open);
        if (open) {
          return el.addClass('open');
        } else {
          return el.removeClass('open');
        }
      });
    };
    return {
      scope: {
        onChangeQ: "&",
        onAddFilter: "&",
        onSelectCustomFilter: "&",
        onRemoveFilter: "&",
        onRemoveCustomFilter: "&",
        onSaveCustomFilter: "&",
        customFilters: "<",
        defaultQ: "=q",
        filters: "<",
        customFilters: "<",
        selectedFilters: "<"
      },
      bindToController: true,
      controller: "Filter",
      controllerAs: "vm",
      templateUrl: 'components/filter/filter.html',
      link: link
    };
  };

  angular.module('taigaComponents').directive("tgFilter", [FilterDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/joy-ride/joy-ride.directive.coffee
 */

(function() {
  var JoyRideDirective, taiga;

  taiga = this.taiga;

  JoyRideDirective = function($rootScope, currentUserService, joyRideService, $location, $translate) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var initJoyrRide, intro, unsuscribe;
      unsuscribe = null;
      intro = introJs();
      intro.oncomplete(function() {
        return $('html,body').scrollTop(0);
      });
      intro.onexit(function() {
        return currentUserService.disableJoyRide();
      });
      initJoyrRide = function(next, config) {
        if (!config[next.joyride]) {
          return;
        }
        intro.setOptions({
          exitOnEsc: false,
          exitOnOverlayClick: false,
          showStepNumbers: false,
          nextLabel: $translate.instant('JOYRIDE.NAV.NEXT') + ' &rarr;',
          prevLabel: '&larr; ' + $translate.instant('JOYRIDE.NAV.BACK'),
          skipLabel: $translate.instant('JOYRIDE.NAV.SKIP'),
          doneLabel: $translate.instant('JOYRIDE.NAV.DONE'),
          disableInteraction: true
        });
        intro.setOption('steps', joyRideService.get(next.joyride));
        return intro.start();
      };
      return $rootScope.$on('$routeChangeSuccess', function(event, next) {
        if (!next.joyride || !currentUserService.isAuthenticated()) {
          intro.exit();
          if (unsuscribe) {
            unsuscribe();
          }
          return;
        }
        intro.oncomplete(function() {
          return currentUserService.disableJoyRide(next.joyride);
        });
        if (next.loader) {
          return unsuscribe = $rootScope.$on('loader:end', function() {
            currentUserService.loadJoyRideConfig().then(function(config) {
              return initJoyrRide(next, config);
            });
            return unsuscribe();
          });
        } else {
          return currentUserService.loadJoyRideConfig().then(function(config) {
            return initJoyrRide(next, config);
          });
        }
      });
    };
    return {
      scope: {},
      link: link
    };
  };

  JoyRideDirective.$inject = ["$rootScope", "tgCurrentUserService", "tgJoyRideService", "$location", "$translate"];

  angular.module("taigaComponents").directive("tgJoyRide", JoyRideDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/joy-ride/joy-ride.service.coffee
 */

(function() {
  var JoyRideService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  JoyRideService = (function(superClass) {
    extend(JoyRideService, superClass);

    JoyRideService.$inject = ['$translate', 'tgCheckPermissionsService'];

    function JoyRideService(translate, checkPermissionsService) {
      this.translate = translate;
      this.checkPermissionsService = checkPermissionsService;
    }

    JoyRideService.prototype.getConfig = function() {
      return {
        dashboard: (function(_this) {
          return function() {
            var steps;
            steps = [
              {
                element: '.project-list > section:not(.ng-hide)',
                position: 'left',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.DASHBOARD.STEP1.TITLE'),
                  text: _this.translate.instant('JOYRIDE.DASHBOARD.STEP1.TEXT')
                }
              }, {
                element: '.working-on-container',
                position: 'right',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.DASHBOARD.STEP2.TITLE'),
                  text: _this.translate.instant('JOYRIDE.DASHBOARD.STEP2.TEXT')
                }
              }, {
                element: '.watching-container',
                position: 'right',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.DASHBOARD.STEP3.TITLE'),
                  text: [_this.translate.instant('JOYRIDE.DASHBOARD.STEP3.TEXT1'), _this.translate.instant('JOYRIDE.DASHBOARD.STEP3.TEXT2')]
                }
              }
            ];
            if (!$('.project-list .create-project-button').is(':hidden')) {
              steps.push({
                element: '.project-list .create-project-button',
                position: 'bottom',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.DASHBOARD.STEP4.TITLE'),
                  text: [_this.translate.instant('JOYRIDE.DASHBOARD.STEP4.TEXT1'), _this.translate.instant('JOYRIDE.DASHBOARD.STEP4.TEXT2')]
                }
              });
            }
            return steps;
          };
        })(this),
        backlog: (function(_this) {
          return function() {
            var steps;
            steps = [
              {
                element: '.summary',
                position: 'bottom',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.BACKLOG.STEP1.TITLE'),
                  text: [_this.translate.instant('JOYRIDE.BACKLOG.STEP1.TEXT1'), _this.translate.instant('JOYRIDE.BACKLOG.STEP1.TEXT2')]
                }
              }, {
                element: '.backlog-table-empty',
                position: 'bottom',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.BACKLOG.STEP2.TITLE'),
                  text: _this.translate.instant('JOYRIDE.BACKLOG.STEP2.TEXT')
                }
              }, {
                element: '.sprints',
                position: 'left',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.BACKLOG.STEP3.TITLE'),
                  text: _this.translate.instant('JOYRIDE.BACKLOG.STEP3.TEXT')
                }
              }
            ];
            if (_this.checkPermissionsService.check('add_us')) {
              steps.push({
                element: '.new-us',
                position: 'rigth',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.BACKLOG.STEP4.TITLE'),
                  text: _this.translate.instant('JOYRIDE.BACKLOG.STEP4.TEXT')
                }
              });
            }
            return steps;
          };
        })(this),
        kanban: (function(_this) {
          return function() {
            var steps;
            steps = [
              {
                element: '.kanban-table-inner',
                position: 'bottom',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.KANBAN.STEP1.TITLE'),
                  text: _this.translate.instant('JOYRIDE.KANBAN.STEP1.TEXT')
                }
              }, {
                element: '.card-placeholder',
                position: 'right',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.KANBAN.STEP2.TITLE'),
                  text: _this.translate.instant('JOYRIDE.KANBAN.STEP2.TEXT')
                }
              }
            ];
            if (_this.checkPermissionsService.check('add_us')) {
              steps.push({
                element: '.add-action',
                position: 'bottom',
                joyride: {
                  title: _this.translate.instant('JOYRIDE.KANBAN.STEP3.TITLE'),
                  text: [_this.translate.instant('JOYRIDE.KANBAN.STEP3.TEXT1'), _this.translate.instant('JOYRIDE.KANBAN.STEP3.TEXT2')]
                }
              });
            }
            return steps;
          };
        })(this)
      };
    };

    JoyRideService.prototype.get = function(name) {
      var joyRide, joyRides;
      joyRides = this.getConfig();
      joyRide = joyRides[name].call(this);
      return _.map(joyRide, function(item) {
        var html;
        html = "";
        if (item.joyride.title) {
          html += "<h3>" + item.joyride.title + "</h3>";
        }
        if (_.isArray(item.joyride.text)) {
          _.forEach(item.joyride.text, function(text) {
            return html += "<p>" + text + "</p>";
          });
        } else {
          html += "<p>" + item.joyride.text + "</p>";
        }
        item.intro = html;
        return item;
      });
    };

    return JoyRideService;

  })(taiga.Service);

  angular.module("taigaComponents").service("tgJoyRideService", JoyRideService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/kanban-board-zoom/kanban-board-zoom.directive.coffee
 */

(function() {
  var KanbanBoardZoomDirective;

  KanbanBoardZoomDirective = function(storage, projectService) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var getZoomView, unwatch, zooms;
      scope.zoomIndex = storage.get("kanban_zoom") || 2;
      scope.levels = 5;
      zooms = [["ref"], ["subject"], ["owner", "tags", "extra_info"], ["unfold"], ["attachments", "related_tasks", "empty_extra_info"]];
      getZoomView = function(zoomIndex) {
        if (zoomIndex == null) {
          zoomIndex = 0;
        }
        if (storage.get("kanban_zoom") !== zoomIndex) {
          storage.set("kanban_zoom", zoomIndex);
        }
        return _.reduce(zooms, function(result, value, key) {
          if (key <= zoomIndex) {
            result = result.concat(value);
          }
          return result;
        });
      };
      scope.$watch('zoomIndex', function(zoomLevel) {
        var zoom;
        zoom = getZoomView(zoomLevel);
        return scope.onZoomChange({
          zoomLevel: zoomLevel,
          zoom: zoom
        });
      });
      return unwatch = scope.$watch(function() {
        return projectService.project;
      }, function(project) {
        if (project) {
          if (project.get('my_permissions').indexOf("view_tasks") === -1) {
            scope.levels = 4;
          }
          return unwatch();
        }
      });
    };
    return {
      scope: {
        onZoomChange: "&"
      },
      template: "<tg-board-zoom\n    class=\"board-zoom\"\n    value=\"zoomIndex\"\n    levels=\"levels\"\n></tg-board-zoom>",
      link: link
    };
  };

  angular.module('taigaComponents').directive("tgKanbanBoardZoom", ["$tgStorage", "tgProjectService", KanbanBoardZoomDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2019 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/lb-select-user/lb-select-user.directive.coffee
 */

(function() {
  var SelectUserDirective, truncate;

  truncate = taiga.truncate;

  SelectUserDirective = function($rootScope, $repo, $translate, lightboxService, lightboxKeyboardNavigationService, avatarService, projectService) {
    var link;
    link = function($scope, $el, $attrs) {
      var closeLightbox, confirmSelection, getFilteredUsers, roles, users;
      users = [];
      roles = [];
      lightboxService.open($el);
      getFilteredUsers = function(text) {
        var _filterRows, available, collection, selected;
        if (text == null) {
          text = "";
        }
        selected = _.compact(_.sortBy(_.filter(users, function(x) {
          return _.includes($scope.currentUsers, x.id);
        }), 'name'));
        _filterRows = function(text, row) {
          var name;
          if (row.type === 'user' && _.find(selected, ['id', row.id])) {
            return false;
          }
          name = row.name.toUpperCase();
          text = text.toUpperCase();
          return _.includes(name, text);
        };
        collection = _.union(users, _.filter(roles, (function(_this) {
          return function(role) {
            var difference;
            difference = _.difference(role.userIds, _.map(selected, 'id'));
            return difference.length > 0;
          };
        })(this)));
        available = _.sortBy(_.filter(collection, _.partial(_filterRows, text)), 'name');
        if (!text) {
          $scope.selected = selected;
          return $scope.collection = _.union(selected, available);
        } else {
          $scope.selected = [];
          return $scope.collection = available;
        }
      };
      closeLightbox = function() {
        lightboxKeyboardNavigationService.stop();
        return lightboxService.close($el);
      };
      $scope.$on("watcher:add", function(ctx, item) {
        $scope.item = item;
        getFilteredUsers();
        return lightboxService.open($el).then(function() {
          $el.find("input").focus();
          return lightboxKeyboardNavigationService.init($el);
        });
      });
      $scope.$watch("activeUsers", function(activeUsers) {
        var project;
        if (!activeUsers) {
          return;
        }
        users = _.map(activeUsers, function(user) {
          return {
            id: user.id,
            type: 'user',
            name: user.full_name_display,
            avatar: avatarService.getAvatar(user)
          };
        });
        if ($scope.single) {
          return;
        }
        project = projectService.project.toJS();
        return roles = _.map(project.roles, function(role) {
          var roleUsers, suffix;
          roleUsers = _.filter(activeUsers, {
            'role': role.id
          });
          suffix = $translate.instant("LIGHTBOX.SELECT_USER.ROLE");
          return {
            id: role.id,
            type: 'role',
            name: suffix + ": " + role.name,
            avatar: null,
            userIds: _.map(roleUsers, 'id'),
            userNames: truncate('(' + _.join(_.map(roleUsers, 'full_name_display'), ', ') + ')', 110)
          };
        });
      });
      $scope.$watch("currentUsers", function(currentUsers) {
        if (!currentUsers) {
          return;
        }
        return getFilteredUsers();
      });
      $scope.$watch("searchText", function(searchingText) {
        getFilteredUsers(searchingText);
        return $el.find("input").focus();
      });
      $scope.removeItem = function(user, $event) {
        $event.preventDefault();
        $event.stopPropagation();
        $event.currentTarget.remove();
        $scope.searchText = null;
        _.pull($scope.currentUsers, user.id);
        return getFilteredUsers();
      };
      $scope.addItem = function(item) {
        if (item.type === 'user') {
          if (_.find($scope.currentUsers, ['id', item.id])) {
            return;
          }
          if ($scope.single) {
            $scope.currentUsers = [item.id];
            confirmSelection();
            return;
          }
          $scope.currentUsers.push(item.id);
        }
        if (item.type === 'role') {
          $scope.currentUsers = _.union($scope.currentUsers, item.userIds);
        }
        $scope.searchText = null;
        return getFilteredUsers();
      };
      $scope.clearSearch = function() {
        return $scope.searchText = '';
      };
      confirmSelection = function() {
        $scope.loading = true;
        $scope.onClose($scope.currentUsers);
        closeLightbox();
        return $scope.loading = false;
      };
      $el.on("click", ".lb-select-user-confirm", function(event) {
        if ($scope.loading) {
          return;
        }
        event.preventDefault();
        return confirmSelection();
      });
      $el.on("click", ".close", function(event) {
        event.preventDefault();
        closeLightbox();
        return $scope.$apply(function() {
          return $scope.searchText = null;
        });
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      templateUrl: "components/lb-select-user/lb-select-user.html",
      link: link,
      scope: true
    };
  };

  SelectUserDirective.$inject = ["$rootScope", "$tgRepo", "$translate", "lightboxService", "lightboxKeyboardNavigationService", "tgAvatarService", "tgProjectService"];

  angular.module("taigaComponents").directive("tgLbSelectUser", SelectUserDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/live-announcement/live-announcement.directive.coffee
 */

(function() {
  var LiveAnnouncementDirective;

  LiveAnnouncementDirective = function(liveAnnouncementService) {
    var link;
    link = function(scope, el, attrs) {};
    return {
      restrict: "AE",
      scope: {},
      controllerAs: 'vm',
      controller: function() {
        this.close = function() {
          return liveAnnouncementService.open = false;
        };
        return Object.defineProperties(this, {
          open: {
            get: function() {
              return liveAnnouncementService.open;
            }
          },
          title: {
            get: function() {
              return liveAnnouncementService.title;
            }
          },
          desc: {
            get: function() {
              return liveAnnouncementService.desc;
            }
          }
        });
      },
      link: link,
      templateUrl: "components/live-announcement/live-announcement.html"
    };
  };

  LiveAnnouncementDirective.$inject = ["tgLiveAnnouncementService"];

  angular.module("taigaComponents").directive("tgLiveAnnouncement", LiveAnnouncementDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/live-announcement/live-announcement.service.coffee
 */

(function() {
  var LiveAnnouncementService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  LiveAnnouncementService = (function(superClass) {
    extend(LiveAnnouncementService, superClass);

    function LiveAnnouncementService() {
      this.open = false;
      this.title = "";
      this.desc = "";
    }

    LiveAnnouncementService.prototype.show = function(title, desc) {
      this.open = true;
      this.title = title;
      return this.desc = desc;
    };

    return LiveAnnouncementService;

  })(taiga.Service);

  angular.module("taigaComponents").service("tgLiveAnnouncementService", LiveAnnouncementService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/move-to-sprint/move-to-sprint-lb/move-to-sprint-lb.controller.coffee
 */

(function() {
  var MoveToSprintLightboxController, module;

  module = angular.module("taigaComponents");

  MoveToSprintLightboxController = (function() {
    MoveToSprintLightboxController.$inject = ['$rootScope', '$scope', '$tgResources', 'tgProjectService', '$translate', 'lightboxService', '$tgConfirm'];

    function MoveToSprintLightboxController(rootScope, scope, rs, projectService, translate, lightboxService, confirm) {
      this.rootScope = rootScope;
      this.scope = scope;
      this.rs = rs;
      this.projectService = projectService;
      this.translate = translate;
      this.lightboxService = lightboxService;
      this.confirm = confirm;
      this.projectId = this.projectService.project.get('id');
      this.loading = false;
      this.someSelected = false;
      this.selectedSprintId = null;
      this.typesSelected = {
        uss: false,
        tasks: false,
        issues: false
      };
      this.itemsToMove = {};
      this._loadSprints();
      this.scope.$watch("vm.openItems", (function(_this) {
        return function(openItems) {
          if (!openItems) {
            return;
          }
          return _this._init(openItems);
        };
      })(this));
    }

    MoveToSprintLightboxController.prototype._init = function(openItems) {
      var ref, ref1, ref2;
      this.hasManyItemTypes = _.size(this.openItems) > 1;
      this.ussCount = parseInt((ref = openItems.uss) != null ? ref.length : void 0);
      this.updateSelected('uss', this.ussCount > 0);
      this.tasksCount = parseInt((ref1 = openItems.tasks) != null ? ref1.length : void 0);
      this.updateSelected('tasks', this.tasksCount > 0);
      this.issuesCount = parseInt((ref2 = openItems.issues) != null ? ref2.length : void 0);
      return this.updateSelected('issues', this.issuesCount > 0);
    };

    MoveToSprintLightboxController.prototype._loadSprints = function() {
      return this.rs.sprints.list(this.projectId, {
        closed: false
      }).then((function(_this) {
        return function(data) {
          return _this.sprints = _.filter(data.milestones, function(x) {
            return x.id !== _this.sprint.id;
          });
        };
      })(this));
    };

    MoveToSprintLightboxController.prototype.updateSelected = function(itemType, value) {
      this.typesSelected[itemType] = value;
      this.someSelected = _.some(this.typesSelected);
      if (value === true) {
        return this.itemsToMove[itemType] = this.openItems[itemType];
      } else if (this.itemsToMove[itemType]) {
        return delete this.itemsToMove[itemType];
      }
    };

    MoveToSprintLightboxController.prototype.submit = function() {
      var itemsNotMoved;
      itemsNotMoved = {};
      _.map(this.openItems, (function(_this) {
        return function(itemsList, itemsType) {
          if (!_this.itemsToMove[itemsType]) {
            return itemsNotMoved[itemsType] = true;
          }
        };
      })(this));
      this.loading = true;
      return this.moveItems().then((function(_this) {
        return function() {
          _this.rootScope.$broadcast("taskboard:items:move", _this.typesSelected);
          _this.lightboxService.closeAll();
          _this.loading = false;
          if (_.size(itemsNotMoved) > 0) {
            return _this.displayWarning(itemsNotMoved);
          }
        };
      })(this));
    };

    MoveToSprintLightboxController.prototype.moveItems = function() {
      var promises;
      promises = [];
      if (this.itemsToMove.uss) {
        promises.push(this.rs.sprints.moveUserStoriesMilestone(this.sprint.id, this.projectId, this.selectedSprintId, this.itemsToMove.uss));
      }
      if (this.itemsToMove.tasks) {
        promises.push(this.rs.sprints.moveTasksMilestone(this.sprint.id, this.projectId, this.selectedSprintId, this.itemsToMove.tasks));
      }
      if (this.itemsToMove.issues) {
        promises.push(this.rs.sprints.moveIssuesMilestone(this.sprint.id, this.projectId, this.selectedSprintId, this.itemsToMove.issues));
      }
      return Promise.all(promises);
    };

    MoveToSprintLightboxController.prototype.displayWarning = function(itemsNotMoved) {
      var action, desc, ref, title, totalItemsMoved;
      action = this.translate.instant('COMMON.I_GET_IT');
      if (_.size(itemsNotMoved) === 1 && itemsNotMoved.issues === true) {
        title = this.translate.instant('TASKBOARD.MOVE_TO_SPRINT.WARNING_ISSUES_NOT_MOVED_TITLE');
        desc = this.translate.instant('TASKBOARD.MOVE_TO_SPRINT.WARNING_ISSUES_NOT_MOVED');
      } else {
        totalItemsMoved = 0;
        _.map(this.itemsToMove, function(itemsList, itemsType) {
          return totalItemsMoved += itemsList.length;
        });
        title = this.translate.instant('TASKBOARD.MOVE_TO_SPRINT.WARNING_SPRINT_STILL_OPEN_TITLE', {
          total: totalItemsMoved
        }, 'messageformat');
        desc = this.translate.instant('TASKBOARD.MOVE_TO_SPRINT.WARNING_SPRINT_STILL_OPEN', {
          sprintName: (ref = this.sprint) != null ? ref.name : void 0
        });
      }
      return this.confirm.success(title, desc, null, action);
    };

    return MoveToSprintLightboxController;

  })();

  module.controller("MoveToSprintLbCtrl", MoveToSprintLightboxController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/move-to-sprint/move-to-sprint-lb/move-to-sprint-lb.directive.coffee
 */

(function() {
  var module, moveToSprintLightboxDirective;

  module = angular.module("taigaComponents");

  moveToSprintLightboxDirective = function(lightboxService) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return lightboxService.open(el);
    };
    return {
      scope: {},
      bindToController: {
        openItems: "=",
        sprint: "="
      },
      templateUrl: "components/move-to-sprint/move-to-sprint-lb/move-to-sprint-lb.html",
      controller: "MoveToSprintLbCtrl",
      controllerAs: "vm",
      link: link
    };
  };

  moveToSprintLightboxDirective.$inject = ["lightboxService"];

  module.directive("tgLbMoveToSprint", moveToSprintLightboxDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/move-to-sprint/move-to-sprint-controller.coffee
 */

(function() {
  var MoveToSprintController, taiga;

  taiga = this.taiga;

  MoveToSprintController = (function() {
    MoveToSprintController.$inject = ['$scope', 'tgLightboxFactory', 'tgProjectService'];

    function MoveToSprintController(scope, lightboxFactory, projectService) {
      this.scope = scope;
      this.lightboxFactory = lightboxFactory;
      this.projectService = projectService;
      this.permissions = this.projectService.project.get('my_permissions');
      this.hasOpenItems = false;
      this.disabled = false;
      this.openItems = {
        uss: [],
        tasks: [],
        issues: []
      };
      this.scope.$watch("vm.uss", (function(_this) {
        return function() {
          return _this.getOpenUss();
        };
      })(this));
      this.scope.$watch("vm.unnasignedTasks", (function(_this) {
        return function() {
          return _this.getOpenStorylessTasks();
        };
      })(this));
      this.scope.$watch("vm.issues", (function(_this) {
        return function() {
          return _this.getOpenIssues();
        };
      })(this));
    }

    MoveToSprintController.prototype.checkOpenItems = function() {
      return _.some(Object.keys(this.openItems), (function(_this) {
        return function(x) {
          return _this.openItems[x].length > 0;
        };
      })(this));
    };

    MoveToSprintController.prototype.openLightbox = function() {
      var openItems;
      if (this.disabled === !true && this.hasOpenItems) {
        openItems = {};
        _.map(this.openItems, function(itemsList, itemsType) {
          if (itemsList.length) {
            return openItems[itemsType] = itemsList;
          }
        });
        return this.lightboxFactory.create('tg-lb-move-to-sprint', {
          "class": "lightbox lightbox-move-to-sprint",
          "sprint": "sprint",
          "open-items": "openItems"
        }, {
          sprint: this.sprint,
          openItems: openItems
        });
      }
    };

    MoveToSprintController.prototype.getOpenUss = function() {
      if (!this.uss || this.permissions.indexOf("modify_us") === -1) {
        return;
      }
      this.openItems.uss = [];
      this.uss.map((function(_this) {
        return function(us) {
          if (us.is_closed === false) {
            return _this.openItems.uss.push({
              us_id: us.id,
              order: us.sprint_order
            });
          }
        };
      })(this));
      return this.hasOpenItems = this.checkOpenItems();
    };

    MoveToSprintController.prototype.getOpenStorylessTasks = function() {
      if (!this.unnasignedTasks || this.permissions.indexOf("modify_task") === -1) {
        return;
      }
      this.openItems.tasks = [];
      this.unnasignedTasks.map((function(_this) {
        return function(column) {
          return column.map(function(task) {
            if (task.get('model').get('is_closed') === false) {
              return _this.openItems.tasks.push({
                task_id: task.get('model').get('id'),
                order: task.get('model').get('taskboard_order')
              });
            }
          });
        };
      })(this));
      return this.hasOpenItems = this.checkOpenItems();
    };

    MoveToSprintController.prototype.getOpenIssues = function() {
      if (!this.issues || this.permissions.indexOf("modify_issue") === -1) {
        return;
      }
      this.openItems.issues = [];
      this.issues.map((function(_this) {
        return function(issue) {
          if (issue.get('status').get('is_closed') === false) {
            return _this.openItems.issues.push({
              issue_id: issue.get('id')
            });
          }
        };
      })(this));
      return this.hasOpenItems = this.checkOpenItems();
    };

    return MoveToSprintController;

  })();

  angular.module('taigaComponents').controller('MoveToSprintCtrl', MoveToSprintController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/move-to-sprint/move-to-sprint.directive.coffee
 */

(function() {
  var module, moveToSprintDirective;

  module = angular.module("taigaComponents");

  moveToSprintDirective = function(taskboardTasksService) {
    return {
      controller: "MoveToSprintCtrl",
      controllerAs: "vm",
      bindToController: true,
      templateUrl: 'components/move-to-sprint/move-to-sprint.html',
      scope: {
        sprint: '=',
        uss: '=',
        unnasignedTasks: '=',
        issues: '=',
        disabled: '='
      }
    };
  };

  moveToSprintDirective.$inject = ['tgTaskboardTasks'];

  module.directive('tgMoveToSprint', [moveToSprintDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/project-logo-big-src/project-logo-big-src.directive.coffee
 */

(function() {
  var ProjectLogoBigSrcDirective;

  ProjectLogoBigSrcDirective = function(projectLogoService) {
    var link;
    link = function(scope, el, attrs) {
      return scope.$watch('project', function(project) {
        var logo, projectLogo;
        project = Immutable.fromJS(project);
        if (!project) {
          return;
        }
        projectLogo = project.get('logo_big_url');
        if (projectLogo) {
          el.attr('src', projectLogo);
          return el.css('background', "");
        } else {
          logo = projectLogoService.getDefaultProjectLogo(project.get('slug'), project.get('id'));
          el.attr('src', logo.src);
          return el.css('background', logo.color);
        }
      });
    };
    return {
      link: link,
      scope: {
        project: "=tgProjectLogoBigSrc"
      }
    };
  };

  ProjectLogoBigSrcDirective.$inject = ["tgProjectLogoService"];

  angular.module("taigaComponents").directive("tgProjectLogoBigSrc", ProjectLogoBigSrcDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/project-logo-small-src/project-logo-small-src.directive.coffee
 */

(function() {
  var ProjectLogoSmallSrcDirective;

  ProjectLogoSmallSrcDirective = function(projectLogoService) {
    var link;
    link = function(scope, el, attrs) {
      return scope.$watch('project', function(project) {
        var logo, projectLogo;
        project = Immutable.fromJS(project);
        if (!project) {
          return;
        }
        projectLogo = project.get('logo_small_url');
        if (projectLogo) {
          el.attr('src', projectLogo);
          return el.css('background', "");
        } else {
          logo = projectLogoService.getDefaultProjectLogo(project.get('slug'), project.get('id'));
          el.attr('src', logo.src);
          return el.css('background', logo.color);
        }
      });
    };
    return {
      link: link,
      scope: {
        project: "=tgProjectLogoSmallSrc"
      }
    };
  };

  ProjectLogoSmallSrcDirective.$inject = ["tgProjectLogoService"];

  angular.module("taigaComponents").directive("tgProjectLogoSmallSrc", ProjectLogoSmallSrcDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/project-menu/project-menu.controller.coffee
 */

(function() {
  var ProjectMenuController;

  ProjectMenuController = (function() {
    ProjectMenuController.$inject = ["tgProjectService", "tgLightboxFactory"];

    function ProjectMenuController(projectService, lightboxFactory) {
      this.projectService = projectService;
      this.lightboxFactory = lightboxFactory;
      this.project = null;
      this.menu = Immutable.Map();
    }

    ProjectMenuController.prototype.show = function() {
      var ref;
      this.project = this.projectService.project;
      this.sprints = (ref = this.project.get('milestones')) != null ? ref.toJS() : void 0;
      this.active = this._getActiveSection();
      this._setVideoConference();
      return this._setMenuPermissions();
    };

    ProjectMenuController.prototype.hide = function() {
      this.project = null;
      return this.menu = {};
    };

    ProjectMenuController.prototype.search = function() {
      return this.lightboxFactory.create("tg-search-box", {
        "class": "lightbox lightbox-search"
      });
    };

    ProjectMenuController.prototype._setVideoConference = function() {
      var videoconferenceUrl;
      videoconferenceUrl = this._videoConferenceUrl();
      if (videoconferenceUrl) {
        return this.project = this.project.set("videoconferenceUrl", videoconferenceUrl);
      }
    };

    ProjectMenuController.prototype._setMenuPermissions = function() {
      this.menu = Immutable.Map({
        epics: false,
        backlog: false,
        kanban: false,
        issues: false,
        wiki: false
      });
      if (this.project.get("is_epics_activated") && this.project.get("my_permissions").indexOf("view_epics") !== -1) {
        this.menu = this.menu.set("epics", true);
      }
      if (this.project.get("is_backlog_activated") && this.project.get("my_permissions").indexOf("view_us") !== -1) {
        this.menu = this.menu.set("backlog", true);
      }
      if (this.project.get("is_kanban_activated") && this.project.get("my_permissions").indexOf("view_us") !== -1) {
        this.menu = this.menu.set("kanban", true);
      }
      if (this.project.get("is_issues_activated") && this.project.get("my_permissions").indexOf("view_issues") !== -1) {
        this.menu = this.menu.set("issues", true);
      }
      if (this.project.get("is_wiki_activated") && this.project.get("my_permissions").indexOf("view_wiki_pages") !== -1) {
        return this.menu = this.menu.set("wiki", true);
      }
    };

    ProjectMenuController.prototype._getActiveSection = function() {
      var indexBacklog, indexKanban, oldSectionName, sectionName, sectionsBreadcrumb;
      sectionName = this.projectService.section;
      sectionsBreadcrumb = this.projectService.sectionsBreadcrumb;
      indexBacklog = sectionsBreadcrumb.lastIndexOf("backlog");
      indexKanban = sectionsBreadcrumb.lastIndexOf("kanban");
      if (indexBacklog !== -1 || indexKanban !== -1) {
        if (indexKanban === -1 || indexBacklog > indexKanban) {
          oldSectionName = "backlog";
        } else {
          oldSectionName = "kanban";
        }
      }
      if (sectionName === "backlog-kanban") {
        if (oldSectionName === "backlog" || oldSectionName === "kanban") {
          sectionName = oldSectionName;
        } else if (this.project.get("is_backlog_activated") && !this.project.get("is_kanban_activated")) {
          sectionName = "backlog";
        } else if (!this.project.get("is_backlog_activated") && this.project.get("is_kanban_activated")) {
          sectionName = "kanban";
        }
      }
      return sectionName;
    };

    ProjectMenuController.prototype._videoConferenceUrl = function() {
      var baseUrl, url;
      if (this.project.get("videoconferences") === "whereby-com") {
        baseUrl = "https://whereby.com/";
      } else if (this.project.get("videoconferences") === "talky") {
        baseUrl = "https://talky.io/";
      } else if (this.project.get("videoconferences") === "jitsi") {
        baseUrl = "https://meet.jit.si/";
      } else if (this.project.get("videoconferences") === "custom") {
        return this.project.get("videoconferences_extra_data");
      } else {
        return "";
      }
      if (this.project.get("videoconferences_extra_data")) {
        url = this.project.get("slug") + "-" + taiga.slugify(this.project.get("videoconferences_extra_data"));
      } else {
        url = this.project.get("slug");
      }
      if (this.project.get("videoconferences") === "jitsi") {
        url = url.replace(/-/g, "");
      }
      return baseUrl + url;
    };

    return ProjectMenuController;

  })();

  angular.module("taigaComponents").controller("ProjectMenu", ProjectMenuController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/project-menu/project-menu.directive.coffee
 */

(function() {
  var ProjectMenuDirective, taiga;

  taiga = this.taiga;

  ProjectMenuDirective = function(projectService, lightboxFactory) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var projectChange;
      projectChange = function() {
        if (projectService.project) {
          return ctrl.show();
        } else {
          return ctrl.hide();
        }
      };
      scope.$watch((function() {
        return projectService.project;
      }), projectChange);
      scope.vm.fixed = false;
      return $(window).on("scroll", function() {
        var position;
        position = $(window).scrollTop();
        if (position > 100 && scope.vm.fixed === false) {
          scope.vm.fixed = true;
          return scope.$digest();
        } else if (position < 100 && scope.vm.fixed === true) {
          scope.vm.fixed = false;
          return scope.$digest();
        }
      });
    };
    return {
      scope: {},
      controller: "ProjectMenu",
      controllerAs: "vm",
      templateUrl: "components/project-menu/project-menu.html",
      link: link
    };
  };

  ProjectMenuDirective.$inject = ["tgProjectService", "tgLightboxFactory"];

  angular.module("taigaComponents").directive("tgProjectMenu", ProjectMenuDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/promote-to-us/promote-to-us.directive.coffee
 */

(function() {
  var PromoteToUsButtonDirective;

  PromoteToUsButtonDirective = function($rootScope, $rs, $confirm, $translate) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var itemType, save;
      itemType = null;
      save = function(item, askResponse) {
        var data, onError, onSuccess;
        data = {
          project: item.project
        };
        onSuccess = function(response) {
          askResponse.finish();
          $confirm.notify("success");
          return $rootScope.$broadcast("promote-" + itemType + "-to-us:success", response.data[0]);
        };
        onError = function() {
          askResponse.finish();
          return $confirm.notify("error");
        };
        return $rs[item._name].promoteToUserStory(item.id, item.project).then(onSuccess, onError);
      };
      $el.on("click", "a", function(event) {
        var ctx, item, message, subtitle, title;
        event.preventDefault();
        item = $model.$modelValue;
        itemType = _.get({
          tasks: 'task',
          issues: 'issue'
        }, item._name);
        ctx = "COMMON.CONFIRM_PROMOTE." + (itemType.toUpperCase());
        title = $translate.instant(ctx + ".TITLE");
        message = $translate.instant(ctx + ".MESSAGE");
        subtitle = item.subject;
        return $confirm.ask(title, subtitle, message).then(function(response) {
          return save(item, response);
        });
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      restrict: "AE",
      require: "ngModel",
      templateUrl: "components/promote-to-us/promote-to-us.html",
      link: link
    };
  };

  angular.module("taigaComponents").directive("tgPromoteToUsButton", ["$rootScope", "$tgResources", "$tgConfirm", "$translate", PromoteToUsButtonDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/search-list/search-list.directive.coffee
 */

(function() {
  var groupBy, module, normalizeString, searchListDirective;

  module = angular.module("taigaComponents");

  normalizeString = this.taiga.normalizeString;

  groupBy = this.taiga.groupBy;

  searchListDirective = function($translate) {
    var link;
    link = function(scope, el, attrs, model) {
      var avaliableItems, filtering, isContainedIn, itemsById, parseString, resetAll, resetSelected;
      scope.templateUrl = "components/search-list/search-list-" + scope.itemType + "-choice.html";
      scope.currentSelected = null;
      filtering = false;
      avaliableItems = [];
      itemsById = {};
      if (scope.itemType === 'issue') {
        scope.milestonesById = groupBy(scope.project.milestones, function(e) {
          return e.id;
        });
      }
      if (scope.filterClosed) {
        scope.showClosed = false;
        if (scope.itemType === 'sprint') {
          scope.textShowClosed = $translate.instant("BACKLOG.SPRINTS.ACTION_SHOW_CLOSED_SPRINTS");
          scope.textHideClosed = $translate.instant("BACKLOG.SPRINTS.ACTION_HIDE_CLOSED_SPRINTS");
        }
      }
      el.on("click", ".choice", function(event) {
        var choiceId, ref, value;
        choiceId = parseInt($(event.currentTarget).data("choice-id"));
        value = ((ref = attrs.ngModel) != null ? ref.id : void 0) !== choiceId ? itemsById[choiceId] : null;
        model.$setViewValue(value);
        scope.currentSelected = value;
        return scope.$apply();
      });
      isContainedIn = function(needle, haystack) {
        return _.includes(parseString(haystack), parseString(needle));
      };
      parseString = function(value) {
        if (typeof value !== 'string') {
          value = value.toString();
        }
        return normalizeString(value.toUpperCase());
      };
      resetSelected = function() {
        scope.currentSelected = null;
        return model.$setViewValue(null);
      };
      resetAll = function() {
        resetSelected();
        scope.searchText = '';
        avaliableItems = angular.copy(scope.items);
        return itemsById = groupBy(avaliableItems, function(x) {
          return x.id;
        });
      };
      scope.isVisible = function(item) {
        var ref;
        if (!scope.filterClosed || scope.showClosed) {
          return true;
        }
        if (scope.itemType === 'sprint' && (item.closed || item.is_closed)) {
          if (((ref = scope.currentSelected) != null ? ref.id : void 0) === item.id) {
            resetSelected();
          }
          return false;
        }
        return true;
      };
      scope.toggleShowClosed = function(item) {
        return scope.showClosed = !scope.showClosed;
      };
      scope.filterItems = function(searchText) {
        scope.filtering = true;
        scope.items = _.filter(avaliableItems, function(item) {
          var itemAttrs;
          itemAttrs = item.getAttrs();
          if (Array.isArray(scope.filterBy)) {
            return _.some(scope.filterBy, function(attr) {
              return isContainedIn(searchText, itemAttrs[attr]);
            });
          } else {
            return isContainedIn(searchText, itemAttrs[scope.filterBy]);
          }
        });
        if (!_.find(scope.items, scope.currentSelected)) {
          return resetSelected();
        }
      };
      return scope.$watch('items', function(items) {
        if (!scope.filtering && items) {
          return resetAll();
        }
      });
    };
    return {
      link: link,
      templateUrl: "components/search-list/search-list.html",
      require: "ngModel",
      scope: {
        label: '@',
        placeholder: '@',
        project: '=',
        filterBy: '=',
        items: '=',
        itemType: '@',
        filterClosed: '=',
        itemDisabled: '='
      }
    };
  };

  module.directive('tgSearchList', ['$translate', searchListDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2017 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: tag-line.directive.coffee
 */

(function() {
  var TagOptionDirective, module;

  module = angular.module('taigaCommon');

  TagOptionDirective = function() {
    var dispatch, link, select, stop;
    select = function(selected) {
      var containerHeight, diff, selectedPosition;
      selected.addClass('selected');
      selectedPosition = selected.position().top + selected.outerHeight();
      containerHeight = selected.parent().outerHeight();
      if (selectedPosition > containerHeight) {
        diff = selectedPosition - containerHeight;
        return selected.parent().scrollTop(selected.parent().scrollTop() + diff);
      } else if (selected.position().top < 0) {
        return selected.parent().scrollTop(selected.parent().scrollTop() + selected.position().top);
      }
    };
    dispatch = function(el, code, scope) {
      var activeElement, next, prev;
      activeElement = el.find(".selected");
      if (code === 40) {
        if (!activeElement.length) {
          return select(el.find('li:first'));
        } else {
          next = activeElement.next('li');
          if (next.length) {
            activeElement.removeClass('selected');
            return select(next);
          }
        }
      } else if (code === 38) {
        if (!activeElement.length) {
          return select(el.find('li:last'));
        } else {
          prev = activeElement.prev('li');
          if (prev.length) {
            activeElement.removeClass('selected');
            return select(prev);
          }
        }
      }
    };
    stop = function() {
      return $(document).off(".tags-keyboard-navigation");
    };
    link = function(scope, el) {
      stop();
      $(el).parent().on("keydown.tags-keyboard-navigation", (function(_this) {
        return function(event) {
          var code;
          code = event.keyCode ? event.keyCode : event.which;
          if (code === 40 || code === 38) {
            event.preventDefault();
            return dispatch(el, code, scope);
          }
        };
      })(this));
      return scope.$on("$destroy", stop);
    };
    return {
      link: link,
      templateUrl: "components/tags/tag-dropdown/tag-dropdown.html",
      scope: {
        onSelectTag: "&",
        colorArray: "=",
        tag: "="
      }
    };
  };

  module.directive("tgTagsDropdown", TagOptionDirective);

}).call(this);


/*
 * Copyright (C) 2014-2017 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: tag-line.controller.coffee
 */

(function() {
  var TagLineCommonController, module, trim;

  trim = this.taiga.trim;

  module = angular.module('taigaCommon');

  TagLineCommonController = (function() {
    TagLineCommonController.$inject = ["tgTagLineService"];

    function TagLineCommonController(tagLineService) {
      this.tagLineService = tagLineService;
      this.disableColorSelection = false;
      this.newTag = {
        name: "",
        color: null
      };
      this.colorArray = [];
      this.addTag = false;
    }

    TagLineCommonController.prototype.checkPermissions = function() {
      return this.tagLineService.checkPermissions(this.project.my_permissions, this.permissions);
    };

    TagLineCommonController.prototype._createColorsArray = function(projectTagColors) {
      return this.colorArray = this.tagLineService.createColorsArray(projectTagColors);
    };

    TagLineCommonController.prototype.displayTagInput = function() {
      return this.addTag = true;
    };

    TagLineCommonController.prototype.addNewTag = function(name, color) {
      this.newTag.name = "";
      this.newTag.color = null;
      if (!name.length) {
        return;
      }
      if (this.disableColorSelection) {
        if (name.length) {
          return this.onAddTag({
            name: name,
            color: color
          });
        }
      } else {
        if (this.project.tags_colors[name]) {
          color = this.project.tags_colors[name];
        }
        return this.onAddTag({
          name: name,
          color: color
        });
      }
    };

    TagLineCommonController.prototype.selectColor = function(color) {
      return this.newTag.color = color;
    };

    return TagLineCommonController;

  })();

  module.controller("TagLineCommonCtrl", TagLineCommonController);

}).call(this);


/*
 * Copyright (C) 2014-2017 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: tag-line.directive.coffee
 */

(function() {
  var TagLineCommonDirective, module;

  module = angular.module('taigaCommon');

  TagLineCommonDirective = function() {
    var link;
    link = function(scope, el, attr, ctrl) {
      var unwatch;
      if (!_.isUndefined(attr.disableColorSelection)) {
        ctrl.disableColorSelection = true;
      }
      unwatch = scope.$watch("vm.project", function(project) {
        if (!project || !Object.keys(project).length) {
          return;
        }
        unwatch();
        if (!ctrl.disableColorSelection) {
          return ctrl.colorArray = ctrl._createColorsArray(ctrl.project.tags_colors);
        }
      });
      return el.on("keydown", ".tag-input", function(event) {
        var tagName;
        if (event.keyCode === 27) {
          ctrl.addTag = false;
          ctrl.newTag.name = "";
          ctrl.newTag.color = "";
          event.stopPropagation();
        } else if (event.keyCode === 13) {
          event.preventDefault();
          if (el.find('.tags-dropdown .selected').length) {
            tagName = $('.tags-dropdown .selected .tags-dropdown-name').text();
            ctrl.addNewTag(tagName, null);
          } else {
            ctrl.addNewTag(ctrl.newTag.name, ctrl.newTag.color);
          }
        }
        return scope.$apply();
      });
    };
    return {
      link: link,
      scope: {
        permissions: "@",
        loadingAddTag: "=",
        loadingRemoveTag: "=",
        tags: "=",
        project: "=",
        onAddTag: "&",
        onDeleteTag: "&"
      },
      templateUrl: "components/tags/tag-line-common/tag-line-common.html",
      controller: "TagLineCommonCtrl",
      controllerAs: "vm",
      bindToController: true
    };
  };

  module.directive("tgTagLineCommon", TagLineCommonDirective);

}).call(this);


/*
 * Copyright (C) 2014-2017 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: tag-line.controller.coffee
 */

(function() {
  var TagLineController, module, trim;

  trim = this.taiga.trim;

  module = angular.module('taigaCommon');

  TagLineController = (function() {
    TagLineController.$inject = ["$rootScope", "$tgConfirm", "$tgQueueModelTransformation"];

    function TagLineController(rootScope, confirm, modelTransform) {
      this.rootScope = rootScope;
      this.confirm = confirm;
      this.modelTransform = modelTransform;
      this.loadingAddTag = false;
    }

    TagLineController.prototype.onDeleteTag = function(tag) {
      var onDeleteTagError, onDeleteTagSuccess, tagName, transform;
      this.loadingRemoveTag = tag[0];
      onDeleteTagSuccess = (function(_this) {
        return function(item) {
          _this.rootScope.$broadcast("object:updated");
          _this.loadingRemoveTag = false;
          return item;
        };
      })(this);
      onDeleteTagError = (function(_this) {
        return function() {
          _this.confirm.notify("error");
          return _this.loadingRemoveTag = false;
        };
      })(this);
      tagName = trim(tag[0].toLowerCase());
      transform = this.modelTransform.save(function(item) {
        var itemtags;
        itemtags = _.clone(item.tags);
        _.remove(itemtags, function(tag) {
          return tag[0] === tagName;
        });
        item.tags = itemtags;
        return item;
      });
      return transform.then(onDeleteTagSuccess, onDeleteTagError);
    };

    TagLineController.prototype.onAddTag = function(tag, color) {
      var onAddTagError, onAddTagSuccess, transform;
      this.loadingAddTag = true;
      onAddTagSuccess = (function(_this) {
        return function(item) {
          _this.rootScope.$broadcast("object:updated");
          _this.rootScope.$broadcast("tags:updated");
          _this.addTag = false;
          _this.loadingAddTag = false;
          return item;
        };
      })(this);
      onAddTagError = (function(_this) {
        return function() {
          _this.loadingAddTag = false;
          return _this.confirm.notify("error");
        };
      })(this);
      transform = this.modelTransform.save((function(_this) {
        return function(item) {
          var itemtags, value;
          value = trim(tag.toLowerCase());
          itemtags = _.clone(item.tags);
          itemtags.push([tag, color]);
          item.tags = itemtags;
          return item;
        };
      })(this));
      return transform.then(onAddTagSuccess, onAddTagError);
    };

    return TagLineController;

  })();

  module.controller("TagLineCtrl", TagLineController);

}).call(this);


/*
 * Copyright (C) 2014-2017 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: tag-line.directive.coffee
 */

(function() {
  var TagLineDirective, module;

  module = angular.module('taigaCommon');

  TagLineDirective = function() {
    return {
      scope: {
        item: "=",
        permissions: "@",
        project: "="
      },
      templateUrl: "components/tags/tag-line-detail/tag-line-detail.html",
      controller: "TagLineCtrl",
      controllerAs: "vm",
      bindToController: true
    };
  };

  module.directive("tgTagLine", TagLineDirective);

}).call(this);


/*
 * Copyright (C) 2014-2017 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: tag-line.service.coffee
 */

(function() {
  var TagLineService, module,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  module = angular.module('taigaCommon');

  TagLineService = (function(superClass) {
    extend(TagLineService, superClass);

    TagLineService.$inject = [];

    function TagLineService() {}

    TagLineService.prototype.checkPermissions = function(myPermissions, projectPermissions) {
      return _.includes(myPermissions, projectPermissions);
    };

    TagLineService.prototype.createColorsArray = function(projectTagColors) {
      return _.map(projectTagColors, function(index, value) {
        return [value, index];
      });
    };

    return TagLineService;

  })(taiga.Service);

  module.service("tgTagLineService", TagLineService);

}).call(this);


/*
 * Copyright (C) 2014-2017 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: tag-line.directive.coffee
 */

(function() {
  var TagDirective, module;

  module = angular.module('taigaCommon');

  TagDirective = function() {
    return {
      templateUrl: "components/tags/tag/tag.html",
      scope: {
        tag: "<",
        loadingRemoveTag: "<",
        onDeleteTag: "&",
        hasPermissions: "@"
      }
    };
  };

  module.directive("tgTag", TagDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/taskboard-zoom/taskboard-zoom.directive.coffee
 */

(function() {
  var TaskboardZoomDirective;

  TaskboardZoomDirective = function(storage) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var getZoomView, zooms;
      scope.zoomIndex = storage.get("taskboard_zoom") || 2;
      scope.levels = 4;
      zooms = [["ref"], ["subject"], ["owner", "tags", "extra_info", "unfold"], ["attachments", "empty_extra_info"], ["related_tasks"]];
      getZoomView = function(zoomIndex) {
        if (zoomIndex == null) {
          zoomIndex = 0;
        }
        if (storage.get("taskboard_zoom") !== zoomIndex) {
          storage.set("taskboard_zoom", zoomIndex);
        }
        return _.reduce(zooms, function(result, value, key) {
          if (key <= zoomIndex) {
            result = result.concat(value);
          }
          return result;
        });
      };
      return scope.$watch('zoomIndex', function(zoomLevel) {
        var zoom;
        zoom = getZoomView(zoomLevel);
        return scope.onZoomChange({
          zoomLevel: zoomLevel,
          zoom: zoom
        });
      });
    };
    return {
      scope: {
        onZoomChange: "&"
      },
      template: "<tg-board-zoom\n    levels=\"levels\"\n    class=\"board-zoom\"\n    value=\"zoomIndex\"\n></tg-board-zoom>",
      link: link
    };
  };

  angular.module('taigaComponents').directive("tgTaskboardZoom", ["$tgStorage", TaskboardZoomDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: tasks-sortable.directive.coffee
 */

(function() {
  var TasksSortableDirective;

  TasksSortableDirective = function($parse, projectService) {
    var link;
    link = function(scope, el, attrs) {
      var callback, drake, scroll;
      if (!projectService.hasPermission("modify_task")) {
        return;
      }
      callback = $parse(attrs.tgTasksSortable);
      drake = dragula([el[0]], {
        copySortSource: false,
        copy: false,
        mirrorContainer: el[0],
        moves: function(item) {
          return $(item).is('div.single-related-task.js-related-task');
        }
      });
      drake.on('dragend', function(item) {
        var itemEl, newIndex, task;
        itemEl = $(item);
        task = itemEl.scope().task;
        newIndex = itemEl.index();
        return scope.$apply(function() {
          return callback(scope, {
            task: task,
            newIndex: newIndex
          });
        });
      });
      scroll = autoScroll(window, {
        margin: 20,
        pixels: 30,
        scrollWhenOutside: true,
        autoScroll: function() {
          return this.down && drake.dragging;
        }
      });
      return scope.$on("$destroy", function() {
        el.off();
        return drake.destroy();
      });
    };
    return {
      link: link
    };
  };

  TasksSortableDirective.$inject = ["$parse", "tgProjectService"];

  angular.module("taigaComponents").directive("tgTasksSortable", TasksSortableDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/terms-announcement/terms-announcement.directive.coffee
 */

(function() {
  var TermsAnnouncementDirective;

  TermsAnnouncementDirective = function(TermsAnnouncementService, $repo, $auth, $config, $model) {
    var link;
    link = function(scope, el, attrs) {
      scope.privacyPolicyUrl = $config.get("privacyPolicyUrl");
      scope.termsOfServiceUrl = $config.get("termsOfServiceUrl");
      return scope.GDPRUrl = $config.get("GDPRUrl");
    };
    return {
      restrict: "AE",
      scope: {},
      controllerAs: 'vm',
      controller: function() {
        this.close = function() {
          var onSuccess, user, userData;
          TermsAnnouncementService.open = false;
          user = $auth.getUser();
          if (user.read_new_terms === void 0) {
            userData = user.getAttrs();
            userData.read_new_terms = false;
            user = $model.make_model("users", userData);
          }
          user.read_new_terms = true;
          onSuccess = function(data) {
            return $auth.setUser(data);
          };
          return $repo.save(user).then(onSuccess);
        };
        return Object.defineProperties(this, {
          open: {
            get: function() {
              return TermsAnnouncementService.open;
            }
          }
        });
      },
      link: link,
      templateUrl: "components/terms-announcement/terms-announcement.html"
    };
  };

  TermsAnnouncementDirective.$inject = ["tgTermsAnnouncementService", "$tgRepo", "$tgAuth", "$tgConfig", "$tgModel"];

  angular.module("taigaComponents").directive("tgTermsAnnouncement", TermsAnnouncementDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/terms-announcement/terms-announcement.service.coffee
 */

(function() {
  var TermsAnnouncementService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TermsAnnouncementService = (function(superClass) {
    extend(TermsAnnouncementService, superClass);

    function TermsAnnouncementService() {
      this.open = false;
    }

    TermsAnnouncementService.prototype.show = function() {
      return this.open = true;
    };

    return TermsAnnouncementService;

  })(taiga.Service);

  angular.module("taigaComponents").service("tgTermsAnnouncementService", TermsAnnouncementService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/terms-of-service-and-privacy-policy-notice/terms-of-service-and-privacy-policy-notice.directive.coffee
 */

(function() {
  var TermsOfServiceAndPrivacyPolicyNoticeDirective;

  TermsOfServiceAndPrivacyPolicyNoticeDirective = function($config) {
    var link;
    link = function(scope, el, attrs) {
      scope.privacyPolicyUrl = $config.get("privacyPolicyUrl");
      scope.termsOfServiceUrl = $config.get("termsOfServiceUrl");
      scope.target = false;
      if (!scope.privacyPolicyUrl || !scope.termsOfServiceUrl) {
        scope.target = true;
      }
      return el.on("change", "input[name='accepted_terms']", function(event) {
        var target;
        target = angular.element(event.currentTarget);
        scope.target = target.is(":checked");
        return scope.$apply();
      });
    };
    return {
      restrict: "AE",
      link: link,
      scope: {
        target: "="
      },
      templateUrl: "components/terms-of-service-and-privacy-policy-notice/terms-of-service-and-privacy-policy-notice.html"
    };
  };

  angular.module("taigaComponents").directive("tgTermsOfServiceAndPrivacyPolicyNotice", ["$tgConfig", TermsOfServiceAndPrivacyPolicyNoticeDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/assigned/assigned-to.directive.coffee
 */

(function() {
  var AssignedToDirective;

  AssignedToDirective = function($rootscope, $confirm, $repo, $loading, $modelTransform, $template, $translate, $compile, $currentUserService, avatarService, $lightboxFactory) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var currentUserId, isEditable, isIocaine, isSelfAssigned, ref, render, save;
      currentUserId = (ref = $currentUserService.getUser()) != null ? ref.get('id') : void 0;
      isEditable = function() {
        var ref1, ref2;
        return ((ref1 = $scope.project) != null ? (ref2 = ref1.my_permissions) != null ? ref2.indexOf($attrs.requiredPerm) : void 0 : void 0) !== -1;
      };
      isIocaine = function(item) {
        return item != null ? item.is_iocaine : void 0;
      };
      isSelfAssigned = function() {
        return $scope.assignedUser && $scope.assignedUser.id === currentUserId;
      };
      save = function(userId) {
        var transform;
        $scope.loading = true;
        transform = $modelTransform.save(function(item) {
          item.assigned_to = userId;
          return item;
        });
        transform.then(function(item) {
          $attrs.ngModel = item;
          return $rootscope.$broadcast("object:updated");
        });
        transform.then(null, function() {
          return $confirm.notify("error");
        });
        transform["finally"](function() {
          return $scope.loading = false;
        });
        return transform;
      };
      render = function(item) {
        $scope.assignedUser = $scope.usersById[item != null ? item.assigned_to : void 0];
        $scope.isEditable = isEditable();
        $scope.isIocaine = isIocaine(item);
        return $scope.isSelfAssigned = isSelfAssigned();
      };
      $el.on("click", ".remove-user", function(event) {
        var title;
        if (!isEditable()) {
          return;
        }
        event.stopPropagation();
        title = $translate.instant("COMMON.ASSIGNED_TO.CONFIRM_UNASSIGNED");
        return $confirm.ask(title).then(function(response) {
          response.finish();
          return save(null);
        });
      });
      $scope.openAssignedUsers = function() {
        var item, onClose;
        onClose = (function(_this) {
          return function(assignedUsers) {
            return save(assignedUsers.pop() || null);
          };
        })(this);
        item = _.clone($model.$modelValue, false);
        return $lightboxFactory.create('tg-lb-select-user', {
          "class": "lightbox lightbox-select-user"
        }, {
          "currentUsers": [item.assigned_to],
          "activeUsers": this.activeUsers,
          "onClose": onClose,
          "single": true,
          "lbTitle": $translate.instant("COMMON.ASSIGNED_USERS.ADD")
        });
      };
      $scope.selfAssign = function() {
        return save(currentUserId);
      };
      $scope.$watch($attrs.ngModel, function(item, currentItem) {
        if (item == null) {
          return;
        }
        return render(item);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      link: link,
      templateUrl: "components/ticket-assigned/assigned-to.html",
      require: "ngModel"
    };
  };

  angular.module('taigaComponents').directive("tgAssignedTo", ["$rootScope", "$tgConfirm", "$tgRepo", "$tgLoading", "$tgQueueModelTransformation", "$tgTemplate", "$translate", "$compile", "tgCurrentUserService", "tgAvatarService", "tgLightboxFactory", AssignedToDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/assigned/assigned-users.directive.coffee
 */

(function() {
  var AssignedUsersDirective,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  AssignedUsersDirective = function($rootscope, $confirm, $repo, $modelTransform, $template, $compile, $translate, $currentUserService, $lightboxFactory) {
    var link;
    link = function($scope, $el, $attrs, $model) {
      var currentUserId, deleteAssignedUser, isEditable, ref, render, save;
      currentUserId = (ref = $currentUserService.getUser()) != null ? ref.get('id') : void 0;
      $scope.visibleAssignedUsersCount = 4;
      $scope.displayHidden = false;
      $scope.toggleFold = function() {
        return $scope.displayHidden = !$scope.displayHidden;
      };
      isEditable = function() {
        var ref1, ref2;
        return ((ref1 = $scope.project) != null ? (ref2 = ref1.my_permissions) != null ? ref2.indexOf($attrs.requiredPerm) : void 0 : void 0) !== -1;
      };
      save = function(assignedUsersIds, assignedToUser) {
        var transform;
        $scope.loading = true;
        transform = $modelTransform.save(function(item) {
          item.assigned_users = assignedUsersIds;
          if (assignedToUser) {
            item.assigned_to = assignedToUser;
          } else if (!assignedUsersIds.length) {
            item.assigned_to = null;
          } else if (!_.includes(assignedUsersIds, item.assigned_to)) {
            item.assigned_to = assignedUsersIds[0];
          }
          return item;
        });
        transform.then(function() {
          var result;
          return result = $rootscope.$broadcast("object:updated");
        });
        transform.then(null, function() {
          return $confirm.notify("error");
        });
        return transform["finally"](function() {
          return $scope.loading = false;
        });
      };
      $scope.openAssignedUsers = function() {
        var item, onClose;
        onClose = (function(_this) {
          return function(assignedUsers) {
            return save(assignedUsers);
          };
        })(this);
        item = _.clone($model.$modelValue, false);
        return $lightboxFactory.create('tg-lb-select-user', {
          "class": "lightbox lightbox-select-user"
        }, {
          "currentUsers": item.assigned_users,
          "activeUsers": $scope.activeUsers,
          "onClose": onClose,
          "lbTitle": $translate.instant("COMMON.ASSIGNED_USERS.ADD")
        });
      };
      $el.on("click", ".user-list-single", function(event) {
        if (!isEditable()) {
          return;
        }
        event.stopPropagation();
        return $scope.openAssignedUsers();
      });
      $el.on("click", ".remove-user", function(event) {
        var assignedUserId, message, target, title;
        if (!isEditable()) {
          return;
        }
        event.stopPropagation();
        target = angular.element(event.currentTarget);
        assignedUserId = target.data("user-id");
        title = $translate.instant("COMMON.ASSIGNED_USERS.TITLE_LIGHTBOX_DELETE_ASSIGNED");
        message = $scope.usersById[assignedUserId].full_name_display;
        return $confirm.askOnDelete(title, message).then(function(askResponse) {
          var assignedUserIds;
          askResponse.finish();
          assignedUserIds = _.clone($model.$modelValue.assigned_users, false);
          assignedUserIds = _.pull(assignedUserIds, assignedUserId);
          return deleteAssignedUser(assignedUserIds);
        });
      });
      $scope.selfAssign = function() {
        var assignedUsers;
        if (!isEditable()) {
          return;
        }
        assignedUsers = _.clone($model.$modelValue.assigned_users, false);
        assignedUsers.push(currentUserId);
        assignedUsers = _.uniq(assignedUsers);
        return save(assignedUsers, currentUserId);
      };
      deleteAssignedUser = function(assignedUserIds) {
        var transform;
        $scope.loading = true;
        transform = $modelTransform.save(function(item) {
          var ref1;
          item.assigned_users = assignedUserIds;
          if ((ref1 = item.assigned_to, indexOf.call(assignedUserIds, ref1) < 0) && assignedUserIds.length > 0) {
            item.assigned_to = assignedUserIds[0];
          }
          if (assignedUserIds.length === 0) {
            item.assigned_to = null;
          }
          return item;
        });
        transform.then(function() {
          var item;
          item = $modelTransform.getObj();
          $attrs.ngModel = item;
          return $rootscope.$broadcast("object:updated");
        });
        transform.then(null, function() {
          item.revert();
          return $confirm.notify("error");
        });
        return transform["finally"](function() {
          return $scope.loading = false;
        });
      };
      render = function(assignedUserIds) {
        var assignedUsers;
        assignedUsers = _.map(assignedUserIds, function(assignedUserId) {
          return $scope.usersById[assignedUserId];
        });
        $scope.assignedUsers = _.compact(assignedUsers);
        $scope.selfAssigned = _.includes(assignedUserIds, currentUserId);
        return $scope.isEditable = isEditable();
      };
      $scope.$on("assigned-user:deleted", function(ctx, assignedUserId) {
        var assignedUsersIds;
        assignedUsersIds = _.clone($model.$modelValue.assigned_users, false);
        assignedUsersIds = _.pull(assignedUsersIds, assignedUserId);
        assignedUsersIds = _.uniq(assignedUsersIds);
        return deleteAssignedUser(assignedUsersIds);
      });
      $scope.$on("assigned-user:added", function(ctx, assignedUserId) {
        var assignedUsers;
        assignedUsers = _.clone($model.$modelValue.assigned_users, false);
        assignedUsers.push(assignedUserId);
        assignedUsers = _.uniq(assignedUsers);
        return save(assignedUsers, assignedUserId);
      });
      $scope.$watch($attrs.ngModel, function(item, currentItem) {
        if (item == null) {
          return;
        }
        return render(item.assigned_users);
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      scope: true,
      templateUrl: "components/ticket-assigned/assigned-users.html",
      link: link,
      require: "ngModel"
    };
  };

  angular.module('taigaComponents').directive("tgAssignedUsers", ["$rootScope", "$tgConfirm", "$tgRepo", "$tgQueueModelTransformation", "$tgTemplate", "$compile", "$translate", "tgCurrentUserService", "tgLightboxFactory", AssignedUsersDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/watch-button/watch-button.controller.coffee
 */

(function() {
  var TicketWatchersController;

  TicketWatchersController = (function() {
    TicketWatchersController.$inject = ["tgCurrentUserService", "$rootScope", "tgLightboxFactory", "$translate", "$tgQueueModelTransformation"];

    function TicketWatchersController(currentUserService, rootScope, lightboxFactory, translate, modelTransform) {
      this.currentUserService = currentUserService;
      this.rootScope = rootScope;
      this.lightboxFactory = lightboxFactory;
      this.translate = translate;
      this.modelTransform = modelTransform;
      this.user = this.currentUserService.getUser();
      this.loading = false;
    }

    TicketWatchersController.prototype.openWatchers = function() {
      var onClose;
      onClose = (function(_this) {
        return function(watchersIds) {
          return _this.save(watchersIds);
        };
      })(this);
      return this.lightboxFactory.create('tg-lb-select-user', {
        "class": "lightbox lightbox-select-user"
      }, {
        "currentUsers": this.item.watchers,
        "activeUsers": this.activeUsers,
        "onClose": onClose,
        "lbTitle": this.translate.instant("COMMON.WATCHERS.ADD")
      });
    };

    TicketWatchersController.prototype.getPerms = function() {
      var name, perms;
      if (!this.item) {
        return "";
      }
      name = this.item._name;
      perms = {
        userstories: 'modify_us',
        issues: 'modify_issue',
        tasks: 'modify_task',
        epics: 'modify_epic'
      };
      return perms[name];
    };

    TicketWatchersController.prototype.watch = function() {
      var promise;
      this.loading = true;
      promise = this._watch();
      promise["finally"]((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
      return promise;
    };

    TicketWatchersController.prototype.unwatch = function() {
      var promise;
      this.loading = true;
      promise = this._unwatch();
      promise["finally"]((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
      return promise;
    };

    TicketWatchersController.prototype.deleteWatcher = function(watcherId) {
      var watchersIds;
      watchersIds = _.filter(this.item.watchers, (function(_this) {
        return function(x) {
          return x !== watcherId;
        };
      })(this));
      return this.save(watchersIds);
    };

    TicketWatchersController.prototype.save = function(watchersIds) {
      var transform;
      this.loading = true;
      transform = this.modelTransform.save(function(item) {
        item.watchers = watchersIds;
        return item;
      });
      transform.then((function(_this) {
        return function() {
          return _this.rootScope.$broadcast("object:updated");
        };
      })(this));
      return transform["finally"]((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
    };

    TicketWatchersController.prototype._watch = function() {
      return this.onWatch();
    };

    TicketWatchersController.prototype._unwatch = function() {
      return this.onUnwatch();
    };

    return TicketWatchersController;

  })();

  angular.module("taigaComponents").controller("TicketWatchersController", TicketWatchersController);

}).call(this);


/*
 * Copyright (C) 2014-2019 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/ticket-watchers/ticket-watchers.directive.coffee
 */

(function() {
  var WatchersDirective;

  WatchersDirective = function($rootscope, $confirm, $repo, $modelTransform, $template, $compile, $translate, $currentUserService) {
    var link;
    link = function($scope, $el, $attrs) {
      var isEditable, render;
      $scope.visibleWatchersCount = 4;
      $scope.displayHidden = false;
      $scope.isAuthenticated = !!$currentUserService.getUser();
      isEditable = function() {
        var ref, ref1;
        return ((ref = $scope.project) != null ? (ref1 = ref.my_permissions) != null ? ref1.indexOf($attrs.requiredPerm) : void 0 : void 0) !== -1;
      };
      render = function() {
        var ref, watchers, watchersIds;
        watchersIds = _.clone((ref = $scope.vm.item) != null ? ref.watchers : void 0, false);
        watchers = _.map(watchersIds, function(watcherId) {
          return $scope.usersById[watcherId];
        });
        watchers = _.filter(watchers, function(it) {
          return !!it;
        });
        $scope.vm.watchers = _.compact(watchers);
        return $scope.isEditable = isEditable();
      };
      $scope.toggleFold = function() {
        return $scope.displayHidden = !$scope.displayHidden;
      };
      $el.on("click", ".user-list-single", function(event) {
        if (!isEditable()) {
          return;
        }
        event.stopPropagation();
        return $scope.vm.openWatchers();
      });
      $el.on("click", ".remove-user", function(event) {
        var message, target, title, watcherId;
        if (!isEditable()) {
          return;
        }
        event.stopPropagation();
        target = angular.element(event.currentTarget);
        watcherId = target.data("watcher-id");
        title = $translate.instant("COMMON.WATCHERS.TITLE_LIGHTBOX_DELETE_WARTCHER");
        message = $scope.usersById[watcherId].full_name_display;
        return $confirm.askOnDelete(title, message).then((function(_this) {
          return function(askResponse) {
            askResponse.finish();
            return $scope.vm.deleteWatcher(watcherId);
          };
        })(this));
      });
      $scope.$on("watcher:added", function(ctx, watcherId) {
        var watchersIds;
        watchersIds = _.clone($scope.item.watchers, false);
        watchersIds.push(watcherId);
        watchersIds = _.uniq(watchers);
        return $scope.vm.save(watchersIds);
      });
      $scope.$on("watchers:selected", function(ctx, watchersIds) {
        return $scope.vm.save(watchersIds);
      });
      $scope.$watch("vm.item", function(item) {
        if (!item) {
          return;
        }
        return render();
      });
      return $scope.$on("$destroy", function() {
        return $el.off();
      });
    };
    return {
      scope: true,
      controller: "TicketWatchersController",
      bindToController: {
        item: "=",
        onWatch: "=",
        onUnwatch: "=",
        activeUsers: "="
      },
      controllerAs: "vm",
      templateUrl: "components/ticket-watchers/ticket-watchers.html",
      link: link
    };
  };

  WatchersDirective.$inject = ["$rootScope", "$tgConfirm", "$tgRepo", "$tgQueueModelTransformation", "$tgTemplate", "$compile", "$translate", "tgCurrentUserService"];

  angular.module("taigaComponents").directive("tgWatchers", WatchersDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/tips/tips.directive.coffee
 */

(function() {
  var module, timeout, tipsDirective;

  timeout = this.taiga.timeout;

  module = angular.module("taigaComponents");

  tipsDirective = function(tgLoader, $translate) {
    var link, randomInt, tips;
    tips = [
      {
        contentType: "icon",
        icon: "icon-project",
        message: "PROJECTS_ORDER"
      }, {
        contentType: "icon",
        icon: "icon-upvote",
        message: "VOTING"
      }, {
        contentType: "icon",
        icon: "icon-attach",
        message: "ISSUES_TO_SPRINT"
      }, {
        contentType: "icon",
        icon: "icon-clock",
        message: "DUE_DATE"
      }, {
        contentType: "icon",
        icon: "icon-iocaine",
        message: "IOCAIN"
      }, {
        contentType: "icon",
        icon: "icon-blocked-project",
        message: "BLOCKED"
      }, {
        contentType: "icon",
        icon: "icon-promote",
        message: "PROMOTE"
      }, {
        contentType: "icon",
        icon: "icon-bulk",
        message: "BULK"
      }, {
        contentType: "range",
        message: "ZOOM"
      }, {
        contentType: "icon",
        icon: "icon-settings",
        message: "CUSTOM_FIELDS"
      }, {
        contentType: "arrows",
        message: "SLIDE_ARROWS"
      }
    ];
    randomInt = function(size) {
      return Math.floor(Math.random() * size) + 1;
    };
    link = function(scope, el, attrs) {
      var loadTip, waitingTimeout;
      scope.tipLoaded = false;
      waitingTimeout = null;
      tgLoader.onStart(function() {
        return waitingTimeout = timeout(1000, function() {
          return loadTip();
        });
      });
      tgLoader.onEnd(function() {
        clearTimeout(waitingTimeout);
        return scope.tipLoaded = false;
      });
      return loadTip = function() {
        var tip;
        scope.tipLoaded = true;
        tip = tips[randomInt(tips.length - 1)];
        return scope.tip = {
          contentType: tip.contentType,
          message: "TIPS.TIP_" + tip.message,
          icon: tip.icon,
          color: "tip-color-" + (randomInt(5))
        };
      };
    };
    return {
      link: link,
      scope: true,
      templateUrl: "components/tips/tip.html"
    };
  };

  module.directive('tgTips', ['tgLoader', '$translate', tipsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/tribe-button/tribe-button.directive.coffee
 */

(function() {
  var TribeButtonDirective;

  TribeButtonDirective = function(configService, locationService) {
    var link;
    link = function(scope, el, attrs) {
      scope.vm = {};
      scope.vm.tribeHost = configService.config.tribeHost;
      scope.vm.url = (locationService.protocol()) + "://" + (locationService.host());
      if (locationService.protocol() === "http" && locationService.port() !== 80) {
        return scope.vm.url = scope.vm.url + ":" + (locationService.port());
      } else if (locationService.protocol() === "https" && locationService.port() !== 443) {
        return scope.vm.url = scope.vm.url + ":" + (locationService.port());
      }
    };
    return {
      scope: {
        usId: "=",
        projectSlug: "="
      },
      controllerAs: "vm",
      templateUrl: "components/tribe-button/tribe-button.html",
      link: link
    };
  };

  TribeButtonDirective.$inject = ["$tgConfig", "$tgLocation"];

  angular.module("taigaComponents").directive("tgTribeButton", TribeButtonDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/tribe-button/tribe-linked.directive.coffee
 */

(function() {
  var TribeLinkedDirective;

  TribeLinkedDirective = function(configService) {
    var directive, link;
    link = function(scope, el, attrs) {
      scope.vm = {};
      scope.vm.tribeHost = configService.config.tribeHost;
      scope.vm.show = function() {
        return scope.vm.open = true;
      };
      return scope.vm.hide = function(event) {
        return scope.vm.open = false;
      };
    };
    directive = {
      templateUrl: "components/tribe-button/tribe-linked.html",
      scope: {
        gigTitle: "=",
        gigId: "="
      },
      link: link
    };
    return directive;
  };

  TribeLinkedDirective.$inject = ["$tgConfig"];

  angular.module("taigaComponents").directive("tgTribeLinked", TribeLinkedDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/vote-button/vote-button.controller.coffee
 */

(function() {
  var VoteButtonController;

  VoteButtonController = (function() {
    VoteButtonController.$inject = ["tgCurrentUserService"];

    function VoteButtonController(currentUserService) {
      this.currentUserService = currentUserService;
      this.user = this.currentUserService.getUser();
      this.loading = false;
    }

    VoteButtonController.prototype.toggleVote = function() {
      var promise;
      this.loading = true;
      if (!this.item.is_voter) {
        promise = this.onUpvote();
      } else {
        promise = this.onDownvote();
      }
      promise["finally"]((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
      return promise;
    };

    return VoteButtonController;

  })();

  angular.module("taigaComponents").controller("VoteButton", VoteButtonController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/vote-button/vote-button.directive.coffee
 */

(function() {
  var VoteButtonDirective;

  VoteButtonDirective = function() {
    return {
      scope: {},
      controller: "VoteButton",
      bindToController: {
        item: "=",
        onUpvote: "=",
        onDownvote: "="
      },
      controllerAs: "vm",
      templateUrl: "components/vote-button/vote-button.html"
    };
  };

  angular.module("taigaComponents").directive("tgVoteButton", VoteButtonDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/comment-edit-wysiwyg.directive.coffee
 */

(function() {
  var CommentEditWysiwyg;

  CommentEditWysiwyg = function(attachmentsFullService) {
    var link;
    link = function($scope, $el, $attrs) {
      var types, uploadFile;
      types = {
        epics: "epic",
        userstories: "us",
        issues: "issue",
        tasks: "task"
      };
      uploadFile = function(file, cb) {
        return attachmentsFullService.addAttachment($scope.vm.projectId, $scope.vm.comment.comment.id, types[$scope.vm.comment.comment._name], file, true, true).then(function(result) {
          return cb(result.getIn(['file', 'name']), result.getIn(['file', 'url']), types[$scope.vm.comment.comment._name], result.getIn(['file', 'id']));
        });
      };
      return $scope.uploadFiles = function(files, cb) {
        var file, i, len, results;
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(uploadFile(file, cb));
        }
        return results;
      };
    };
    return {
      scope: true,
      link: link,
      template: "<div>\n    <tg-wysiwyg\n        editonly\n        required\n        content='vm.comment.comment'\n        on-save=\"vm.saveComment(text, cb)\"\n        on-cancel=\"vm.onEditMode({commentId: vm.comment.id})\"\n        on-upload-file='uploadFiles(files, cb)'>\n    </tg-wysiwyg>\n</div>"
    };
  };

  angular.module("taigaComponents").directive("tgCommentEditWysiwyg", ["tgAttachmentsFullService", CommentEditWysiwyg]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/comment-wysiwyg.directive.coffee
 */

(function() {
  var CommentWysiwyg;

  CommentWysiwyg = function($modelTransform, $rootscope, attachmentsFullService) {
    var link;
    link = function($scope, $el, $attrs) {
      var types, uploadFile;
      $scope.editableDescription = false;
      $scope.saveComment = function(description, cb) {
        var transform;
        $scope.content = '';
        $scope.vm.type.comment = description;
        transform = $modelTransform.save(function(item) {});
        transform.then(function() {
          if ($scope.vm.onAddComment) {
            $scope.vm.onAddComment();
          }
          return $rootscope.$broadcast("object:updated");
        });
        return transform["finally"](cb);
      };
      types = {
        epics: "epic",
        userstories: "us",
        issues: "issue",
        tasks: "task"
      };
      uploadFile = function(file, cb) {
        return attachmentsFullService.addAttachment($scope.vm.projectId, $scope.vm.type.id, types[$scope.vm.type._name], file, true, true).then(function(result) {
          return cb(result.getIn(['file', 'name']), result.getIn(['file', 'url']), types[$scope.vm.type._name], result.getIn(['file', 'id']));
        });
      };
      $scope.onChange = function(markdown) {
        return $scope.vm.type.comment = markdown;
      };
      $scope.uploadFiles = function(files, cb) {
        var file, i, len, results;
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(uploadFile(file, cb));
        }
        return results;
      };
      $scope.content = '';
      return $scope.$watch("vm.type", function(value) {
        if (!value) {
          return;
        }
        return $scope.storageKey = "comment-" + value.project + "-" + value.id + "-" + value._name;
      });
    };
    return {
      scope: true,
      link: link,
      template: "<div>\n    <tg-wysiwyg\n        required\n        not-persist\n        placeholder='{{\"COMMENTS.TYPE_NEW_COMMENT\" | translate}}'\n        storage-key='storageKey'\n        content='content'\n        on-save='saveComment(text, cb)'\n        on-upload-file='uploadFiles(files, cb)'>\n    </tg-wysiwyg>\n</div>"
    };
  };

  angular.module("taigaComponents").directive("tgCommentWysiwyg", ["$tgQueueModelTransformation", "$rootScope", "tgAttachmentsFullService", CommentWysiwyg]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/custom-field-edit-wysiwyg.directive.coffee
 */

(function() {
  var CustomFieldEditWysiwyg;

  CustomFieldEditWysiwyg = function(attachmentsFullService) {
    var link;
    link = function($scope, $el, $attrs) {
      var types, uploadFile;
      types = {
        userstories: "us",
        issues: "issue",
        tasks: "task"
      };
      uploadFile = function(file, cb) {
        return attachmentsFullService.addAttachment($scope.vm.projectId, $scope.vm.comment.comment.id, types[$scope.vm.comment.comment._name], file).then(function(result) {
          return cb(result.getIn(['file', 'name']), result.getIn(['file', 'url']), types[$scope.vm.comment.comment._name], result.getIn(['file', 'id']));
        });
      };
      return $scope.uploadFiles = function(files, cb) {
        var file, i, len, results;
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(uploadFile(file, cb));
        }
        return results;
      };
    };
    return {
      scope: true,
      link: link,
      template: "<div>\n    <tg-wysiwyg\n        editonly\n        content='customAttributeValue.value'\n        on-save=\"saveCustomRichText(text, cb)\"\n        on-cancel=\"cancelCustomRichText()\"\n        on-upload-file='uploadFiles(files, cb)'>\n    </tg-wysiwyg>\n</div>"
    };
  };

  angular.module("taigaComponents").directive("tgCustomFieldEditWysiwyg", ["tgAttachmentsFullService", CustomFieldEditWysiwyg]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/item-wysiwyg.directive.coffee
 */

(function() {
  var ItemWysiwyg;

  ItemWysiwyg = function($modelTransform, $rootscope, $confirm, attachmentsFullService, $translate) {
    var link;
    link = function($scope, $el, $attrs) {
      var uploadFile;
      $scope.editableDescription = false;
      $scope.saveDescription = function(description, cb) {
        var transform;
        transform = $modelTransform.save(function(item) {
          item.description = description;
          return item;
        });
        transform.then(function() {
          $confirm.notify("success");
          return $rootscope.$broadcast("object:updated");
        });
        transform.then(null, function() {
          return $confirm.notify("error");
        });
        return transform["finally"](cb);
      };
      uploadFile = function(file, cb) {
        return attachmentsFullService.addAttachment($scope.project.id, $scope.item.id, $attrs.type, file).then(function(result) {
          return cb(result.getIn(['file', 'name']), result.getIn(['file', 'url']), $attrs.type, result.getIn(['file', 'id']));
        });
      };
      $scope.uploadFiles = function(files, cb) {
        var file, i, len, results;
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          results.push(uploadFile(file, cb));
        }
        return results;
      };
      $scope.$watch($attrs.model, function(value) {
        if (!value) {
          return;
        }
        $scope.item = value;
        $scope.version = value.version;
        return $scope.storageKey = $scope.project.id + "-" + value.id + "-" + $attrs.type;
      });
      return $scope.$watch('project', function(project) {
        if (!project) {
          return;
        }
        return $scope.editableDescription = project.my_permissions.indexOf($attrs.requiredPerm) !== -1;
      });
    };
    return {
      scope: true,
      link: link,
      template: "<div>\n    <tg-wysiwyg\n        ng-if=\"editableDescription\"\n        placeholder='{{\"COMMON.DESCRIPTION.EMPTY\" | translate}}'\n        version='version'\n        storage-key='storageKey'\n        content='item.description'\n        on-save='saveDescription(text, cb)'\n        on-upload-file='uploadFiles(files, cb)'>\n    </tg-wysiwyg>\n\n    <div\n        class=\"wysiwyg\"\n        ng-if=\"!editableDescription && item.description.length\"\n        ng-bind-html=\"item.description | markdownToHTML\"></div>\n\n    <div\n        class=\"wysiwyg\"\n        ng-if=\"!editableDescription && !item.description.length\">\n        {{'COMMON.DESCRIPTION.NO_DESCRIPTION' | translate}}\n    </div>\n</div>"
    };
  };

  angular.module("taigaComponents").directive("tgItemWysiwyg", ["$tgQueueModelTransformation", "$rootScope", "$tgConfirm", "tgAttachmentsFullService", "$translate", ItemWysiwyg]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/wysiwyg-code-hightlighter.service.coffee
 */

(function() {
  var WysiwygCodeHightlighterService;

  WysiwygCodeHightlighterService = (function() {
    function WysiwygCodeHightlighterService() {
      Prism.plugins.customClass.prefix('prism-');
      Prism.plugins.customClass.map({});
    }

    WysiwygCodeHightlighterService.prototype.getLanguages = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this.languages) {
            return resolve(_this.languages);
          } else if (_this.loadPromise) {
            return _this.loadPromise.then(function() {
              return resolve(_this.languages);
            });
          } else {
            return _this.loadPromise = $.getJSON("/" + window._version + "/prism/prism-languages.json").then(function(_languages_) {
              _this.loadPromise = null;
              _this.languages = _.map(_languages_, function(it) {
                it.url = ("/" + window._version + "/prism/") + it.file;
                return it;
              });
              return resolve(_this.languages);
            });
          }
        };
      })(this));
    };

    WysiwygCodeHightlighterService.prototype.getLanguageInClassList = function(classes) {
      var lan;
      lan = _.find(this.languages, function(it) {
        return !!_.find(classes, function(className) {
          return 'language-' + it.name === className;
        });
      });
      if (lan) {
        return lan.name;
      } else {
        return null;
      }
    };

    WysiwygCodeHightlighterService.prototype.loadLanguage = function(lan) {
      return new Promise(function(resolve) {
        if (!Prism.languages[lan]) {
          return ljs.load("/" + window._version + "/prism/prism-" + lan + ".min.js", resolve);
        } else {
          return resolve();
        }
      });
    };

    WysiwygCodeHightlighterService.prototype.replaceCodeBrToNl = function(code) {
      return $(code).find('br').replaceWith('\n');
    };

    WysiwygCodeHightlighterService.prototype.hightlightCode = function(code) {
      var lan;
      this.replaceCodeBrToNl(code);
      lan = this.getLanguageInClassList(code.classList);
      if (lan) {
        return this.loadLanguage(lan).then(function() {
          return Prism.highlightElement(code);
        });
      }
    };

    WysiwygCodeHightlighterService.prototype.addHightlighter = function(element) {
      var codes;
      codes = $(element).find('code');
      return codes.each((function(_this) {
        return function(index, code) {
          return _this.hightlightCode(code);
        };
      })(this));
    };

    return WysiwygCodeHightlighterService;

  })();

  angular.module("taigaComponents").service("tgWysiwygCodeHightlighterService", WysiwygCodeHightlighterService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/wysiwyg-code-lightbox/wysiwyg-code-lightbox.directive.coffee
 */

(function() {
  var WysiwygCodeLightbox;

  WysiwygCodeLightbox = function(lightboxService) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return scope.$watch('visible', function(visible) {
        if (visible && !el.hasClass('open')) {
          scope.open = true;
          lightboxService.open(el, null, scope.onClose);
          return scope.$applyAsync(function() {
            var textarea;
            textarea = el[0].querySelector('textarea');
            if (textarea) {
              return textarea.select();
            }
          });
        } else if (!visible && el.hasClass('open')) {
          scope.open = false;
          return lightboxService.close(el);
        }
      });
    };
    return {
      scope: {
        languages: '<',
        codeLanguage: '<',
        code: '<',
        visible: '<',
        onClose: '&',
        onSave: '&'
      },
      link: link,
      templateUrl: "components/wysiwyg/wysiwyg-code-lightbox/wysiwyg-code-lightbox.html"
    };
  };

  angular.module("taigaComponents").directive("tgWysiwygCodeLightbox", ["lightboxService", WysiwygCodeLightbox]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/wysiwyg-mention.service.coffee
 */

(function() {
  var WysiwygMentionService;

  WysiwygMentionService = (function() {
    WysiwygMentionService.$inject = ["tgProjectService", "tgWysiwygService", "$tgNavUrls", "$tgResources"];

    function WysiwygMentionService(projectService, wysiwygService, navurls, rs) {
      this.projectService = projectService;
      this.wysiwygService = wysiwygService;
      this.navurls = navurls;
      this.rs = rs;
      this.cancelablePromise = null;
      this.projectSlug = this.projectService.project.get('slug');
    }

    WysiwygMentionService.prototype.search = function(mention) {
      return new Promise((function(_this) {
        return function(resolve) {
          if ('#'.indexOf(mention[0]) !== -1) {
            return _this.searchItem(mention.replace('#', '')).then(resolve);
          } else if ('@'.indexOf(mention[0]) !== -1) {
            return _this.searchUser(mention.replace('@', ''), resolve);
          } else if (':'.indexOf(mention[0]) !== -1) {
            return _this.searchEmoji(mention.replace(':', ''), resolve);
          }
        };
      })(this));
    };

    WysiwygMentionService.prototype.searchItem = function(term) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var filter;
          term = taiga.slugify(term);
          filter = function(item) {
            return ['subject', 'ref'].some(function(attr) {
              return taiga.slugify(item[attr]).indexOf(term) >= 0;
            });
          };
          return _this.rs.search["do"](_this.projectService.project.get('id'), term).then(function(res) {
            var i, items, len, ref, result, type, typeURLs;
            result = [];
            if (!res.count || res.count === res.wikipages.length) {
              return resolve(result);
            } else {
              typeURLs = {
                issues: 'project-issues-detail',
                userstories: 'project-userstories-detail',
                tasks: 'project-tasks-detail'
              };
              ref = ['issues', 'tasks', 'userstories'];
              for (i = 0, len = ref.length; i < len; i++) {
                type = ref[i];
                if (!res[type]) {
                  continue;
                }
                items = res[type].filter(filter).map(function(item) {
                  item.url = _this.navurls.resolve(typeURLs[type], {
                    project: _this.projectSlug,
                    ref: item.ref
                  });
                  return item;
                });
                result = result.concat(items);
              }
              return resolve(_.sortBy(result, ["ref"]).slice(0, 10));
            }
          });
        };
      })(this));
    };

    WysiwygMentionService.prototype.searchUser = function(term, callback) {
      var users;
      users = this.projectService.project.toJS().members.filter(function(user) {
        return ['username', 'full_name', 'full_name_display'].some(function(attr) {
          return taiga.slugify(user[attr]).indexOf(term) >= 0 || user[attr].indexOf(term) >= 0;
        });
      });
      users = users.slice(0, 10).map((function(_this) {
        return function(item) {
          item.url = _this.navurls.resolve('user-profile', {
            project: _this.projectSlug,
            username: item.username
          });
          return item;
        };
      })(this));
      return callback(users);
    };

    WysiwygMentionService.prototype.searchEmoji = function(name, callback) {
      var filteredEmojis;
      filteredEmojis = this.wysiwygService.searchEmojiByName(name);
      filteredEmojis = filteredEmojis.slice(0, 10);
      return callback(filteredEmojis);
    };

    return WysiwygMentionService;

  })();

  angular.module("taigaComponents").service("tgWysiwygMentionService", WysiwygMentionService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/wysiwyg.directive.coffee
 */

(function() {
  var Medium, bindOnce, taiga;

  taiga = this.taiga;

  bindOnce = this.taiga.bindOnce;

  Medium = function($translate, $confirm, $storage, wysiwygService, animationFrame, tgLoader, wysiwygCodeHightlighterService, wysiwygMentionService, analytics, $location) {
    var AlignRightButton, CodeButton, CustomPasteHandler, addCodeBlockAndHightlight, getIcon, getRangeCodeBlock, isCodeBlockSelected, link, oldIsBlockContainer, refreshCodeBlocks, removeCodeBlockAndHightlight, removeSelections;
    removeSelections = function() {
      if (window.getSelection) {
        if (window.getSelection().empty) {
          return window.getSelection().empty();
        }
      } else if (window.getSelection().removeAllRanges) {
        return window.getSelection().removeAllRanges();
      } else if (document.selection) {
        return document.selection.empty();
      }
    };
    getRangeCodeBlock = function(range) {
      return $(range.endContainer).parentsUntil('.editor', 'code');
    };
    isCodeBlockSelected = function(range) {
      return !!getRangeCodeBlock(range).length;
    };
    removeCodeBlockAndHightlight = function(selection, mediumInstance) {
      var code, p, pre;
      if ($(selection).is('code')) {
        code = selection;
      } else {
        code = $(selection).closest('code')[0];
      }
      pre = code.parentNode;
      p = document.createElement('p');
      p.innerText = code.innerText;
      pre.parentNode.replaceChild(p, pre);
      return mediumInstance.checkContentChanged(mediumInstance.elements[0]);
    };
    addCodeBlockAndHightlight = function(range, mediumInstance) {
      var code, extract, pre, start;
      pre = document.createElement('pre');
      code = document.createElement('code');
      if (!range.startContainer.parentNode.nextSibling) {
        $('<br/>').insertAfter(range.startContainer.parentNode);
      }
      start = range.endContainer.parentNode.nextSibling;
      extract = range.extractContents();
      code.appendChild(extract);
      pre.appendChild(code);
      start.parentNode.insertBefore(pre, start);
      refreshCodeBlocks(mediumInstance);
      return mediumInstance.checkContentChanged(mediumInstance.elements[0]);
    };
    refreshCodeBlocks = function(mediumInstance) {
      var i, j, len, len1, mainChildren, p, pre, preList, ref, results;
      if (!mediumInstance) {
        return;
      }
      ref = mediumInstance.elements[0].children;
      for (i = 0, len = ref.length; i < len; i++) {
        mainChildren = ref[i];
        if (mainChildren && mainChildren.tagName.toLowerCase() === 'p' && !mainChildren.innerHTML.trim().length) {
          mainChildren.parentNode.removeChild(mainChildren);
        }
      }
      preList = mediumInstance.elements[0].querySelectorAll('pre');
      results = [];
      for (j = 0, len1 = preList.length; j < len1; j++) {
        pre = preList[j];
        pre.setAttribute('contenteditable', false);
        pre.setAttribute('title', $translate.instant("COMMON.WYSIWYG.DB_CLICK"));
        pre.addEventListener('mousedown', function(e) {
          return e.preventDefault();
        });
        if (pre.nextElementSibling && pre.nextElementSibling.nodeName.toLowerCase() === 'p' && !pre.nextElementSibling.children.length) {
          results.push(pre.nextElementSibling.appendChild(document.createElement('br')));
        } else if (!pre.nextElementSibling || ['p', 'ul', 'h1', 'h2', 'h3'].indexOf(pre.nextElementSibling.nodeName.toLowerCase()) === -1) {
          p = document.createElement('p');
          p.appendChild(document.createElement('br'));
          results.push(pre.parentNode.insertBefore(p, pre.nextSibling));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    AlignRightButton = MediumEditor.extensions.button.extend({
      name: 'rtl',
      init: function() {
        var option;
        option = _.find(this.base.options.toolbar.buttons, function(it) {
          return it.name === 'rtl';
        });
        this.button = this.document.createElement('button');
        this.button.classList.add('medium-editor-action');
        this.button.innerHTML = option.contentDefault || '<b>RTL</b>';
        this.button.title = 'RTL';
        return this.on(this.button, 'click', this.handleClick.bind(this));
      },
      getButton: function() {
        return this.button;
      },
      handleClick: function(event) {
        var range;
        range = MediumEditor.selection.getSelectionRange(document);
        if (range.commonAncestorContainer.parentNode.style.textAlign === 'right') {
          return document.execCommand('justifyLeft', false);
        } else {
          return document.execCommand('justifyRight', false);
        }
      }
    });
    getIcon = function(icon) {
      return "<svg class=\"icon icon-" + icon + "\">\n    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#" + icon + "\"></use>\n</svg>";
    };
    CodeButton = MediumEditor.extensions.button.extend({
      name: 'code',
      init: function() {
        var option;
        option = _.find(this.base.options.toolbar.buttons, function(it) {
          return it.name === 'code';
        });
        this.button = this.document.createElement('button');
        this.button.classList.add('medium-editor-action');
        this.button.innerHTML = option.contentDefault || '<b>Code</b>';
        this.button.title = 'Code';
        return this.on(this.button, 'click', this.handleClick.bind(this));
      },
      getButton: function() {
        return this.button;
      },
      tagNames: ['code'],
      handleClick: function(event) {
        var range, toolbar;
        range = MediumEditor.selection.getSelectionRange(self.document);
        if (isCodeBlockSelected(range, this.base)) {
          removeCodeBlockAndHightlight(range.endContainer, this.base);
        } else {
          addCodeBlockAndHightlight(range, this.base);
          removeSelections();
        }
        toolbar = this.base.getExtensionByName('toolbar');
        if (toolbar) {
          return toolbar.hideToolbar();
        }
      }
    });
    CustomPasteHandler = MediumEditor.extensions.paste.extend({
      doPaste: function(pastedHTML, pastedPlain, editable) {
        var html;
        html = MediumEditor.util.htmlEntities(pastedPlain);
        return MediumEditor.util.insertHTMLCommand(this.document, html);
      }
    });
    oldIsBlockContainer = MediumEditor.util.isBlockContainer;
    MediumEditor.util.isBlockContainer = function(element) {
      var tagName;
      if (!element) {
        return oldIsBlockContainer(element);
      }
      if (element.tagName) {
        tagName = element.tagName;
      } else {
        tagName = element.parentNode.tagName;
      }
      if (tagName.toLowerCase() === 'code') {
        return true;
      }
      return oldIsBlockContainer(element);
    };
    link = function($scope, $el, $attrs) {
      var change, clean, codeBlockSelected, create, discardLocalStorage, editorMarkdown, editorMedium, getCurrentContent, isDraft, isEditOnly, isOutdated, localSave, mediumInstance, notPersist, replaceCodeBrToNl, saveEnd, setEditMode, setHtmlMedium, throttleChange, unwatch, updateMarkdownWithCurrentHtml, uploadEnd, uploadEndMarkdown;
      mediumInstance = null;
      editorMedium = $el.find('.medium');
      editorMarkdown = $el.find('.markdown');
      codeBlockSelected = null;
      isEditOnly = !!$attrs.$attr.editonly;
      notPersist = !!$attrs.$attr.notPersist;
      $scope.required = !!$attrs.$attr.required;
      $scope.editMode = isEditOnly || false;
      $scope.mode = $storage.get('editor-mode', 'html');
      $scope.markdown = '';
      $scope.codeEditorVisible = false;
      $scope.codeLans = [];
      wysiwygCodeHightlighterService.getLanguages().then(function(codeLans) {
        return $scope.codeLans = codeLans;
      });
      setEditMode = function(editMode) {
        return $scope.editMode = editMode;
      };
      setHtmlMedium = function(markdown) {
        var html;
        html = wysiwygService.getHTML(markdown);
        editorMedium.html(html);
        wysiwygCodeHightlighterService.addHightlighter(mediumInstance.elements[0]);
        if ($scope.editMode) {
          return refreshCodeBlocks(mediumInstance);
        }
      };
      $scope.saveSnippet = function(lan, code) {
        var codePre;
        $scope.codeEditorVisible = false;
        codeBlockSelected.innerText = code;
        codePre = codeBlockSelected.parentNode;
        if (lan === 'remove-formating') {
          codeBlockSelected.className = '';
          codePre.className = '';
          removeCodeBlockAndHightlight(codeBlockSelected, mediumInstance);
        } else if (_.trim(code).length) {
          if (lan) {
            codeBlockSelected.className = 'language-' + lan;
            codePre.className = 'language-' + lan;
          } else {
            codeBlockSelected.className = '';
            codePre.className = '';
          }
          wysiwygCodeHightlighterService.hightlightCode(codeBlockSelected);
          mediumInstance.checkContentChanged(mediumInstance.elements[0]);
        } else {
          codeBlockSelected.parentNode.parentNode.removeChild(codeBlockSelected.parentNode);
          mediumInstance.checkContentChanged(mediumInstance.elements[0]);
        }
        throttleChange();
        return null;
      };
      $scope.setMode = function(mode) {
        $storage.set('editor-mode', mode);
        if (mode === 'markdown') {
          updateMarkdownWithCurrentHtml();
        } else {
          setHtmlMedium($scope.markdown);
        }
        $scope.mode = mode;
        return mediumInstance.trigger('editableBlur', {}, editorMedium[0]);
      };
      $scope.save = function(e) {
        if (e) {
          e.preventDefault();
        }
        if ($scope.mode === 'html') {
          updateMarkdownWithCurrentHtml();
        }
        setHtmlMedium($scope.markdown);
        if ($scope.required && !$scope.markdown.length) {
          return;
        }
        $scope.saving = true;
        $scope.outdated = false;
        $scope.onSave({
          text: $scope.markdown,
          cb: saveEnd
        });
      };
      $scope.cancel = function(e) {
        if (e) {
          e.preventDefault();
        }
        if (!isEditOnly) {
          setEditMode(false);
        }
        if (notPersist) {
          clean();
        } else if ($scope.mode === 'html') {
          setHtmlMedium($scope.content || null);
        }
        $scope.markdown = $scope.content;
        discardLocalStorage();
        mediumInstance.trigger('blur', {}, editorMedium[0]);
        $scope.outdated = false;
        refreshCodeBlocks(mediumInstance);
        $scope.onCancel();
      };
      clean = function() {
        $scope.markdown = '';
        return editorMedium.html('');
      };
      saveEnd = function() {
        $scope.saving = false;
        if (!isEditOnly) {
          setEditMode(false);
        }
        if (notPersist) {
          clean();
        }
        discardLocalStorage();
        mediumInstance.trigger('blur', {}, editorMedium[0]);
        return analytics.trackEvent('develop', 'save wysiwyg', $scope.mode, 1);
      };
      uploadEnd = function(name, url, type, id) {
        if (id == null) {
          id = null;
        }
        if (id) {
          url = url + "#_taiga-refresh=" + type + ":" + id;
        }
        if (taiga.isImage(name)) {
          return mediumInstance.pasteHTML("<img alt='" + name + "' src='" + url + "' title='" + name + "' /><br/>");
        } else {
          name = $('<div/>').text(name).html();
          return mediumInstance.pasteHTML("<a target='_blank' href='" + url + "'>" + name + "</a><br/>");
        }
      };
      uploadEndMarkdown = function(name, url, type, id) {
        if (id == null) {
          id = null;
        }
        if (id) {
          url = url + "#_taiga-refresh=" + type + ":" + id;
        }
        if (taiga.isImage(name)) {
          return $scope.markdown += "\n![" + name + "](" + url + " \"" + name + "\")\n";
        } else {
          return $scope.markdown += "\n[" + name + "](" + url + ")\n";
        }
      };
      isOutdated = function() {
        var store;
        store = $storage.get($scope.storageKey);
        if (store && store.version && store.version !== $scope.version) {
          return true;
        }
        return false;
      };
      isDraft = function() {
        var store;
        store = $storage.get($scope.storageKey);
        if (store) {
          return true;
        }
        return false;
      };
      getCurrentContent = function() {
        var store;
        store = $storage.get($scope.storageKey);
        if (store) {
          return store.text;
        }
        return $scope.content;
      };
      discardLocalStorage = function() {
        return $storage.remove($scope.storageKey);
      };
      $scope.cancelWithConfirmation = function() {
        var message, title;
        if ($scope.content === $scope.markdown) {
          $scope.cancel();
          if (document.activeElement.blur) {
            document.activeElement.blur();
          }
          document.body.click();
          return null;
        }
        title = $translate.instant("COMMON.CONFIRM_CLOSE_EDIT_MODE_TITLE");
        message = $translate.instant("COMMON.CONFIRM_CLOSE_EDIT_MODE_MESSAGE");
        return $confirm.ask(title, null, message).then(function(askResponse) {
          $scope.cancel();
          return askResponse.finish();
        });
      };
      replaceCodeBrToNl = function() {
        var html;
        html = $('<div></div>').html(editorMedium.html());
        html.find('code br').replaceWith('\n');
        return html.html();
      };
      updateMarkdownWithCurrentHtml = function() {
        var html;
        html = replaceCodeBrToNl();
        return $scope.markdown = wysiwygService.getMarkdown(html);
      };
      localSave = function(markdown) {
        var store;
        if ($scope.storageKey) {
          store = {};
          store.version = $scope.version || 0;
          store.text = markdown;
          return $storage.set($scope.storageKey, store);
        }
      };
      change = function() {
        if ($scope.mode === 'html') {
          updateMarkdownWithCurrentHtml();
        }
        localSave($scope.markdown);
        return $scope.onChange({
          markdown: $scope.markdown
        });
      };
      throttleChange = _.throttle(change, 200);
      create = function(text, editMode) {
        var html, promise;
        if (editMode == null) {
          editMode = false;
        }
        html = "";
        if (text.length) {
          html = wysiwygService.getHTML(text);
        }
        promise = wysiwygService.refreshAttachmentURL(html);
        return promise.then((function(_this) {
          return function(html) {
            editorMedium.html(html);
            mediumInstance = new MediumEditor(editorMedium[0], {
              imageDragging: false,
              placeholder: {
                text: $scope.placeholder
              },
              toolbar: {
                buttons: [
                  {
                    name: 'bold',
                    contentDefault: getIcon('editor-bold')
                  }, {
                    name: 'italic',
                    contentDefault: getIcon('editor-italic')
                  }, {
                    name: 'strikethrough',
                    contentDefault: getIcon('editor-cross-out')
                  }, {
                    name: 'anchor',
                    contentDefault: getIcon('editor-link')
                  }, {
                    name: 'image',
                    contentDefault: getIcon('editor-image')
                  }, {
                    name: 'orderedlist',
                    contentDefault: getIcon('editor-list-n')
                  }, {
                    name: 'unorderedlist',
                    contentDefault: getIcon('editor-list-o')
                  }, {
                    name: 'h1',
                    contentDefault: getIcon('editor-h1')
                  }, {
                    name: 'h2',
                    contentDefault: getIcon('editor-h2')
                  }, {
                    name: 'h3',
                    contentDefault: getIcon('editor-h3')
                  }, {
                    name: 'quote',
                    contentDefault: getIcon('editor-quote')
                  }, {
                    name: 'removeFormat',
                    contentDefault: getIcon('editor-no-format')
                  }, {
                    name: 'rtl',
                    contentDefault: getIcon('editor-rtl')
                  }, {
                    name: 'code',
                    contentDefault: getIcon('editor-code')
                  }
                ]
              },
              extensions: {
                paste: new CustomPasteHandler(),
                code: new CodeButton(),
                autolist: new AutoList(),
                alignright: new AlignRightButton(),
                mediumMention: new MentionExtension({
                  getItems: function(mention, mentionCb) {
                    return wysiwygMentionService.search(mention).then(mentionCb);
                  }
                })
              }
            });
            $scope.changeMarkdown = throttleChange;
            mediumInstance.subscribe('editableInput', function(e) {
              return $scope.$applyAsync(throttleChange);
            });
            mediumInstance.subscribe("editableClick", function(e) {
              var r;
              r = new RegExp('^(?:[a-z]+:)?//', 'i');
              if (e.target.href) {
                if (r.test(e.target.getAttribute('href')) || e.target.getAttribute('target') === '_blank') {
                  e.stopPropagation();
                  return window.open(e.target.href);
                } else {
                  return $location.url(e.target.href);
                }
              }
            });
            mediumInstance.subscribe('editableDrop', function(event) {
              return $scope.onUploadFile({
                files: event.dataTransfer.files,
                cb: uploadEnd
              });
            });
            mediumInstance.subscribe('editableKeydown', function(e) {
              var code, mention;
              code = e.keyCode ? e.keyCode : e.which;
              mention = $('.medium-mention');
              if ((code === 40 || code === 38) && mention.length) {
                e.stopPropagation();
                e.preventDefault();
                return;
              }
              if ($scope.editMode && code === 27) {
                e.stopPropagation();
                return $scope.$applyAsync($scope.cancelWithConfirmation);
              } else if (code === 27) {
                return editorMedium.blur();
              }
            });
            setEditMode(editMode);
            return $scope.$applyAsync(function() {
              wysiwygCodeHightlighterService.addHightlighter(mediumInstance.elements[0]);
              return refreshCodeBlocks(mediumInstance);
            });
          };
        })(this));
      };
      $(editorMedium[0]).on('mousedown', function(e) {
        if (e.target.href) {
          e.preventDefault();
          return e.stopPropagation();
        } else {
          return $scope.$applyAsync(function() {
            if (!$scope.editMode) {
              setEditMode(true);
              return refreshCodeBlocks(mediumInstance);
            }
          });
        }
      });
      $(editorMedium[0]).on('dblclick', 'pre', function(e) {
        return $scope.$applyAsync(function() {
          $scope.codeEditorVisible = true;
          codeBlockSelected = e.currentTarget.querySelector('code');
          $scope.currentCodeLanguage = wysiwygCodeHightlighterService.getLanguageInClassList(codeBlockSelected.classList);
          return $scope.code = codeBlockSelected.innerText;
        });
      });
      $(editorMarkdown).on("dragover", function(e) {
        return e.preventDefault();
      });
      $(editorMarkdown).on("dragenter", function(e) {
        return e.preventDefault();
      });
      $(editorMarkdown).on("drop", function(e) {
        e.preventDefault();
        return $scope.onUploadFile({
          files: e.originalEvent.dataTransfer.files,
          cb: uploadEndMarkdown
        });
      });
      unwatch = $scope.$watch('content', function(content) {
        var unwatchLoader;
        if (!_.isUndefined(content)) {
          $scope.outdated = isOutdated();
          if (!mediumInstance && isDraft()) {
            setEditMode(true);
          }
          if (($scope.markdown.length || content.length) && $scope.markdown === content) {
            return;
          }
          content = getCurrentContent();
          $scope.markdown = content;
          if (mediumInstance) {
            mediumInstance.destroy();
          }
          if (tgLoader.open()) {
            unwatchLoader = tgLoader.onEnd(function() {
              create(content, $scope.editMode);
              return unwatchLoader();
            });
          } else {
            create(content, $scope.editMode);
          }
          return unwatch();
        }
      });
      return $scope.$on("$destroy", function() {
        if (mediumInstance) {
          if (editorMedium.length) {
            $(editorMedium[0]).off();
          }
          return mediumInstance.destroy();
        }
      });
    };
    return {
      templateUrl: "common/components/wysiwyg-toolbar.html",
      scope: {
        placeholder: '@',
        version: '<',
        storageKey: '<',
        content: '<',
        onCancel: '&',
        onSave: '&',
        onUploadFile: '&',
        onChange: '&'
      },
      link: link
    };
  };

  angular.module("taigaComponents").directive("tgWysiwyg", ["$translate", "$tgConfirm", "$tgStorage", "tgWysiwygService", "animationFrame", "tgLoader", "tgWysiwygCodeHightlighterService", "tgWysiwygMentionService", "$tgAnalytics", "$location", Medium]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: components/wysiwyg/wysiwyg.service.coffee
 */

(function() {
  var WysiwygService;

  WysiwygService = (function() {
    WysiwygService.$inject = ["tgWysiwygCodeHightlighterService", "tgProjectService", "$tgNavUrls", "$tgEmojis", "tgAttachmentsService", "$q"];

    function WysiwygService(wysiwygCodeHightlighterService, projectService, navurls, emojis, attachmentsService, q) {
      var i, len, m, ref;
      this.wysiwygCodeHightlighterService = wysiwygCodeHightlighterService;
      this.projectService = projectService;
      this.navurls = navurls;
      this.emojis = emojis;
      this.attachmentsService = attachmentsService;
      this.q = q;
      this.members = this.projectService.project.get('members').toJS();
      this.memberObjectMap = {};
      ref = this.members;
      for (i = 0, len = ref.length; i < len; i++) {
        m = ref[i];
        this.memberObjectMap[m.username] = m;
      }
    }

    WysiwygService.prototype.searchEmojiByName = function(name) {
      return this.emojis.searchByName(name);
    };

    WysiwygService.prototype.pipeLinks = function(text) {
      return text.replace(/\[\[(.*?)\]\]/g, function(match, p1, offset, str) {
        var link, linkParams, title;
        linkParams = p1.split('|');
        link = linkParams[0];
        title = linkParams[1] || linkParams[0];
        return '[' + title + '](' + link + ')';
      });
    };

    WysiwygService.prototype.replaceUrls = function(html) {
      var el, i, len, link, links, username;
      el = document.createElement('html');
      el.innerHTML = html;
      links = el.querySelectorAll('a');
      for (i = 0, len = links.length; i < len; i++) {
        link = links[i];
        if (link.getAttribute('href').indexOf('/profile/') !== -1) {
          username = link.getAttribute('href').split('/profile/')[1];
          link.innerText = '@' + username;
          link.parentNode.replaceChild(document.createTextNode(link.innerText), link);
        } else if (link.getAttribute('href').indexOf('/t/') !== -1) {
          link.parentNode.replaceChild(document.createTextNode(link.innerText), link);
        }
      }
      return el.innerHTML;
    };

    WysiwygService.prototype.getAttachmentData = function(el, tokens, attr) {
      var deferred;
      deferred = this.q.defer();
      this.attachmentsService.get(tokens[0], tokens[1]).then(function(response) {
        el.setAttribute(attr, response.data.url + "#_taiga-refresh=" + tokens[0] + ":" + tokens[1]);
        return deferred.resolve(el);
      });
      return deferred.promise;
    };

    WysiwygService.prototype.refreshAttachmentURL = function(html) {
      var deferred, el, images, links, promises, regex;
      el = document.createElement('html');
      el.innerHTML = html;
      regex = /#_taiga-refresh=([a-zA-Z]*\:\d+)/;
      links = {
        "elements": el.querySelectorAll('a'),
        "attr": "href"
      };
      images = {
        "elements": el.querySelectorAll('img'),
        "attr": "src"
      };
      deferred = this.q.defer();
      promises = [];
      _.map([links, images], (function(_this) {
        return function(tag) {
          return _.map(tag.elements, function(e) {
            var match, tokens;
            if (e.getAttribute(tag.attr).indexOf('#_taiga-refresh=') !== -1) {
              match = e.getAttribute(tag.attr).match(regex);
              if (match) {
                tokens = match[1].split(":");
                return promises.push(_this.getAttachmentData(e, tokens, tag.attr));
              }
            }
          });
        };
      })(this));
      this.q.all(promises).then(function() {
        return deferred.resolve(el.innerHTML);
      });
      return deferred.promise;
    };

    WysiwygService.prototype.searchWikiLinks = function(html) {
      var el, i, len, link, links, url;
      el = document.createElement('html');
      el.innerHTML = html;
      links = el.querySelectorAll('a');
      for (i = 0, len = links.length; i < len; i++) {
        link = links[i];
        if (link.getAttribute('href').indexOf('/') === -1) {
          url = this.navurls.resolve('project-wiki-page', {
            project: this.projectService.project.get('slug'),
            slug: link.getAttribute('href')
          });
          link.setAttribute('href', url);
        }
      }
      return el.innerHTML;
    };

    WysiwygService.prototype.removeTrailingListBr = function(text) {
      return text.replace(/<li>(.*?)<br><\/li>/g, '<li>$1</li>');
    };

    WysiwygService.prototype.getMarkdown = function(html) {
      var cleanIssueConverter, codeLanguageConverter, markdown;
      cleanIssueConverter = {
        filter: ['html', 'body', 'span', 'div'],
        replacement: function(innerHTML) {
          return innerHTML;
        }
      };
      codeLanguageConverter = {
        filter: function(node) {
          return node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';
        },
        replacement: (function(_this) {
          return function(content, node) {
            var lan;
            lan = _this.wysiwygCodeHightlighterService.getLanguageInClassList(node.firstChild.classList);
            if (!lan) {
              lan = '';
            }
            return '\n\n```' + lan + '\n' + _.trim(node.firstChild.textContent) + '\n```\n\n';
          };
        })(this)
      };
      html = html.replace(/&nbsp;(<\/.*>)/g, "$1");
      html = this.emojis.replaceImgsByEmojiName(html);
      html = this.replaceUrls(html);
      html = this.removeTrailingListBr(html);
      markdown = toMarkdown(html, {
        gfm: true,
        converters: [cleanIssueConverter, codeLanguageConverter]
      });
      return markdown;
    };

    WysiwygService.prototype.parseMentionMatches = function(text) {
      var m, matches, offset, prevChar, regex, serviceName, tagBuilder;
      serviceName = 'twitter';
      tagBuilder = this.tagBuilder;
      matches = [];
      regex = /@[^\s]{1,50}[^.\s]/g;
      m = regex.exec(text);
      while (m !== null) {
        offset = m.index;
        prevChar = text.charAt(offset - 1);
        if (m.index === regex.lastIndex) {
          regex.lastIndex++;
        }
        m.forEach(function(match, groupIndex) {
          return matches.push(new Autolinker.match.Mention({
            tagBuilder: tagBuilder,
            matchedText: match,
            offset: offset,
            serviceName: serviceName,
            mention: match.slice(1)
          }));
        });
        m = regex.exec(text);
      }
      return matches;
    };

    WysiwygService.prototype.autoLinkHTML = function(html) {
      var autolinker, matchRegexStr;
      matchRegexStr = String(Autolinker.matcher.Mention.prototype.matcherRegexes.twitter);
      if (matchRegexStr.indexOf('.') === -1) {
        matchRegexStr = '@[^\s]{1,50}[^.\s]';
      }
      autolinker = new Autolinker({
        mention: 'twitter',
        hashtag: 'twitter',
        replaceFn: (function(_this) {
          return function(match) {
            var member, profileUrl, url;
            if (match.getType() === 'mention') {
              profileUrl = _this.navurls.resolve('user-profile', {
                project: _this.projectService.project.get('slug'),
                username: match.getMention()
              });
              if (_this.memberObjectMap.hasOwnProperty(match.getMention())) {
                member = _this.memberObjectMap[match.getMention()];
                if (member.full_name) {
                  return '<a class="autolink" href="' + profileUrl + '">@' + member.full_name + '</a>';
                }
              } else {
                return '<a class="autolink" href="' + profileUrl + '">@' + match.getMention() + '</a>';
              }
            } else if (match.getType() === 'hashtag') {
              url = _this.navurls.resolve('project-detail-ref', {
                project: _this.projectService.project.get('slug'),
                ref: match.getHashtag()
              });
              return '<a class="autolink" href="' + url + '">#' + match.getHashtag() + '</a>';
            }
          };
        })(this)
      });
      Autolinker.matcher.Mention.prototype.parseMatches = this.parseMentionMatches.bind(autolinker);
      return autolinker.link(html);
    };

    WysiwygService.prototype.getHTML = function(text) {
      var md, options, result;
      if (!text || !text.length) {
        return "";
      }
      options = {
        breaks: true
      };
      text = this.emojis.replaceEmojiNameByImgs(text);
      text = this.pipeLinks(text);
      md = window.markdownit({
        breaks: true
      });
      md.use(window.markdownitLazyHeaders);
      result = md.render(text);
      result = this.searchWikiLinks(result);
      result = this.autoLinkHTML(result);
      return result;
    };

    return WysiwygService;

  })();

  angular.module("taigaComponents").service("tgWysiwygService", WysiwygService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/discover-home-order-by/discover-home-order-by.controller.coffee
 */

(function() {
  var DiscoverHomeOrderByController;

  DiscoverHomeOrderByController = (function() {
    DiscoverHomeOrderByController.$inject = ['$translate'];

    function DiscoverHomeOrderByController(translate) {
      this.translate = translate;
      this.is_open = false;
      this.texts = {
        week: this.translate.instant('DISCOVER.FILTERS.WEEK'),
        month: this.translate.instant('DISCOVER.FILTERS.MONTH'),
        year: this.translate.instant('DISCOVER.FILTERS.YEAR'),
        all: this.translate.instant('DISCOVER.FILTERS.ALL_TIME')
      };
    }

    DiscoverHomeOrderByController.prototype.currentText = function() {
      return this.texts[this.currentOrderBy];
    };

    DiscoverHomeOrderByController.prototype.open = function() {
      return this.is_open = true;
    };

    DiscoverHomeOrderByController.prototype.close = function() {
      return this.is_open = false;
    };

    DiscoverHomeOrderByController.prototype.orderBy = function(type) {
      this.currentOrderBy = type;
      this.is_open = false;
      return this.onChange({
        orderBy: this.currentOrderBy
      });
    };

    return DiscoverHomeOrderByController;

  })();

  angular.module("taigaDiscover").controller("DiscoverHomeOrderBy", DiscoverHomeOrderByController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/discover-home-order-by/discover-home-order-by.directive.coffee
 */

(function() {
  var DiscoverHomeOrderByDirective;

  DiscoverHomeOrderByDirective = function() {
    var link;
    link = function(scope, el, attrs) {};
    return {
      controller: "DiscoverHomeOrderBy",
      controllerAs: "vm",
      bindToController: true,
      templateUrl: "discover/components/discover-home-order-by/discover-home-order-by.html",
      scope: {
        currentOrderBy: "=orderBy",
        onChange: "&"
      },
      link: link
    };
  };

  DiscoverHomeOrderByDirective.$inject = [];

  angular.module("taigaDiscover").directive("tgDiscoverHomeOrderBy", DiscoverHomeOrderByDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/discover-search-bar/discover-search-bar.controller.coffee
 */

(function() {
  var DiscoverSearchBarController;

  DiscoverSearchBarController = (function() {
    DiscoverSearchBarController.$inject = ['tgDiscoverProjectsService'];

    function DiscoverSearchBarController(discoverProjectsService) {
      this.discoverProjectsService = discoverProjectsService;
      taiga.defineImmutableProperty(this, 'projects', (function(_this) {
        return function() {
          return _this.discoverProjectsService.projectsCount;
        };
      })(this));
      this.discoverProjectsService.fetchStats();
    }

    DiscoverSearchBarController.prototype.selectFilter = function(filter) {
      return this.onChange({
        filter: filter,
        q: this.q
      });
    };

    DiscoverSearchBarController.prototype.submitFilter = function() {
      return this.onChange({
        filter: this.filter,
        q: this.q
      });
    };

    return DiscoverSearchBarController;

  })();

  angular.module("taigaDiscover").controller("DiscoverSearchBar", DiscoverSearchBarController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/discover-search-bar/discover-search-bar.directive.coffee
 */

(function() {
  var DiscoverSearchBarDirective;

  DiscoverSearchBarDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {};
    return {
      controller: "DiscoverSearchBar",
      controllerAs: "vm",
      templateUrl: 'discover/components/discover-search-bar/discover-search-bar.html',
      bindToController: true,
      scope: {
        q: "=",
        filter: "=",
        onChange: "&"
      },
      compile: function(element, attrs) {
        if (!attrs.q) {
          return attrs.q = '';
        }
      },
      link: link
    };
  };

  DiscoverSearchBarDirective.$inject = [];

  angular.module('taigaDiscover').directive('tgDiscoverSearchBar', DiscoverSearchBarDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/discover-search-list-header/discover-search-list-header.controller.coffee
 */

(function() {
  var DiscoverSearchListHeaderController;

  DiscoverSearchListHeaderController = (function() {
    DiscoverSearchListHeaderController.$inject = [];

    function DiscoverSearchListHeaderController() {
      this.like_is_open = this.orderBy.indexOf('-total_fans') === 0;
      this.activity_is_open = this.orderBy.indexOf('-total_activity') === 0;
    }

    DiscoverSearchListHeaderController.prototype.openLike = function() {
      this.like_is_open = true;
      this.activity_is_open = false;
      return this.setOrderBy('-total_fans_last_week');
    };

    DiscoverSearchListHeaderController.prototype.openActivity = function() {
      this.activity_is_open = true;
      this.like_is_open = false;
      return this.setOrderBy('-total_activity_last_week');
    };

    DiscoverSearchListHeaderController.prototype.setOrderBy = function(type) {
      if (type == null) {
        type = '';
      }
      if (!type) {
        this.like_is_open = false;
        this.activity_is_open = false;
      }
      return this.onChange({
        orderBy: type
      });
    };

    return DiscoverSearchListHeaderController;

  })();

  angular.module("taigaDiscover").controller("DiscoverSearchListHeader", DiscoverSearchListHeaderController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/discover-search-list-header/discover-search-list-header.directive.coffee
 */

(function() {
  var DiscoverSearchListHeaderDirective;

  DiscoverSearchListHeaderDirective = function() {
    var link;
    link = function(scope, el, attrs) {};
    return {
      controller: "DiscoverSearchListHeader",
      controllerAs: "vm",
      bindToController: true,
      templateUrl: "discover/components/discover-search-list-header/discover-search-list-header.html",
      scope: {
        onChange: "&",
        orderBy: "="
      },
      link: link
    };
  };

  DiscoverSearchListHeaderDirective.$inject = [];

  angular.module("taigaDiscover").directive("tgDiscoverSearchListHeader", DiscoverSearchListHeaderDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/featured-projects/featured-projects.controller.coffee
 */

(function() {
  var FeaturedProjectsController;

  FeaturedProjectsController = (function() {
    FeaturedProjectsController.$inject = ["tgDiscoverProjectsService"];

    function FeaturedProjectsController(discoverProjectsService) {
      this.discoverProjectsService = discoverProjectsService;
      taiga.defineImmutableProperty(this, "featured", (function(_this) {
        return function() {
          return _this.discoverProjectsService.featured;
        };
      })(this));
      this.discoverProjectsService.fetchFeatured();
    }

    return FeaturedProjectsController;

  })();

  angular.module("taigaDiscover").controller("FeaturedProjects", FeaturedProjectsController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/featured-projects/featured-projects.directive.coffee
 */

(function() {
  var FeaturedProjectsDirective;

  FeaturedProjectsDirective = function() {
    var link;
    link = function(scope, el, attrs) {};
    return {
      controller: "FeaturedProjects",
      controllerAs: "vm",
      templateUrl: "discover/components/featured-projects/featured-projects.html",
      scope: {},
      link: link
    };
  };

  FeaturedProjectsDirective.$inject = [];

  angular.module("taigaDiscover").directive("tgFeaturedProjects", FeaturedProjectsDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/highlighted/highlighted.directive.coffee
 */

(function() {
  var HighlightedDirective;

  HighlightedDirective = function() {
    return {
      templateUrl: "discover/components/highlighted/highlighted.html",
      scope: {
        loading: "=",
        highlighted: "=",
        orderBy: "="
      }
    };
  };

  HighlightedDirective.$inject = [];

  angular.module("taigaDiscover").directive("tgHighlighted", HighlightedDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/most-active/most-active.controller.coffee
 */

(function() {
  var MostActiveController;

  MostActiveController = (function() {
    MostActiveController.$inject = ["tgDiscoverProjectsService"];

    function MostActiveController(discoverProjectsService) {
      this.discoverProjectsService = discoverProjectsService;
      taiga.defineImmutableProperty(this, "highlighted", (function(_this) {
        return function() {
          return _this.discoverProjectsService.mostActive;
        };
      })(this));
      this.currentOrderBy = 'week';
      this.order_by = this.getOrderBy();
    }

    MostActiveController.prototype.fetch = function() {
      this.loading = true;
      this.order_by = this.getOrderBy();
      return this.discoverProjectsService.fetchMostActive({
        order_by: this.order_by
      }).then((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
    };

    MostActiveController.prototype.orderBy = function(type) {
      this.currentOrderBy = type;
      return this.fetch();
    };

    MostActiveController.prototype.getOrderBy = function(type) {
      if (this.currentOrderBy === 'all') {
        return '-total_activity';
      } else {
        return '-total_activity_last_' + this.currentOrderBy;
      }
    };

    return MostActiveController;

  })();

  angular.module("taigaDiscover").controller("MostActive", MostActiveController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/most-active/most-active.directive.coffee
 */

(function() {
  var MostActiveDirective;

  MostActiveDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return ctrl.fetch();
    };
    return {
      controller: "MostActive",
      controllerAs: "vm",
      templateUrl: "discover/components/most-active/most-active.html",
      scope: {},
      link: link
    };
  };

  MostActiveDirective.$inject = [];

  angular.module("taigaDiscover").directive("tgMostActive", MostActiveDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/most-liked/most-liked.controller.coffee
 */

(function() {
  var MostLikedController;

  MostLikedController = (function() {
    MostLikedController.$inject = ["tgDiscoverProjectsService"];

    function MostLikedController(discoverProjectsService) {
      this.discoverProjectsService = discoverProjectsService;
      taiga.defineImmutableProperty(this, "highlighted", (function(_this) {
        return function() {
          return _this.discoverProjectsService.mostLiked;
        };
      })(this));
      this.currentOrderBy = 'week';
      this.order_by = this.getOrderBy();
    }

    MostLikedController.prototype.fetch = function() {
      this.loading = true;
      this.order_by = this.getOrderBy();
      return this.discoverProjectsService.fetchMostLiked({
        order_by: this.order_by
      }).then((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
    };

    MostLikedController.prototype.orderBy = function(type) {
      this.currentOrderBy = type;
      return this.fetch();
    };

    MostLikedController.prototype.getOrderBy = function() {
      if (this.currentOrderBy === 'all') {
        return '-total_fans';
      } else {
        return '-total_fans_last_' + this.currentOrderBy;
      }
    };

    return MostLikedController;

  })();

  angular.module("taigaDiscover").controller("MostLiked", MostLikedController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/components/most-liked/most-liked.directive.coffee
 */

(function() {
  var MostLikedDirective;

  MostLikedDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return ctrl.fetch();
    };
    return {
      controller: "MostLiked",
      controllerAs: "vm",
      templateUrl: "discover/components/most-liked/most-liked.html",
      scope: {},
      link: link
    };
  };

  MostLikedDirective.$inject = [];

  angular.module("taigaDiscover").directive("tgMostLiked", MostLikedDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/discover-home/discover-home.controller.coffee
 */

(function() {
  var DiscoverHomeController;

  DiscoverHomeController = (function() {
    DiscoverHomeController.$inject = ['$tgLocation', '$tgNavUrls', 'tgAppMetaService', '$translate'];

    function DiscoverHomeController(location, navUrls, appMetaService, translate) {
      var description, title;
      this.location = location;
      this.navUrls = navUrls;
      this.appMetaService = appMetaService;
      this.translate = translate;
      title = this.translate.instant("DISCOVER.PAGE_TITLE");
      description = this.translate.instant("DISCOVER.PAGE_DESCRIPTION");
      this.appMetaService.setAll(title, description);
    }

    DiscoverHomeController.prototype.onSubmit = function(q) {
      var url;
      url = this.navUrls.resolve('discover-search');
      return this.location.search('text', q).path(url);
    };

    return DiscoverHomeController;

  })();

  angular.module("taigaDiscover").controller("DiscoverHome", DiscoverHomeController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/discover-search/discover-search.controller.coffee
 */

(function() {
  var DiscoverSearchController;

  DiscoverSearchController = (function() {
    DiscoverSearchController.$inject = ['$routeParams', 'tgDiscoverProjectsService', '$route', '$tgLocation', '$tgAnalytics', 'tgAppMetaService', '$translate'];

    function DiscoverSearchController(routeParams, discoverProjectsService, route, location, analytics, appMetaService, translate) {
      var description, title;
      this.routeParams = routeParams;
      this.discoverProjectsService = discoverProjectsService;
      this.route = route;
      this.location = location;
      this.analytics = analytics;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.page = 1;
      taiga.defineImmutableProperty(this, "searchResult", (function(_this) {
        return function() {
          return _this.discoverProjectsService.searchResult;
        };
      })(this));
      taiga.defineImmutableProperty(this, "nextSearchPage", (function(_this) {
        return function() {
          return _this.discoverProjectsService.nextSearchPage;
        };
      })(this));
      this.q = this.routeParams.text;
      this.filter = this.routeParams.filter || 'all';
      this.orderBy = this.routeParams['order_by'] || '';
      this.loadingGlobal = false;
      this.loadingList = false;
      this.loadingPagination = false;
      title = this.translate.instant("DISCOVER.SEARCH.PAGE_TITLE");
      description = this.translate.instant("DISCOVER.SEARCH.PAGE_DESCRIPTION");
      this.appMetaService.setAll(title, description);
      this.analytics.trackPage(this.location.url(), "Discover Search");
    }

    DiscoverSearchController.prototype.fetch = function() {
      this.page = 1;
      this.discoverProjectsService.resetSearchList();
      return this.search();
    };

    DiscoverSearchController.prototype.fetchByGlobalSearch = function() {
      if (this.loadingGlobal) {
        return;
      }
      this.loadingGlobal = true;
      return this.fetch().then((function(_this) {
        return function() {
          return _this.loadingGlobal = false;
        };
      })(this));
    };

    DiscoverSearchController.prototype.fetchByOrderBy = function() {
      if (this.loadingList) {
        return;
      }
      this.loadingList = true;
      return this.fetch().then((function(_this) {
        return function() {
          return _this.loadingList = false;
        };
      })(this));
    };

    DiscoverSearchController.prototype.showMore = function() {
      if (this.loadingPagination) {
        return;
      }
      this.loadingPagination = true;
      this.page++;
      return this.search().then((function(_this) {
        return function() {
          return _this.loadingPagination = false;
        };
      })(this));
    };

    DiscoverSearchController.prototype.search = function() {
      var filter, params;
      filter = this.getFilter();
      params = {
        page: this.page,
        q: this.q,
        order_by: this.orderBy
      };
      _.assign(params, filter);
      return this.discoverProjectsService.fetchSearch(params);
    };

    DiscoverSearchController.prototype.getFilter = function() {
      if (this.filter === 'people') {
        return {
          is_looking_for_people: true
        };
      } else if (this.filter === 'scrum') {
        return {
          is_backlog_activated: true
        };
      } else if (this.filter === 'kanban') {
        return {
          is_kanban_activated: true
        };
      }
      return {};
    };

    DiscoverSearchController.prototype.onChangeFilter = function(filter, q) {
      this.filter = filter;
      this.q = q;
      this.route.updateParams({
        filter: this.filter,
        text: this.q
      });
      this.analytics.trackPage(this.location.url(), "Discover Search");
      return this.fetchByGlobalSearch();
    };

    DiscoverSearchController.prototype.onChangeOrder = function(orderBy) {
      this.orderBy = orderBy;
      this.route.updateParams({
        order_by: orderBy
      });
      this.analytics.trackPage(this.location.url(), "Discover Search");
      return this.fetchByOrderBy();
    };

    return DiscoverSearchController;

  })();

  angular.module("taigaDiscover").controller("DiscoverSearch", DiscoverSearchController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/discover-search/discover-search.directive.coffee
 */

(function() {
  var DiscoverSearchDirective;

  DiscoverSearchDirective = function() {
    var link;
    link = function(scope, element, attrs, ctrl) {
      return ctrl.fetch();
    };
    return {
      controller: "DiscoverSearch",
      controllerAs: "vm",
      link: link
    };
  };

  DiscoverSearchDirective.$inject = [];

  angular.module("taigaDiscover").directive("tgDiscoverSearch", DiscoverSearchDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: discover/services/discover-projects.service.coffee
 */

(function() {
  var DiscoverProjectsService, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  DiscoverProjectsService = (function(superClass) {
    var _discoverParams;

    extend(DiscoverProjectsService, superClass);

    DiscoverProjectsService.$inject = ["tgResources", "tgProjectsService"];

    _discoverParams = {
      discover_mode: true
    };

    function DiscoverProjectsService(rs, projectsService) {
      this.rs = rs;
      this.projectsService = projectsService;
      this._mostLiked = Immutable.List();
      this._mostActive = Immutable.List();
      this._featured = Immutable.List();
      this._searchResult = Immutable.List();
      this._projectsCount = 0;
      this.decorate = this.projectsService._decorate.bind(this.projectsService);
      taiga.defineImmutableProperty(this, "mostLiked", (function(_this) {
        return function() {
          return _this._mostLiked;
        };
      })(this));
      taiga.defineImmutableProperty(this, "mostActive", (function(_this) {
        return function() {
          return _this._mostActive;
        };
      })(this));
      taiga.defineImmutableProperty(this, "featured", (function(_this) {
        return function() {
          return _this._featured;
        };
      })(this));
      taiga.defineImmutableProperty(this, "searchResult", (function(_this) {
        return function() {
          return _this._searchResult;
        };
      })(this));
      taiga.defineImmutableProperty(this, "nextSearchPage", (function(_this) {
        return function() {
          return _this._nextSearchPage;
        };
      })(this));
      taiga.defineImmutableProperty(this, "projectsCount", (function(_this) {
        return function() {
          return _this._projectsCount;
        };
      })(this));
    }

    DiscoverProjectsService.prototype.fetchMostLiked = function(params) {
      var _params;
      _params = _.extend({}, _discoverParams, params);
      return this.rs.projects.getProjects(_params, false).then((function(_this) {
        return function(result) {
          var data, projects;
          data = result.data.slice(0, 5);
          projects = Immutable.fromJS(data);
          projects = projects.map(_this.decorate);
          return _this._mostLiked = projects;
        };
      })(this));
    };

    DiscoverProjectsService.prototype.fetchMostActive = function(params) {
      var _params;
      _params = _.extend({}, _discoverParams, params);
      return this.rs.projects.getProjects(_params, false).then((function(_this) {
        return function(result) {
          var data, projects;
          data = result.data.slice(0, 5);
          projects = Immutable.fromJS(data);
          projects = projects.map(_this.decorate);
          return _this._mostActive = projects;
        };
      })(this));
    };

    DiscoverProjectsService.prototype.fetchFeatured = function() {
      var _params;
      _params = _.extend({}, _discoverParams);
      _params.is_featured = true;
      return this.rs.projects.getProjects(_params, false).then((function(_this) {
        return function(result) {
          var data, projects;
          data = result.data.slice(0, 4);
          projects = Immutable.fromJS(data);
          projects = projects.map(_this.decorate);
          return _this._featured = projects;
        };
      })(this));
    };

    DiscoverProjectsService.prototype.resetSearchList = function() {
      return this._searchResult = Immutable.List();
    };

    DiscoverProjectsService.prototype.fetchStats = function() {
      return this.rs.stats.discover().then((function(_this) {
        return function(discover) {
          return _this._projectsCount = discover.getIn(['projects', 'total']);
        };
      })(this));
    };

    DiscoverProjectsService.prototype.fetchSearch = function(params) {
      var _params;
      _params = _.extend({}, _discoverParams, params);
      return this.rs.projects.getProjects(_params).then((function(_this) {
        return function(result) {
          var projects;
          _this._nextSearchPage = !!result.headers('X-Pagination-Next');
          projects = Immutable.fromJS(result.data);
          projects = projects.map(_this.decorate);
          return _this._searchResult = _this._searchResult.concat(projects);
        };
      })(this));
    };

    return DiscoverProjectsService;

  })(taiga.Service);

  angular.module("taigaDiscover").service("tgDiscoverProjectsService", DiscoverProjectsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/create-epic/create-epic.controller.coffee
 */

(function() {
  var CreateEpicController, getRandomDefaultColor, taiga, trim;

  taiga = this.taiga;

  trim = taiga.trim;

  getRandomDefaultColor = taiga.getRandomDefaultColor;

  CreateEpicController = (function() {
    CreateEpicController.$inject = ["$tgConfirm", "tgProjectService", "tgEpicsService", "$tgAnalytics"];

    function CreateEpicController(confirm, projectService, epicsService, analytics) {
      this.confirm = confirm;
      this.projectService = projectService;
      this.epicsService = epicsService;
      this.analytics = analytics;
      this.project = this.projectService.project.toJS();
      this.newEpic = {
        color: getRandomDefaultColor(),
        status: this.project.default_epic_status,
        tags: []
      };
      this.attachments = Immutable.List();
      this.loading = false;
    }

    CreateEpicController.prototype.createEpic = function() {
      if (!this.validateForm()) {
        return;
      }
      this.loading = true;
      return this.epicsService.createEpic(this.newEpic, this.attachments).then((function(_this) {
        return function(response) {
          _this.analytics.trackEvent("epic", "create", "create epic", 1);
          _this.onCreateEpic();
          return _this.loading = false;
        };
      })(this))["catch"]((function(_this) {
        return function(response) {
          _this.loading = false;
          _this.setFormErrors(response.data);
          if (response.data._error_message) {
            return _this.confirm.notify("error", response.data._error_message);
          }
        };
      })(this));
    };

    CreateEpicController.prototype.selectColor = function(color) {
      return this.newEpic.color = color;
    };

    CreateEpicController.prototype.addTag = function(name, color) {
      name = trim(name.toLowerCase());
      if (!_.find(this.newEpic.tags, function(it) {
        return it[0] === name;
      })) {
        return this.newEpic.tags.push([name, color]);
      }
    };

    CreateEpicController.prototype.deleteTag = function(tag) {
      return _.remove(this.newEpic.tags, function(it) {
        return it[0] === tag[0];
      });
    };

    CreateEpicController.prototype.addAttachment = function(attachment) {
      return this.attachments.push(attachment);
    };

    return CreateEpicController;

  })();

  angular.module("taigaEpics").controller("CreateEpicCtrl", CreateEpicController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/create-epic/create-epic.directive.coffee
 */

(function() {
  var CreateEpicDirective;

  CreateEpicDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var form;
      form = el.find("form").checksley();
      ctrl.validateForm = (function(_this) {
        return function() {
          return form.validate();
        };
      })(this);
      return ctrl.setFormErrors = (function(_this) {
        return function(errors) {
          return form.setErrors(errors);
        };
      })(this);
    };
    return {
      link: link,
      templateUrl: "epics/create-epic/create-epic.html",
      controller: "CreateEpicCtrl",
      controllerAs: "vm",
      bindToController: {
        onCreateEpic: '&'
      },
      scope: {}
    };
  };

  angular.module('taigaEpics').directive("tgCreateEpic", CreateEpicDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/dashboard/epic-row/epic-row.controller.coffee
 */

(function() {
  var EpicRowController;

  EpicRowController = (function() {
    EpicRowController.$inject = ["$tgConfirm", "tgProjectService", "tgEpicsService"];

    function EpicRowController(confirm, projectService, epicsService) {
      this.confirm = confirm;
      this.projectService = projectService;
      this.epicsService = epicsService;
      this.displayUserStories = false;
      this.displayAssignedTo = false;
      this.displayStatusList = false;
      this.loadingStatus = false;
      this.project = this.projectService.project.toJS();
      this._calculateProgressBar();
    }

    EpicRowController.prototype._calculateProgressBar = function() {
      var progress, total;
      if (this.epic.getIn(['status_extra_info', 'is_closed']) === true) {
        return this.percentage = "100%";
      } else {
        progress = this.epic.getIn(['user_stories_counts', 'progress']);
        total = this.epic.getIn(['user_stories_counts', 'total']);
        if (total === 0) {
          return this.percentage = "0%";
        } else {
          return this.percentage = (progress * 100 / total) + "%";
        }
      }
    };

    EpicRowController.prototype.canEditEpics = function() {
      return this.projectService.hasPermission("modify_epic");
    };

    EpicRowController.prototype.toggleUserStoryList = function() {
      if (!this.displayUserStories) {
        return this.epicsService.listRelatedUserStories(this.epic).then((function(_this) {
          return function(userStories) {
            _this.epicStories = userStories;
            return _this.displayUserStories = true;
          };
        })(this))["catch"]((function(_this) {
          return function() {
            return _this.confirm.notify('error');
          };
        })(this));
      } else {
        return this.displayUserStories = false;
      }
    };

    EpicRowController.prototype.updateStatus = function(statusId) {
      this.displayStatusList = false;
      this.loadingStatus = true;
      return this.epicsService.updateEpicStatus(this.epic, statusId)["catch"]((function(_this) {
        return function() {
          return _this.confirm.notify('error');
        };
      })(this))["finally"]((function(_this) {
        return function() {
          return _this.loadingStatus = false;
        };
      })(this));
    };

    EpicRowController.prototype.updateAssignedTo = function(member) {
      this.assignLoader = true;
      return this.epicsService.updateEpicAssignedTo(this.epic, (member != null ? member.id : void 0) || null)["catch"]((function(_this) {
        return function() {
          return _this.confirm.notify('error');
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.assignLoader = false;
        };
      })(this));
    };

    return EpicRowController;

  })();

  angular.module("taigaEpics").controller("EpicRowCtrl", EpicRowController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/dashboard/epic-row/epic-row.directive.coffee
 */

(function() {
  var EpicRowDirective;

  EpicRowDirective = function() {
    return {
      templateUrl: "epics/dashboard/epic-row/epic-row.html",
      controller: "EpicRowCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        epic: '=',
        options: '='
      }
    };
  };

  angular.module('taigaEpics').directive("tgEpicRow", EpicRowDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/dashboard/epics-dashboard.controller.coffee
 */

(function() {
  var EpicsDashboardController, taiga;

  taiga = this.taiga;

  EpicsDashboardController = (function() {
    EpicsDashboardController.$inject = ["$routeParams", "tgErrorHandlingService", "tgLightboxFactory", "lightboxService", "$tgConfirm", "tgProjectService", "tgEpicsService", "tgAppMetaService", "$translate"];

    function EpicsDashboardController(params, errorHandlingService, lightboxFactory, lightboxService, confirm, projectService, epicsService, appMetaService, translate) {
      this.params = params;
      this.errorHandlingService = errorHandlingService;
      this.lightboxFactory = lightboxFactory;
      this.lightboxService = lightboxService;
      this.confirm = confirm;
      this.projectService = projectService;
      this.epicsService = epicsService;
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.sectionName = "EPICS.SECTION_NAME";
      taiga.defineImmutableProperty(this, 'project', (function(_this) {
        return function() {
          return _this.projectService.project;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'epics', (function(_this) {
        return function() {
          return _this.epicsService.epics;
        };
      })(this));
      this.appMetaService.setfn(this._setMeta.bind(this));
    }

    EpicsDashboardController.prototype._setMeta = function() {
      var ctx;
      if (!this.project) {
        return null;
      }
      ctx = {
        projectName: this.project.get("name"),
        projectDescription: this.project.get("description")
      };
      return {
        title: this.translate.instant("EPICS.PAGE_TITLE", ctx),
        description: this.translate.instant("EPICS.PAGE_DESCRIPTION", ctx)
      };
    };

    EpicsDashboardController.prototype.loadInitialData = function() {
      this.epicsService.clear();
      return this.projectService.setProjectBySlug(this.params.pslug).then((function(_this) {
        return function() {
          if (!_this.projectService.isEpicsDashboardEnabled()) {
            return _this.errorHandlingService.notFound();
          }
          if (!_this.projectService.hasPermission("view_epics")) {
            return _this.errorHandlingService.permissionDenied();
          }
          return _this.epicsService.fetchEpics();
        };
      })(this));
    };

    EpicsDashboardController.prototype.canCreateEpics = function() {
      return this.projectService.hasPermission("add_epic");
    };

    EpicsDashboardController.prototype.onCreateEpic = function() {
      var onCreateEpic;
      onCreateEpic = (function(_this) {
        return function() {
          _this.lightboxService.closeAll();
          _this.confirm.notify("success");
        };
      })(this);
      return this.lightboxFactory.create('tg-create-epic', {
        "class": "lightbox lightbox-create-epic open",
        "on-create-epic": "onCreateEpic()"
      }, {
        "onCreateEpic": onCreateEpic.bind(this)
      });
    };

    return EpicsDashboardController;

  })();

  angular.module("taigaEpics").controller("EpicsDashboardCtrl", EpicsDashboardController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/dashboard/epics-sortable/epics-sortable.directive.coffee
 */

(function() {
  var EpicsSortableDirective;

  EpicsSortableDirective = function($parse, projectService) {
    var link;
    link = function(scope, el, attrs) {
      var callback, drake, scroll;
      if (!projectService.hasPermission("modify_epic")) {
        return;
      }
      callback = $parse(attrs.tgEpicsSortable);
      drake = dragula([el[0]], {
        copySortSource: false,
        copy: false,
        mirrorContainer: el[0],
        moves: function(item) {
          return $(item).is('div.epics-table-body-row');
        }
      });
      drake.on('dragend', function(item) {
        var epic, itemEl, newIndex;
        itemEl = $(item);
        epic = itemEl.scope().epic;
        newIndex = itemEl.index();
        return scope.$apply(function() {
          return callback(scope, {
            epic: epic,
            newIndex: newIndex
          });
        });
      });
      scroll = autoScroll(window, {
        margin: 20,
        pixels: 30,
        scrollWhenOutside: true,
        autoScroll: function() {
          return this.down && drake.dragging;
        }
      });
      return scope.$on("$destroy", function() {
        el.off();
        return drake.destroy();
      });
    };
    return {
      link: link
    };
  };

  EpicsSortableDirective.$inject = ["$parse", "tgProjectService"];

  angular.module("taigaComponents").directive("tgEpicsSortable", EpicsSortableDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/dashboard/epics-table/epics-table.controller.coffee
 */

(function() {
  var EpicsTableController, generateHash, taiga;

  taiga = this.taiga;

  generateHash = this.taiga.generateHash;

  EpicsTableController = (function() {
    EpicsTableController.$inject = ["$tgConfirm", "tgEpicsService", "$timeout", "$tgStorage", "tgProjectService"];

    function EpicsTableController(confirm, epicsService, timeout, storage, projectService) {
      this.confirm = confirm;
      this.epicsService = epicsService;
      this.timeout = timeout;
      this.storage = storage;
      this.projectService = projectService;
      this.hash = generateHash([this.projectService.project.get('id'), 'epics']);
      this.displayOptions = false;
      this.displayVotes = true;
      this.options = this.storage.get(this.hash, {
        votes: true,
        name: true,
        project: true,
        sprint: true,
        assigned: true,
        status: true,
        progress: true,
        closed: true,
        closed_us: true
      });
      taiga.defineImmutableProperty(this, 'epics', (function(_this) {
        return function() {
          return _this.epicsService.epics;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'disabledEpicsPagination', (function(_this) {
        return function() {
          return _this.epicsService._disablePagination;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'loadingEpics', (function(_this) {
        return function() {
          return _this.epicsService._loadingEpics;
        };
      })(this));
    }

    EpicsTableController.prototype.toggleEpicTableOptions = function() {
      return this.displayOptions = !this.displayOptions;
    };

    EpicsTableController.prototype.reorderEpic = function(epic, newIndex) {
      if (epic.get('epics_order') === newIndex) {
        return null;
      }
      return this.epicsService.reorderEpic(epic, newIndex).then(null, (function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this));
    };

    EpicsTableController.prototype.nextPage = function() {
      return this.epicsService.nextPage();
    };

    EpicsTableController.prototype.hoverEpicTableOption = function() {
      if (this.timer) {
        return this.timeout.cancel(this.timer);
      }
    };

    EpicsTableController.prototype.hideEpicTableOption = function() {
      return this.timer = this.timeout(((function(_this) {
        return function() {
          return _this.displayOptions = false;
        };
      })(this)), 400);
    };

    EpicsTableController.prototype.updateViewOptions = function() {
      return this.storage.set(this.hash, this.options);
    };

    return EpicsTableController;

  })();

  angular.module("taigaEpics").controller("EpicsTableCtrl", EpicsTableController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/dashboard/epics-table/epics-table.directive.coffee
 */

(function() {
  var EpicsTableDirective;

  EpicsTableDirective = function() {
    return {
      templateUrl: "epics/dashboard/epics-table/epics-table.html",
      controller: "EpicsTableCtrl",
      controllerAs: "vm",
      scope: {}
    };
  };

  angular.module('taigaEpics').directive("tgEpicsTable", EpicsTableDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/dashboard/story-row/story-row.controller.coffee
 */

(function() {
  var StoryRowController, module;

  module = angular.module("taigaEpics");

  StoryRowController = (function() {
    StoryRowController.$inject = [];

    function StoryRowController() {
      this._calculateProgressBar();
    }

    StoryRowController.prototype._calculateProgressBar = function() {
      var totalTasks, totalTasksCompleted;
      if (this.story.get('is_closed') === true) {
        return this.percentage = "100%";
      } else {
        totalTasks = this.story.get('tasks').size;
        totalTasksCompleted = this.story.get('tasks').filter(function(it) {
          return it.get("is_closed");
        }).size;
        if (totalTasks === 0) {
          return this.percentage = "0%";
        } else {
          return this.percentage = (totalTasksCompleted * 100 / totalTasks) + "%";
        }
      }
    };

    return StoryRowController;

  })();

  module.controller("StoryRowCtrl", StoryRowController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/dashboard/story-row/story-row.directive.coffee
 */

(function() {
  var StoryRowDirective, module;

  module = angular.module('taigaEpics');

  StoryRowDirective = function() {
    return {
      templateUrl: "epics/dashboard/story-row/story-row.html",
      controller: "StoryRowCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        story: '=',
        options: '='
      }
    };
  };

  module.directive("tgStoryRow", StoryRowDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/epics.service.coffee
 */

(function() {
  var EpicsService, taiga;

  taiga = this.taiga;

  EpicsService = (function() {
    EpicsService.$inject = ['tgProjectService', 'tgAttachmentsService', 'tgResources', 'tgXhrErrorService'];

    function EpicsService(projectService, attachmentsService, resources, xhrError) {
      this.projectService = projectService;
      this.attachmentsService = attachmentsService;
      this.resources = resources;
      this.xhrError = xhrError;
      this.clear();
      taiga.defineImmutableProperty(this, 'epics', (function(_this) {
        return function() {
          return _this._epics;
        };
      })(this));
    }

    EpicsService.prototype.clear = function() {
      this._loadingEpics = false;
      this._disablePagination = false;
      this._page = 1;
      return this._epics = Immutable.List();
    };

    EpicsService.prototype.fetchEpics = function(reset) {
      if (reset == null) {
        reset = false;
      }
      this._loadingEpics = true;
      this._disablePagination = true;
      return this.resources.epics.list(this.projectService.project.get('id'), this._page).then((function(_this) {
        return function(result) {
          if (reset) {
            _this.clear();
            _this._epics = result.list;
          } else {
            _this._epics = _this._epics.concat(result.list);
          }
          _this._loadingEpics = false;
          return _this._disablePagination = !result.headers('x-pagination-next');
        };
      })(this))["catch"]((function(_this) {
        return function(xhr) {
          return _this.xhrError.response(xhr);
        };
      })(this));
    };

    EpicsService.prototype.nextPage = function() {
      this._page++;
      return this.fetchEpics();
    };

    EpicsService.prototype.listRelatedUserStories = function(epic) {
      return this.resources.userstories.listInEpic(epic.get('id'));
    };

    EpicsService.prototype.createEpic = function(epicData, attachments, projectId) {
      if (projectId) {
        epicData.project = projectId;
      } else {
        epicData.project = this.projectService.project.get('id');
      }
      return this.resources.epics.post(epicData).then((function(_this) {
        return function(epic) {
          var promises;
          if (!attachments) {
            return epic;
          } else {
            promises = _.map(attachments.toJS(), function(attachment) {
              return _this.attachmentsService.upload(attachment.file, epic.get('id'), epic.get('project'), 'epic');
            });
            return Promise.all(promises).then(_this.fetchEpics.bind(_this, true));
          }
        };
      })(this));
    };

    EpicsService.prototype.reorderEpic = function(epic, newIndex) {
      var afterDestination, beforeDestination, data, newOrder, orderList, previous, previousWithTheSameOrder, setOrders, withoutMoved;
      orderList = {};
      this._epics.forEach(function(it) {
        return orderList[it.get('id')] = it.get('epics_order');
      });
      withoutMoved = this.epics.filter((function(_this) {
        return function(it) {
          return it.get('id') !== epic.get('id');
        };
      })(this));
      beforeDestination = withoutMoved.slice(0, newIndex);
      afterDestination = withoutMoved.slice(newIndex);
      previous = beforeDestination.last();
      newOrder = !previous ? 0 : previous.get('epics_order') + 1;
      orderList[epic.get('id')] = newOrder;
      previousWithTheSameOrder = beforeDestination.filter((function(_this) {
        return function(it) {
          return it.get('epics_order') === previous.get('epics_order');
        };
      })(this));
      setOrders = _.fromPairs(previousWithTheSameOrder.map((function(_this) {
        return function(it) {
          return [it.get('id'), it.get('epics_order')];
        };
      })(this)).toJS());
      afterDestination.forEach(function(it) {
        return orderList[it.get('id')] = it.get('epics_order') + 1;
      });
      this._epics = this._epics.map(function(it) {
        return it.set('epics_order', orderList[it.get('id')]);
      });
      this._epics = this._epics.sortBy(function(it) {
        return it.get('epics_order');
      });
      data = {
        epics_order: newOrder,
        version: epic.get('version')
      };
      return this.resources.epics.reorder(epic.get('id'), data, setOrders).then((function(_this) {
        return function(newEpic) {
          return _this._epics = _this._epics.map(function(it) {
            if (it.get('id') === newEpic.get('id')) {
              return newEpic;
            }
            return it;
          });
        };
      })(this));
    };

    EpicsService.prototype.reorderRelatedUserstory = function(epic, epicUserstories, userstory, newIndex) {
      var beforeDestination, data, epicId, newOrder, previous, previousWithTheSameOrder, setOrders, userstoryId, withoutMoved;
      withoutMoved = epicUserstories.filter((function(_this) {
        return function(it) {
          return it.get('id') !== userstory.get('id');
        };
      })(this));
      beforeDestination = withoutMoved.slice(0, newIndex);
      previous = beforeDestination.last();
      newOrder = !previous ? 0 : previous.get('epic_order') + 1;
      previousWithTheSameOrder = beforeDestination.filter((function(_this) {
        return function(it) {
          return it.get('epic_order') === previous.get('epic_order');
        };
      })(this));
      setOrders = _.fromPairs(previousWithTheSameOrder.map((function(_this) {
        return function(it) {
          return [it.get('id'), it.get('epic_order')];
        };
      })(this)).toJS());
      data = {
        order: newOrder
      };
      epicId = epic.get('id');
      userstoryId = userstory.get('id');
      return this.resources.epics.reorderRelatedUserstory(epicId, userstoryId, data, setOrders).then((function(_this) {
        return function() {
          return _this.listRelatedUserStories(epic);
        };
      })(this));
    };

    EpicsService.prototype.replaceEpic = function(epic) {
      return this._epics = this._epics.map(function(it) {
        if (it.get('id') === epic.get('id')) {
          return epic;
        }
        return it;
      });
    };

    EpicsService.prototype.updateEpicStatus = function(epic, statusId) {
      var data;
      data = {
        status: statusId,
        version: epic.get('version')
      };
      return this.resources.epics.patch(epic.get('id'), data).then(this.replaceEpic.bind(this));
    };

    EpicsService.prototype.updateEpicAssignedTo = function(epic, userId) {
      var data;
      data = {
        assigned_to: userId,
        version: epic.get('version')
      };
      return this.resources.epics.patch(epic.get('id'), data).then(this.replaceEpic.bind(this));
    };

    return EpicsService;

  })();

  angular.module('taigaEpics').service('tgEpicsService', EpicsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/related-userstories/related-userstories-controller.coffee
 */

(function() {
  var RelatedUserStoriesController, module;

  module = angular.module("taigaEpics");

  RelatedUserStoriesController = (function() {
    RelatedUserStoriesController.$inject = ["tgProjectService", "tgEpicsService"];

    function RelatedUserStoriesController(projectService, epicsService) {
      this.projectService = projectService;
      this.epicsService = epicsService;
      this.sectionName = "Epics";
      this.showCreateRelatedUserstoriesLightbox = false;
    }

    RelatedUserStoriesController.prototype.showRelatedUserStoriesSection = function() {
      var ref;
      return this.projectService.hasPermission("view_epics") || ((ref = this.userstories) != null ? ref.length : void 0) > 0;
    };

    RelatedUserStoriesController.prototype.userCanSort = function() {
      return this.projectService.hasPermission("modify_epic");
    };

    RelatedUserStoriesController.prototype.loadRelatedUserstories = function() {
      return this.epicsService.listRelatedUserStories(this.epic).then((function(_this) {
        return function(userstories) {
          return _this.userstories = userstories;
        };
      })(this));
    };

    RelatedUserStoriesController.prototype.reorderRelatedUserstory = function(us, newIndex) {
      return this.epicsService.reorderRelatedUserstory(this.epic, this.userstories, us, newIndex).then((function(_this) {
        return function(userstories) {
          return _this.userstories = userstories;
        };
      })(this));
    };

    return RelatedUserStoriesController;

  })();

  module.controller("RelatedUserStoriesCtrl", RelatedUserStoriesController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/related-userstories/related-userstories-create/related-userstories-create.controller.coffee
 */

(function() {
  var RelatedUserstoriesCreateController, module;

  module = angular.module("taigaEpics");

  RelatedUserstoriesCreateController = (function() {
    RelatedUserstoriesCreateController.$inject = ["tgCurrentUserService", "tgResources", "$tgConfirm", "$tgAnalytics"];

    function RelatedUserstoriesCreateController(currentUserService, rs, confirm, analytics) {
      this.currentUserService = currentUserService;
      this.rs = rs;
      this.confirm = confirm;
      this.analytics = analytics;
      this.projects = null;
      this.projectUserstories = Immutable.List();
      this.loading = false;
    }

    RelatedUserstoriesCreateController.prototype.loadProjects = function() {
      if (this.projects === null) {
        return this.projects = this.currentUserService.projects.get("unblocked");
      }
    };

    RelatedUserstoriesCreateController.prototype.filterUss = function(selectedProjectId, filterText) {
      var promise;
      promise = this.rs.userstories.listInAllProjects({
        project: selectedProjectId,
        q: filterText
      }, true).then((function(_this) {
        return function(data) {
          var excludeIds, filteredData;
          excludeIds = _this.epicUserstories.map(function(us) {
            return us.get('id');
          });
          filteredData = data.filter(function(us) {
            return excludeIds.indexOf(us.get('id')) === -1;
          });
          return _this.projectUserstories = filteredData;
        };
      })(this));
      return promise;
    };

    RelatedUserstoriesCreateController.prototype.saveRelatedUserStory = function(selectedUserstoryId, onSavedRelatedUserstory) {
      var epicId, onError, onSuccess;
      if (!this.validateExistingUserstoryForm()) {
        return;
      }
      this.loading = true;
      onError = (function(_this) {
        return function(data) {
          _this.loading = false;
          _this.confirm.notify("error");
          return _this.setExistingUserstoryFormErrors(data);
        };
      })(this);
      onSuccess = (function(_this) {
        return function() {
          _this.analytics.trackEvent("epic related user story", "create", "create related user story on epic", 1);
          _this.loading = false;
          if (onSavedRelatedUserstory) {
            onSavedRelatedUserstory();
          }
          return _this.loadRelatedUserstories();
        };
      })(this);
      epicId = this.epic.get('id');
      return this.rs.epics.addRelatedUserstory(epicId, selectedUserstoryId).then(onSuccess, onError);
    };

    RelatedUserstoriesCreateController.prototype.bulkCreateRelatedUserStories = function(selectedProjectId, userstoriesText, onCreatedRelatedUserstory) {
      var epicId, onError, onSuccess;
      if (!this.validateNewUserstoryForm()) {
        return;
      }
      this.loading = true;
      onError = (function(_this) {
        return function(data) {
          _this.loading = false;
          _this.confirm.notify("error");
          return _this.setNewUserstoryFormErrors(data);
        };
      })(this);
      onSuccess = (function(_this) {
        return function() {
          _this.analytics.trackEvent("epic related user story", "create", "create related user story on epic", 1);
          _this.loading = false;
          if (onCreatedRelatedUserstory) {
            onCreatedRelatedUserstory();
          }
          return _this.loadRelatedUserstories();
        };
      })(this);
      epicId = this.epic.get('id');
      return this.rs.epics.bulkCreateRelatedUserStories(epicId, selectedProjectId, userstoriesText).then(onSuccess, onError);
    };

    return RelatedUserstoriesCreateController;

  })();

  module.controller("RelatedUserstoriesCreateCtrl", RelatedUserstoriesCreateController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/related-userstories/related-userstories-create/related-userstories-create.directive.coffee
 */

(function() {
  var RelatedUserstoriesCreateDirective, debounceLeading, module;

  module = angular.module('taigaEpics');

  debounceLeading = this.taiga.debounceLeading;

  RelatedUserstoriesCreateDirective = function(lightboxService1) {
    var link;
    this.lightboxService = lightboxService1;
    link = function(scope, el, attrs, ctrl) {
      var existingUserstoryForm, newUserstoryForm;
      newUserstoryForm = el.find(".new-user-story-form").checksley();
      existingUserstoryForm = el.find(".existing-user-story-form").checksley();
      ctrl.validateNewUserstoryForm = (function(_this) {
        return function() {
          return newUserstoryForm.validate();
        };
      })(this);
      ctrl.setNewUserstoryFormErrors = (function(_this) {
        return function(errors) {
          return newUserstoryForm.setErrors(errors);
        };
      })(this);
      ctrl.validateExistingUserstoryForm = (function(_this) {
        return function() {
          return existingUserstoryForm.validate();
        };
      })(this);
      ctrl.setExistingUserstoryFormErrors = (function(_this) {
        return function(errors) {
          return existingUserstoryForm.setErrors(errors);
        };
      })(this);
      scope.showLightbox = function(selectedProjectId) {
        ctrl.loadProjects();
        return scope.selectProject(selectedProjectId).then((function(_this) {
          return function() {
            return lightboxService.open(el.find(".lightbox-create-related-user-stories"));
          };
        })(this));
      };
      scope.closeLightbox = function() {
        scope.selectedUserstory = null;
        scope.searchUserstory = "";
        scope.relatedUserstoriesText = "";
        return lightboxService.close(el.find(".lightbox-create-related-user-stories"));
      };
      scope.$watch('vm.project', function(project) {
        if (project != null) {
          return scope.selectedProject = project.get('id');
        }
      });
      scope.selectProject = function(selectedProjectId) {
        scope.selectedUserstory = null;
        scope.searchUserstory = "";
        return ctrl.filterUss(selectedProjectId, scope.searchUserstory);
      };
      return scope.onUpdateSearchUserstory = debounceLeading(300, function() {
        scope.selectedUserstory = null;
        return ctrl.filterUss(scope.selectedProject, scope.searchUserstory);
      });
    };
    return {
      link: link,
      templateUrl: "epics/related-userstories/related-userstories-create/related-userstories-create.html",
      controller: "RelatedUserstoriesCreateCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        showCreateRelatedUserstoriesLightbox: "=",
        project: "=",
        epic: "=",
        epicUserstories: "=",
        loadRelatedUserstories: "&"
      }
    };
  };

  RelatedUserstoriesCreateDirective.$inject = ["lightboxService"];

  module.directive("tgRelatedUserstoriesCreate", RelatedUserstoriesCreateDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/related-userstories/related-userstories-sortable/related-userstories-sortable.directive.coffee
 */

(function() {
  var RelatedUserstoriesSortableDirective, module;

  module = angular.module('taigaEpics');

  RelatedUserstoriesSortableDirective = function($parse, projectService) {
    var link;
    link = function(scope, el, attrs) {
      var callback, drake, scroll;
      if (!projectService.hasPermission("modify_epic")) {
        return;
      }
      callback = $parse(attrs.tgRelatedUserstoriesSortable);
      drake = dragula([el[0]], {
        copySortSource: false,
        copy: false,
        mirrorContainer: el[0],
        moves: function(item) {
          return $(item).is('tg-related-userstory-row');
        }
      });
      drake.on('dragend', function(item) {
        var itemEl, newIndex, us;
        itemEl = $(item);
        us = itemEl.scope().us;
        newIndex = itemEl.index();
        return scope.$apply(function() {
          return callback(scope, {
            us: us,
            newIndex: newIndex
          });
        });
      });
      scroll = autoScroll(window, {
        margin: 20,
        pixels: 30,
        scrollWhenOutside: true,
        autoScroll: function() {
          return this.down && drake.dragging;
        }
      });
      return scope.$on("$destroy", function() {
        el.off();
        return drake.destroy();
      });
    };
    return {
      link: link
    };
  };

  RelatedUserstoriesSortableDirective.$inject = ["$parse", "tgProjectService"];

  module.directive("tgRelatedUserstoriesSortable", RelatedUserstoriesSortableDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/related-userstories/related-userstories.directive.coffee
 */

(function() {
  var RelatedUserStoriesDirective, module;

  module = angular.module('taigaEpics');

  RelatedUserStoriesDirective = function() {
    return {
      templateUrl: "epics/related-userstories/related-userstories.html",
      controller: "RelatedUserStoriesCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        userstories: '=',
        project: '=',
        epic: '='
      }
    };
  };

  RelatedUserStoriesDirective.$inject = [];

  module.directive("tgRelatedUserstories", RelatedUserStoriesDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/related-userstories/related-userstory-row/related-userstory-row.controller.coffee
 */

(function() {
  var RelatedUserstoryRowController, module;

  module = angular.module("taigaEpics");

  RelatedUserstoryRowController = (function() {
    RelatedUserstoryRowController.$inject = ["tgAvatarService", "$translate", "$tgConfirm", "tgResources"];

    function RelatedUserstoryRowController(avatarService, translate, confirm, rs) {
      this.avatarService = avatarService;
      this.translate = translate;
      this.confirm = confirm;
      this.rs = rs;
    }

    RelatedUserstoryRowController.prototype.setAvatarData = function() {
      var member;
      member = this.userstory.get('assigned_to_extra_info');
      return this.avatar = this.avatarService.getAvatar(member);
    };

    RelatedUserstoryRowController.prototype.getAssignedToFullNameDisplay = function() {
      if (this.userstory.get('assigned_to')) {
        return this.userstory.getIn(['assigned_to_extra_info', 'full_name_display']);
      }
      return this.translate.instant("COMMON.ASSIGNED_TO.NOT_ASSIGNED");
    };

    RelatedUserstoryRowController.prototype.onDeleteRelatedUserstory = function() {
      var message, title;
      title = this.translate.instant("LIGHTBOX.REMOVE_RELATIONSHIP_WITH_EPIC.TITLE");
      message = this.translate.instant("LIGHTBOX.REMOVE_RELATIONSHIP_WITH_EPIC.MESSAGE", {
        epicSubject: this.epic.get('subject')
      });
      return this.confirm.ask(title, null, message).then((function(_this) {
        return function(askResponse) {
          var epicId, onError, onSuccess, userstoryId;
          onError = function() {
            message = _this.translate.instant('EPIC.ERROR_UNLINK_RELATED_USERSTORY', {
              errorMessage: message
            });
            _this.confirm.notify("error", null, message);
            return askResponse.finish(false);
          };
          onSuccess = function() {
            _this.loadRelatedUserstories();
            return askResponse.finish();
          };
          epicId = _this.epic.get('id');
          userstoryId = _this.userstory.get('id');
          return _this.rs.epics.deleteRelatedUserstory(epicId, userstoryId).then(onSuccess, onError);
        };
      })(this));
    };

    return RelatedUserstoryRowController;

  })();

  module.controller("RelatedUserstoryRowCtrl", RelatedUserstoryRowController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: epics/related-userstories/related-userstory-row/related-userstory-row.directive.coffee
 */

(function() {
  var RelatedUserstoryRowDirective, module;

  module = angular.module('taigaEpics');

  RelatedUserstoryRowDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return ctrl.setAvatarData();
    };
    return {
      link: link,
      templateUrl: "epics/related-userstories/related-userstory-row/related-userstory-row.html",
      controller: "RelatedUserstoryRowCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        userstory: '=',
        epic: '=',
        project: '=',
        loadRelatedUserstories: "&"
      }
    };
  };

  RelatedUserstoryRowDirective.$inject = [];

  module.directive("tgRelatedUserstoryRow", RelatedUserstoryRowDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: external-apps/external-app.controller.coffee
 */

(function() {
  var ExternalAppController, taiga,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  ExternalAppController = (function(superClass) {
    extend(ExternalAppController, superClass);

    ExternalAppController.$inject = ["$routeParams", "tgExternalAppsService", "$window", "tgCurrentUserService", "$location", "$tgNavUrls", "tgXhrErrorService", "tgLoader"];

    function ExternalAppController(routeParams, externalAppsService, window, currentUserService, location, navUrls, xhrError, loader) {
      var loginUrl, nextUrl;
      this.routeParams = routeParams;
      this.externalAppsService = externalAppsService;
      this.window = window;
      this.currentUserService = currentUserService;
      this.location = location;
      this.navUrls = navUrls;
      this.xhrError = xhrError;
      this.loader = loader;
      this.createApplicationToken = bind(this.createApplicationToken, this);
      this._getApplicationToken = bind(this._getApplicationToken, this);
      this._redirect = bind(this._redirect, this);
      this.loader.start(false);
      this._applicationId = this.routeParams.application;
      this._state = this.routeParams.state;
      this._getApplicationToken();
      this._user = this.currentUserService.getUser();
      this._application = null;
      nextUrl = encodeURIComponent(this.location.url());
      loginUrl = this.navUrls.resolve("login");
      this.loginWithAnotherUserUrl = loginUrl + "?next=" + nextUrl + "&force_login=1";
      taiga.defineImmutableProperty(this, "user", (function(_this) {
        return function() {
          return _this._user;
        };
      })(this));
      taiga.defineImmutableProperty(this, "application", (function(_this) {
        return function() {
          return _this._application;
        };
      })(this));
    }

    ExternalAppController.prototype._redirect = function(applicationToken) {
      var nextUrl;
      nextUrl = applicationToken.get("next_url");
      return this.window.open(nextUrl, "_self");
    };

    ExternalAppController.prototype._getApplicationToken = function() {
      return this.externalAppsService.getApplicationToken(this._applicationId, this._state).then((function(_this) {
        return function(data) {
          _this._application = data.get("application");
          if (data.get("auth_code")) {
            return _this._redirect(data);
          } else {
            return _this.loader.pageLoaded();
          }
        };
      })(this))["catch"]((function(_this) {
        return function(xhr) {
          _this.loader.pageLoaded();
          return _this.xhrError.response(xhr);
        };
      })(this));
    };

    ExternalAppController.prototype.cancel = function() {
      return this.window.history.back();
    };

    ExternalAppController.prototype.createApplicationToken = function() {
      return this.externalAppsService.authorizeApplicationToken(this._applicationId, this._state).then((function(_this) {
        return function(data) {
          return _this._redirect(data);
        };
      })(this))["catch"]((function(_this) {
        return function(xhr) {
          return _this.xhrError.response(xhr);
        };
      })(this));
    };

    return ExternalAppController;

  })(taiga.Controller);

  angular.module("taigaExternalApps").controller("ExternalApp", ExternalAppController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: external-apps/external-app.service.coffee
 */

(function() {
  var ExternalAppsService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ExternalAppsService = (function(superClass) {
    extend(ExternalAppsService, superClass);

    ExternalAppsService.$inject = ["tgResources"];

    function ExternalAppsService(rs) {
      this.rs = rs;
    }

    ExternalAppsService.prototype.getApplicationToken = function(applicationId, state) {
      return this.rs.externalapps.getApplicationToken(applicationId, state);
    };

    ExternalAppsService.prototype.authorizeApplicationToken = function(applicationId, state) {
      return this.rs.externalapps.authorizeApplicationToken(applicationId, state);
    };

    return ExternalAppsService;

  })(taiga.Service);

  angular.module("taigaExternalApps").service("tgExternalAppsService", ExternalAppsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: feedback/feedback.service.coffee
 */

(function() {
  var FeedbackService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  FeedbackService = (function(superClass) {
    extend(FeedbackService, superClass);

    FeedbackService.$inject = ["tgLightboxFactory"];

    function FeedbackService(lightboxFactory) {
      this.lightboxFactory = lightboxFactory;
    }

    FeedbackService.prototype.sendFeedback = function() {
      return this.lightboxFactory.create("tg-lb-feedback", {
        "class": "lightbox lightbox-feedback lightbox-generic-form"
      });
    };

    return FeedbackService;

  })(taiga.Service);

  angular.module("taigaFeedback").service("tgFeedbackService", FeedbackService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/activity/activity.service.coffee
 */

(function() {
  var ActivityService, taiga;

  taiga = this.taiga;

  ActivityService = (function() {
    ActivityService.$inject = ['tgResources', 'tgXhrErrorService'];

    function ActivityService(rs, xhrError) {
      this.rs = rs;
      this.xhrError = xhrError;
      this._contentType = null;
      this._objectId = null;
      this.clear();
    }

    ActivityService.prototype.clear = function() {
      this.page = 1;
      this.loadingEntries = false;
      this.disablePagination = false;
      this.entries = Immutable.List();
      return this.count = null;
    };

    ActivityService.prototype.fetchEntries = function(reset) {
      if (reset == null) {
        reset = false;
      }
      if (reset) {
        this.page = 1;
      }
      this.loadingEntries = true;
      this.disablePagination = true;
      if (!this._contentType || !this._objectId) {
        return;
      }
      return this.rs.history.getHistory('activity', this._contentType, this._objectId, this.page).then((function(_this) {
        return function(result) {
          if (reset) {
            _this.clear();
            _this.entries = result.list;
          } else {
            _this.entries = _this.entries.concat(result.list);
          }
          _this.loadingEntries = false;
          _this.disablePagination = !result.headers('x-pagination-next');
          _this.count = result.headers('x-pagination-count');
          return _this.entries;
        };
      })(this))["catch"]((function(_this) {
        return function(xhr) {
          return _this.xhrError.response(_this.entries);
        };
      })(this));
    };

    ActivityService.prototype.nextPage = function(historyType) {
      if (historyType == null) {
        historyType = 'comment';
      }
      this.page++;
      return this.fetchEntries();
    };

    ActivityService.prototype.init = function(contentType, objectId) {
      this._contentType = contentType;
      this._objectId = objectId;
      return this.clear();
    };

    return ActivityService;

  })();

  angular.module('taigaHistory').service('tgActivityService', ActivityService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/comments/comment.controller.coffee
 */

(function() {
  var CommentController, module;

  module = angular.module("taigaHistory");

  CommentController = (function() {
    CommentController.$inject = ["tgCurrentUserService", "tgCheckPermissionsService", "tgLightboxFactory"];

    function CommentController(currentUserService, permissionService, lightboxFactory) {
      this.currentUserService = currentUserService;
      this.permissionService = permissionService;
      this.lightboxFactory = lightboxFactory;
      this.hiddenDeletedComment = true;
    }

    CommentController.prototype.showDeletedComment = function() {
      return this.hiddenDeletedComment = false;
    };

    CommentController.prototype.hideDeletedComment = function() {
      return this.hiddenDeletedComment = true;
    };

    CommentController.prototype.checkCancelComment = function(event) {
      if (event.keyCode === 27) {
        return this.onEditMode({
          commentId: this.comment.id
        });
      }
    };

    CommentController.prototype.canEditDeleteComment = function() {
      if (this.currentUserService.getUser()) {
        this.user = this.currentUserService.getUser();
        return this.user.get('id') === this.comment.user.pk || this.permissionService.check('modify_project');
      }
    };

    CommentController.prototype.saveComment = function(text, cb) {
      return this.onEditComment({
        commentId: this.comment.id,
        commentData: text,
        callback: cb
      });
    };

    CommentController.prototype.displayCommentHistory = function() {
      return this.lightboxFactory.create('tg-lb-display-historic', {
        "class": "lightbox lightbox-display-historic",
        "comment": "comment",
        "name": "name",
        "object": "object"
      }, {
        "comment": this.comment,
        "name": this.name,
        "object": this.object
      });
    };

    return CommentController;

  })();

  module.controller("CommentCtrl", CommentController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/comments/comment.directive.coffee
 */

(function() {
  var CommentDirective, module;

  module = angular.module('taigaHistory');

  CommentDirective = function() {
    return {
      scope: {
        name: "@",
        object: "@",
        comment: "<",
        type: "<",
        loading: "<",
        editing: "<",
        deleting: "<",
        objectId: "<",
        editMode: "<",
        onEditMode: "&",
        onDeleteComment: "&",
        onRestoreDeletedComment: "&",
        onEditComment: "&"
      },
      templateUrl: "history/comments/comment.html",
      bindToController: true,
      controller: 'CommentCtrl',
      controllerAs: "vm"
    };
  };

  module.directive("tgComment", CommentDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/comments/comments.controller.coffee
 */

(function() {
  var CommentsController, module;

  module = angular.module("taigaHistory");

  CommentsController = (function() {
    CommentsController.$inject = [];

    function CommentsController() {}

    CommentsController.prototype.initializePermissions = function() {
      return this.canAddCommentPermission = 'comment_' + this.name;
    };

    return CommentsController;

  })();

  module.controller("CommentsCtrl", CommentsController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/comments/comments.directive.coffee
 */

(function() {
  var CommentsDirective, module;

  module = angular.module('taigaHistory');

  CommentsDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return ctrl.initializePermissions();
    };
    return {
      scope: {
        type: "<",
        name: "@",
        object: "@",
        comments: "<",
        onEditMode: "&",
        onDeleteComment: "&",
        onRestoreDeletedComment: "&",
        onAddComment: "&",
        onEditComment: "&",
        editMode: "<",
        loading: "<",
        deleting: "<",
        editing: "<",
        projectId: "=",
        reverse: "="
      },
      templateUrl: "history/comments/comments.html",
      bindToController: true,
      controller: 'CommentsCtrl',
      controllerAs: "vm",
      link: link
    };
  };

  module.directive("tgComments", CommentsDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history-lightbox/comment-history-lightbox.controller.coffee
 */

(function() {
  var LightboxDisplayHistoricController, module;

  module = angular.module("taigaHistory");

  LightboxDisplayHistoricController = (function() {
    LightboxDisplayHistoricController.$inject = ["$tgResources"];

    function LightboxDisplayHistoricController(rs) {
      this.rs = rs;
    }

    LightboxDisplayHistoricController.prototype._loadHistoric = function() {
      var activityId, objectId, type;
      type = this.name;
      objectId = this.object;
      activityId = this.comment.id;
      return this.rs.history.getCommentHistory(type, objectId, activityId).then((function(_this) {
        return function(data) {
          return _this.commentHistoryEntries = data;
        };
      })(this));
    };

    return LightboxDisplayHistoricController;

  })();

  module.controller("LightboxDisplayHistoricCtrl", LightboxDisplayHistoricController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history-lightbox/comment-history-lightbox.directive.coffee
 */

(function() {
  var LightboxDisplayHistoricDirective;

  LightboxDisplayHistoricDirective = function(lightboxService) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      ctrl._loadHistoric();
      return lightboxService.open(el);
    };
    return {
      scope: {},
      bindToController: {
        name: '=',
        object: '=',
        comment: '='
      },
      templateUrl: "history/history-lightbox/comment-history-lightbox.html",
      controller: "LightboxDisplayHistoricCtrl",
      controllerAs: "vm",
      link: link
    };
  };

  LightboxDisplayHistoricDirective.$inject = ["lightboxService"];

  angular.module('taigaHistory').directive("tgLbDisplayHistoric", LightboxDisplayHistoricDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history-lightbox/history-entry.directive.coffee
 */

(function() {
  var HistoryEntryDirective;

  HistoryEntryDirective = function() {
    return {
      scope: {
        entry: "<"
      },
      templateUrl: "history/history-lightbox/history-entry.html"
    };
  };

  angular.module('taigaHistory').directive("tgHistoryEntry", HistoryEntryDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history-tabs/history-tabs.directive.coffee
 */

(function() {
  var HistoryTabsDirective, module;

  module = angular.module('taigaHistory');

  HistoryTabsDirective = function() {
    return {
      templateUrl: "history/history-tabs/history-tabs.html",
      scope: {
        showCommentTab: "&",
        showActivityTab: "&",
        onActiveComments: "&",
        onActiveActivities: "&",
        onOrderComments: "&",
        activeTab: "<",
        commentsNum: "<",
        activitiesNum: "<",
        onReverse: "<"
      }
    };
  };

  module.directive("tgHistoryTabs", HistoryTabsDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history.controller.coffee
 */

(function() {
  var HistorySectionController, module;

  module = angular.module("taigaHistory");

  HistorySectionController = (function() {
    HistorySectionController.$inject = ["$tgResources", "$tgRepo", "$tgStorage", "tgProjectService", "tgActivityService"];

    function HistorySectionController(rs, repo, storage, projectService, activityService) {
      this.rs = rs;
      this.repo = repo;
      this.storage = storage;
      this.projectService = projectService;
      this.activityService = activityService;
      this.editing = null;
      this.deleting = null;
      this.editMode = {};
      this.viewComments = true;
      this.reverse = this.storage.get("orderComments");
      taiga.defineImmutableProperty(this, 'disabledActivityPagination', (function(_this) {
        return function() {
          return _this.activityService.disablePagination;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'loadingActivity', (function(_this) {
        return function() {
          return _this.activityService.loading;
        };
      })(this));
    }

    HistorySectionController.prototype._loadHistory = function() {
      this._loadComments();
      return this._loadActivity();
    };

    HistorySectionController.prototype._loadActivity = function() {
      this.activityService.init(this.name, this.id);
      return this.activityService.fetchEntries().then((function(_this) {
        return function(response) {
          _this.activitiesNum = _this.activityService.count;
          return _this.activities = response.toJS();
        };
      })(this));
    };

    HistorySectionController.prototype._loadComments = function() {
      return this.rs.history.get(this.name, this.id, 'comment').then((function(_this) {
        return function(comments) {
          _this.comments = _.filter(comments, function(item) {
            return item.comment !== "";
          });
          if (_this.reverse) {
            _this.comments - _.reverse(_this.comments);
          }
          return _this.commentsNum = _this.comments.length;
        };
      })(this));
    };

    HistorySectionController.prototype.nextActivityPage = function() {
      return this.activityService.nextPage().then((function(_this) {
        return function(response) {
          return _this.activities = response.toJS();
        };
      })(this));
    };

    HistorySectionController.prototype.showHistorySection = function() {
      return this.showCommentTab() || this.showActivityTab();
    };

    HistorySectionController.prototype.showCommentTab = function() {
      return this.commentsNum > 0 || this.projectService.hasPermission("comment_" + this.name);
    };

    HistorySectionController.prototype.showActivityTab = function() {
      return this.activitiesNum > 0;
    };

    HistorySectionController.prototype.toggleEditMode = function(commentId) {
      return this.editMode[commentId] = !this.editMode[commentId];
    };

    HistorySectionController.prototype.onActiveHistoryTab = function(active) {
      return this.viewComments = active;
    };

    HistorySectionController.prototype.deleteComment = function(commentId) {
      var activityId, objectId, type;
      type = this.name;
      objectId = this.id;
      activityId = commentId;
      this.deleting = commentId;
      return this.rs.history.deleteComment(type, objectId, activityId).then((function(_this) {
        return function() {
          _this._loadComments();
          return _this.deleting = null;
        };
      })(this));
    };

    HistorySectionController.prototype.editComment = function(commentId, comment) {
      var activityId, objectId, type;
      type = this.name;
      objectId = this.id;
      activityId = commentId;
      this.editing = commentId;
      return this.rs.history.editComment(type, objectId, activityId, comment).then((function(_this) {
        return function() {
          _this._loadComments();
          _this.toggleEditMode(commentId);
          return _this.editing = null;
        };
      })(this));
    };

    HistorySectionController.prototype.restoreDeletedComment = function(commentId) {
      var activityId, objectId, type;
      type = this.name;
      objectId = this.id;
      activityId = commentId;
      this.editing = commentId;
      return this.rs.history.undeleteComment(type, objectId, activityId).then((function(_this) {
        return function() {
          _this._loadComments();
          return _this.editing = null;
        };
      })(this));
    };

    HistorySectionController.prototype.addComment = function() {
      this.editMode = {};
      this.editing = null;
      return this._loadComments();
    };

    HistorySectionController.prototype.onOrderComments = function() {
      this.reverse = !this.reverse;
      this.storage.set("orderComments", this.reverse);
      return this._loadComments();
    };

    return HistorySectionController;

  })();

  module.controller("HistorySection", HistorySectionController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history.directive.coffee
 */

(function() {
  var HistorySectionDirective, bindOnce, module;

  module = angular.module('taigaHistory');

  bindOnce = this.taiga.bindOnce;

  HistorySectionDirective = function() {
    var link;
    link = function(scope, el, attr, ctrl) {
      scope.$on("object:updated", function() {
        return ctrl._loadActivity();
      });
      return scope.$watch('vm.id', function(value) {
        return ctrl._loadHistory();
      });
    };
    return {
      link: link,
      templateUrl: "history/history.html",
      controller: "HistorySection",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        type: "=",
        name: "@",
        id: "=",
        projectId: "="
      }
    };
  };

  HistorySectionDirective.$inject = [];

  module.directive("tgHistorySection", HistorySectionDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history/history-diff.controller.coffee
 */

(function() {
  var ActivitiesDiffController, module;

  module = angular.module("taigaHistory");

  ActivitiesDiffController = (function() {
    ActivitiesDiffController.$inject = [];

    function ActivitiesDiffController() {}

    ActivitiesDiffController.prototype.diffTags = function() {
      var diff;
      if (this.type === 'tags') {
        this.diffRemoveTags = _.difference(this.diff[0], this.diff[1]).toString();
        return this.diffAddTags = _.difference(this.diff[1], this.diff[0]).toString();
      } else if (this.type === 'promoted_to') {
        diff = _.difference(this.diff[1], this.diff[0]);
        return this.promotedTo = _.filter(this.model.generated_user_stories, (function(_this) {
          return function(x) {
            return _.includes(diff, x.id);
          };
        })(this));
      }
    };

    return ActivitiesDiffController;

  })();

  module.controller("ActivitiesDiffCtrl", ActivitiesDiffController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history/history-diff.directive.coffee
 */

(function() {
  var HistoryDiffDirective, module;

  module = angular.module('taigaHistory');

  HistoryDiffDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return ctrl.diffTags();
    };
    return {
      scope: {
        model: "<",
        type: "<",
        diff: "<"
      },
      templateUrl: "history/history/history-diff.html",
      controller: "ActivitiesDiffCtrl",
      controllerAs: 'vm',
      bindToController: true,
      link: link
    };
  };

  module.directive("tgHistoryDiff", HistoryDiffDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: history/history/history.directive.coffee
 */

(function() {
  var HistoryDirective, module;

  module = angular.module('taigaHistory');

  HistoryDirective = function() {
    var link;
    link = function(scope, el, attrs) {};
    return {
      scope: {
        activities: "<",
        model: "<"
      },
      templateUrl: "history/history/history.html",
      link: link
    };
  };

  module.directive("tgHistory", HistoryDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: home/duties/duty.directive.coffee
 */

(function() {
  var DutyDirective;

  DutyDirective = function(navurls, $translate) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      scope.vm = {};
      scope.vm.duty = scope.duty;
      scope.vm.type = scope.type;
      scope.vm.isHidden = scope.isHidden;
      scope.vm.getDutyType = function() {
        if (scope.vm.duty) {
          if (scope.vm.duty.get('_name') === "epics") {
            return $translate.instant("COMMON.EPIC");
          }
          if (scope.vm.duty.get('_name') === "userstories") {
            return $translate.instant("COMMON.USER_STORY");
          }
          if (scope.vm.duty.get('_name') === "tasks") {
            return $translate.instant("COMMON.TASK");
          }
          if (scope.vm.duty.get('_name') === "issues") {
            return $translate.instant("COMMON.ISSUE");
          }
        }
      };
      return el.on("click", ".button-hide", function(event) {
        event.preventDefault();
        el.remove();
        return scope.$emit('duty:toggle-hidden', scope.vm.duty, scope.vm.type);
      });
    };
    return {
      templateUrl: "home/duties/duty.html",
      scope: {
        "duty": "=tgDuty",
        "isHidden": "=",
        "type": "@"
      },
      link: link
    };
  };

  DutyDirective.$inject = ["$tgNavUrls", "$translate"];

  angular.module("taigaHome").directive("tgDuty", DutyDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: home/home.controller.coffee
 */

(function() {
  var HomeController;

  HomeController = (function() {
    HomeController.$inject = ["tgCurrentUserService", "$location", "$tgNavUrls"];

    function HomeController(currentUserService, location, navUrls) {
      this.currentUserService = currentUserService;
      this.location = location;
      this.navUrls = navUrls;
      if (!this.currentUserService.getUser()) {
        this.location.path(this.navUrls.resolve("discover"));
      }
    }

    return HomeController;

  })();

  angular.module("taigaHome").controller("Home", HomeController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: home/home.service.coffee
 */

(function() {
  var HomeService, groupBy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  groupBy = this.taiga.groupBy;

  HomeService = (function(superClass) {
    extend(HomeService, superClass);

    HomeService.$inject = ["$tgNavUrls", "tgResources", "tgProjectsService"];

    function HomeService(navurls, rs, projectsService) {
      this.navurls = navurls;
      this.rs = rs;
      this.projectsService = projectsService;
    }

    HomeService.prototype._attachProjectInfoToWorkInProgress = function(workInProgress, projectsById) {
      var _attachProjectInfoToDuty, _duties, _getValidDutiesAndAttachProjectInfo, assignedTo, watching;
      _attachProjectInfoToDuty = (function(_this) {
        return function(duty, objType) {
          var ctx, project, url;
          project = projectsById.get(String(duty.get('project')));
          ctx = {
            project: project.get('slug'),
            ref: duty.get('ref')
          };
          url = _this.navurls.resolve("project-" + objType + "-detail", ctx);
          duty = duty.set('url', url);
          duty = duty.set('project', project);
          duty = duty.set("_name", objType);
          return duty;
        };
      })(this);
      _getValidDutiesAndAttachProjectInfo = function(duties, dutyType) {
        duties = duties.filter(function(duty) {
          return projectsById.get(String(duty.get('project')));
        });
        duties = duties.map(function(duty) {
          return _attachProjectInfoToDuty(duty, dutyType);
        });
        return duties;
      };
      assignedTo = workInProgress.get("assignedTo");
      if (assignedTo.get("epics")) {
        _duties = _getValidDutiesAndAttachProjectInfo(assignedTo.get("epics"), "epics");
        assignedTo = assignedTo.set("epics", _duties);
      }
      if (assignedTo.get("userStories")) {
        _duties = _getValidDutiesAndAttachProjectInfo(assignedTo.get("userStories"), "userstories");
        assignedTo = assignedTo.set("userStories", _duties);
      }
      if (assignedTo.get("tasks")) {
        _duties = _getValidDutiesAndAttachProjectInfo(assignedTo.get("tasks"), "tasks");
        assignedTo = assignedTo.set("tasks", _duties);
      }
      if (assignedTo.get("issues")) {
        _duties = _getValidDutiesAndAttachProjectInfo(assignedTo.get("issues"), "issues");
        assignedTo = assignedTo.set("issues", _duties);
      }
      watching = workInProgress.get("watching");
      if (watching.get("epics")) {
        _duties = _getValidDutiesAndAttachProjectInfo(watching.get("epics"), "epics");
        watching = watching.set("epics", _duties);
      }
      if (watching.get("userStories")) {
        _duties = _getValidDutiesAndAttachProjectInfo(watching.get("userStories"), "userstories");
        watching = watching.set("userStories", _duties);
      }
      if (watching.get("tasks")) {
        _duties = _getValidDutiesAndAttachProjectInfo(watching.get("tasks"), "tasks");
        watching = watching.set("tasks", _duties);
      }
      if (watching.get("issues")) {
        _duties = _getValidDutiesAndAttachProjectInfo(watching.get("issues"), "issues");
        watching = watching.set("issues", _duties);
      }
      workInProgress = workInProgress.set("assignedTo", assignedTo);
      return workInProgress = workInProgress.set("watching", watching);
    };

    HomeService.prototype.getWorkInProgress = function(userId) {
      var assignedEpicsPromise, assignedIssuesPromise, assignedTasksPromise, assignedTo, assignedUserStoriesPromise, params_epics, params_issues, params_tasks, params_uss, projectsById, projectsPromise, watching, watchingEpicsPromise, watchingIssuesPromise, watchingTasksPromise, watchingUserStoriesPromise, workInProgress;
      projectsById = Immutable.Map();
      projectsPromise = this.projectsService.getListProjectsByUserId(userId).then(function(projects) {
        return projectsById = Immutable.fromJS(groupBy(projects.toJS(), function(p) {
          return p.id;
        }));
      });
      assignedTo = Immutable.Map();
      params_epics = {
        status__is_closed: false,
        assigned_to: userId
      };
      params_uss = {
        is_closed: false,
        assigned_users: userId,
        dashboard: true
      };
      params_tasks = {
        status__is_closed: false,
        assigned_to: userId
      };
      params_issues = {
        status__is_closed: false,
        assigned_to: userId
      };
      assignedEpicsPromise = this.rs.epics.listInAllProjects(params_epics).then(function(epics) {
        return assignedTo = assignedTo.set("epics", epics);
      });
      assignedUserStoriesPromise = this.rs.userstories.listInAllProjects(params_uss).then(function(userstories) {
        return assignedTo = assignedTo.set("userStories", userstories);
      });
      assignedTasksPromise = this.rs.tasks.listInAllProjects(params_tasks).then(function(tasks) {
        return assignedTo = assignedTo.set("tasks", tasks);
      });
      assignedIssuesPromise = this.rs.issues.listInAllProjects(params_issues).then(function(issues) {
        return assignedTo = assignedTo.set("issues", issues);
      });
      params_epics = {
        status__is_closed: false,
        watchers: userId
      };
      params_uss = {
        is_closed: false,
        watchers: userId,
        dashboard: true
      };
      params_tasks = {
        status__is_closed: false,
        watchers: userId
      };
      params_issues = {
        status__is_closed: false,
        watchers: userId
      };
      watching = Immutable.Map();
      watchingEpicsPromise = this.rs.epics.listInAllProjects(params_epics).then(function(epics) {
        return watching = watching.set("epics", epics);
      });
      watchingUserStoriesPromise = this.rs.userstories.listInAllProjects(params_uss).then(function(userstories) {
        return watching = watching.set("userStories", userstories);
      });
      watchingTasksPromise = this.rs.tasks.listInAllProjects(params_tasks).then(function(tasks) {
        return watching = watching.set("tasks", tasks);
      });
      watchingIssuesPromise = this.rs.issues.listInAllProjects(params_issues).then(function(issues) {
        return watching = watching.set("issues", issues);
      });
      workInProgress = Immutable.Map();
      return Promise.all([projectsPromise, assignedEpicsPromise, watchingEpicsPromise, assignedUserStoriesPromise, watchingUserStoriesPromise, assignedTasksPromise, watchingTasksPromise, assignedIssuesPromise, watchingIssuesPromise]).then((function(_this) {
        return function() {
          workInProgress = workInProgress.set("assignedTo", assignedTo);
          workInProgress = workInProgress.set("watching", watching);
          workInProgress = _this._attachProjectInfoToWorkInProgress(workInProgress, projectsById);
          return workInProgress;
        };
      })(this));
    };

    return HomeService;

  })(taiga.Service);

  angular.module("taigaHome").service("tgHomeService", HomeService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: home/projects/home-project-list.directive.coffee
 */

(function() {
  var HomeProjectListDirective;

  HomeProjectListDirective = function(currentUserService) {
    var directive, link;
    link = function(scope, el, attrs, ctrl) {
      scope.vm = {};
      return taiga.defineImmutableProperty(scope.vm, "projects", function() {
        return currentUserService.projects.get("recents");
      });
    };
    directive = {
      templateUrl: "home/projects/home-project-list.html",
      scope: {},
      link: link
    };
    return directive;
  };

  HomeProjectListDirective.$inject = ["tgCurrentUserService"];

  angular.module("taigaHome").directive("tgHomeProjectList", HomeProjectListDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: home/working-on/working-on.controller.coffee
 */

(function() {
  var WorkingOnController;

  WorkingOnController = (function() {
    WorkingOnController.$inject = ["tgHomeService"];

    function WorkingOnController(homeService) {
      this.homeService = homeService;
      this.assignedTo = Immutable.Map();
      this.hiddenAssignedTo = [];
      this.showHiddenAssignedTo = false;
      this.watching = Immutable.Map();
      this.showHiddenWatching = false;
    }

    WorkingOnController.prototype._setAssignedTo = function(workInProgress) {
      var epics, issues, tasks, userStories;
      epics = workInProgress.get("assignedTo").get("epics");
      userStories = workInProgress.get("assignedTo").get("userStories");
      tasks = workInProgress.get("assignedTo").get("tasks");
      issues = workInProgress.get("assignedTo").get("issues");
      this.assignedTo = userStories.concat(tasks).concat(issues).concat(epics);
      if (this.assignedTo.size > 0) {
        return this.assignedTo = this.assignedTo.sortBy(function(elem) {
          return elem.get("modified_date");
        }).reverse();
      }
    };

    WorkingOnController.prototype._setWatching = function(workInProgress) {
      var epics, issues, tasks, userStories;
      epics = workInProgress.get("watching").get("epics");
      userStories = workInProgress.get("watching").get("userStories");
      tasks = workInProgress.get("watching").get("tasks");
      issues = workInProgress.get("watching").get("issues");
      this.watching = userStories.concat(tasks).concat(issues).concat(epics);
      if (this.watching.size > 0) {
        return this.watching = this.watching.sortBy(function(elem) {
          return elem.get("modified_date");
        }).reverse();
      }
    };

    WorkingOnController.prototype.getWorkInProgress = function(userId) {
      return this.homeService.getWorkInProgress(userId).then((function(_this) {
        return function(workInProgress) {
          _this._setAssignedTo(workInProgress);
          return _this._setWatching(workInProgress);
        };
      })(this));
    };

    return WorkingOnController;

  })();

  angular.module("taigaHome").controller("WorkingOn", WorkingOnController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: home/working-on/working-on.directive.coffee
 */

(function() {
  var WorkingOnDirective, generateHash, taiga,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  taiga = this.taiga;

  generateHash = this.taiga.generateHash;

  WorkingOnDirective = function(homeService, currentUserService, storage) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      var getHiddenDuties, getShowHiddenDuties, i, len, slot, slots, toggleDutyHidden, updateHiddenDuties, updateShowHiddenDuties, user, userId;
      updateShowHiddenDuties = function(slot) {
        var hash;
        hash = generateHash(['ShowHiddenDashboardDuties', slot]);
        return storage.set(hash, scope.showHiddenDuties[slot]);
      };
      getShowHiddenDuties = function(slot) {
        var hash;
        hash = generateHash(['ShowHiddenDashboardDuties', slot]);
        return storage.get(hash) || false;
      };
      updateHiddenDuties = function(slot) {
        var hash;
        hash = generateHash(['HiddenDashboardDuties', slot]);
        return storage.set(hash, scope.hiddenDuties[slot]);
      };
      getHiddenDuties = function(slot) {
        var hash;
        hash = generateHash(['HiddenDashboardDuties', slot]);
        return storage.get(hash) || [];
      };
      toggleDutyHidden = function(duty, slot) {
        var ref;
        if (ref = duty.get('id'), indexOf.call(scope.hiddenDuties[slot], ref) >= 0) {
          scope.hiddenDuties[slot].splice(scope.hiddenDuties[slot].indexOf(duty.get('id')), 1);
        } else {
          scope.hiddenDuties[slot].push(duty.get('id'));
        }
        updateHiddenDuties(slot);
        return scope.$apply();
      };
      user = currentUserService.getUser();
      if (!user) {
        return;
      }
      userId = user.get("id");
      ctrl.getWorkInProgress(userId);
      slots = ['working-on', 'watching'];
      scope.hiddenDuties = {};
      scope.showHiddenDuties = {};
      scope.toggleShowHiddenDuties = function(slot) {
        if (!(indexOf.call(slots, slot) >= 0)) {
          return console.error("Invalid duties slot `" + slot + "`");
        }
        scope.showHiddenDuties[slot] = !scope.showHiddenDuties[slot];
        return updateShowHiddenDuties(slot);
      };
      for (i = 0, len = slots.length; i < len; i++) {
        slot = slots[i];
        scope.hiddenDuties[slot] = getHiddenDuties(slot);
        scope.showHiddenDuties[slot] = getShowHiddenDuties(slot);
      }
      return scope.$on("duty:toggle-hidden", (function(_this) {
        return function(event, duty, slot) {
          if (!(indexOf.call(slots, slot) >= 0)) {
            return console.error("Invalid duties slot `" + slot + "`");
          }
          return toggleDutyHidden(duty, slot);
        };
      })(this));
    };
    return {
      controller: "WorkingOn",
      controllerAs: "vm",
      templateUrl: "home/working-on/working-on.html",
      scope: {},
      link: link
    };
  };

  WorkingOnDirective.$inject = ["tgHomeService", "tgCurrentUserService", "$tgStorage"];

  angular.module("taigaHome").directive("tgWorkingOn", WorkingOnDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: invite-members/invite-members-form/invite-members-form.controller.coffee
 */

(function() {
  var InviteMembersFormController, taiga;

  taiga = this.taiga;

  InviteMembersFormController = (function() {
    InviteMembersFormController.$inject = ["tgProjectService", "$tgResources", "lightboxService", "$tgConfirm", "$rootScope"];

    function InviteMembersFormController(projectService, rs, lightboxService, confirm, rootScope) {
      this.projectService = projectService;
      this.rs = rs;
      this.lightboxService = lightboxService;
      this.confirm = confirm;
      this.rootScope = rootScope;
      this.project = this.projectService.project;
      this.roles = this.projectService.project.get('roles');
      this.rolesValues = {};
      this.loading = false;
      this.defaultMaxInvites = 4;
    }

    InviteMembersFormController.prototype._areRolesValidated = function() {
      return Object.defineProperty(this, 'areRolesValidated', {
        get: (function(_this) {
          return function() {
            var roleIds;
            roleIds = _.filter(_.values(_this.rolesValues), function(it) {
              return it;
            });
            return roleIds.length === _this.contactsToInvite.size + _this.emailsToInvite.size;
          };
        })(this)
      });
    };

    InviteMembersFormController.prototype._checkLimitMemberships = function() {
      var pendingMembersCount;
      if (this.project.get('max_memberships') === null) {
        this.membersLimit = this.defaultMaxInvites;
      } else {
        pendingMembersCount = Math.max(this.project.get('max_memberships') - this.project.get('total_memberships'), 0);
        this.membersLimit = Math.min(pendingMembersCount, this.defaultMaxInvites);
      }
      return this.showWarningMessage = this.membersLimit < this.defaultMaxInvites;
    };

    InviteMembersFormController.prototype.sendInvites = function() {
      this.setInvitedContacts = [];
      _.forEach(this.rolesValues, (function(_this) {
        return function(key, value) {
          return _this.setInvitedContacts.push({
            'role_id': key,
            'username': value
          });
        };
      })(this));
      this.loading = true;
      return this.rs.memberships.bulkCreateMemberships(this.project.get('id'), this.setInvitedContacts, this.inviteContactsMessage).then((function(_this) {
        return function(response) {
          return _this.projectService.fetchProject().then(function() {
            _this.loading = false;
            _this.lightboxService.closeAll();
            _this.rootScope.$broadcast("membersform:new:success");
            return _this.confirm.notify('success');
          });
        };
      })(this))["catch"]((function(_this) {
        return function(response) {
          _this.loading = false;
          if (response.data._error_message) {
            return _this.confirm.notify("error", response.data._error_message);
          }
        };
      })(this));
    };

    return InviteMembersFormController;

  })();

  angular.module("taigaAdmin").controller("InviteMembersFormCtrl", InviteMembersFormController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: invite-members/invite-members-form/invite-members-form.directive.coffee
 */

(function() {
  var InviteMembersFormDirective;

  InviteMembersFormDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      ctrl._areRolesValidated();
      return ctrl._checkLimitMemberships();
    };
    return {
      scope: {},
      templateUrl: "invite-members/invite-members-form/invite-members-form.html",
      controller: "InviteMembersFormCtrl",
      controllerAs: "vm",
      bindToController: {
        contactsToInvite: '<',
        emailsToInvite: '=',
        onDisplayContactList: '&',
        onRemoveInvitedContact: '&',
        onRemoveInvitedEmail: '&',
        onSendInvites: '&'
      },
      link: link
    };
  };

  angular.module("taigaAdmin").directive("tgInviteMembersForm", InviteMembersFormDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: invite-members/lightbox-add-members.controller.coffee
 */

(function() {
  var AddMembersController, taiga;

  taiga = this.taiga;

  AddMembersController = (function() {
    AddMembersController.$inject = ["tgUserService", "tgCurrentUserService", "tgProjectService"];

    function AddMembersController(userService, currentUserService, projectService) {
      this.userService = userService;
      this.currentUserService = currentUserService;
      this.projectService = projectService;
      this.contactsToInvite = Immutable.List();
      this.emailsToInvite = Immutable.List();
      this.displayContactList = false;
    }

    AddMembersController.prototype._getContacts = function() {
      var excludeProjectId, userId;
      userId = this.currentUserService.getUser().get("id");
      excludeProjectId = this.projectService.project.get("id");
      return this.userService.getContacts(userId, excludeProjectId).then((function(_this) {
        return function(contacts) {
          return _this.contacts = contacts;
        };
      })(this));
    };

    AddMembersController.prototype._filterContacts = function(invited) {
      return this.contacts = this.contacts.filter((function(_this) {
        return function(contact) {
          return contact.get('id') !== invited.get('id');
        };
      })(this));
    };

    AddMembersController.prototype.inviteSuggested = function(contact) {
      this.contactsToInvite = this.contactsToInvite.push(contact);
      this._filterContacts(contact);
      return this.displayContactList = true;
    };

    AddMembersController.prototype.removeContact = function(invited) {
      this.contactsToInvite = this.contactsToInvite.filter((function(_this) {
        return function(contact) {
          return contact.get('id') !== invited.id;
        };
      })(this));
      invited = Immutable.fromJS(invited);
      this.contacts = this.contacts.push(invited);
      return this.testEmptyContacts();
    };

    AddMembersController.prototype.inviteEmail = function(email) {
      var emailData;
      emailData = Immutable.Map({
        'email': email
      });
      this.emailsToInvite = this.emailsToInvite.push(emailData);
      return this.displayContactList = true;
    };

    AddMembersController.prototype.removeEmail = function(invited) {
      this.emailsToInvite = this.emailsToInvite.filter((function(_this) {
        return function(email) {
          return email.get('email') !== invited.email;
        };
      })(this));
      return this.testEmptyContacts();
    };

    AddMembersController.prototype.testEmptyContacts = function() {
      if (this.emailsToInvite.size + this.contactsToInvite.size === 0) {
        return this.displayContactList = false;
      }
    };

    return AddMembersController;

  })();

  angular.module("taigaAdmin").controller("AddMembersCtrl", AddMembersController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: invite-members/lightbox-add-members.directive.coffee
 */

(function() {
  var LightboxAddMembersDirective;

  LightboxAddMembersDirective = function(lightboxService) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      lightboxService.open(el);
      return ctrl._getContacts();
    };
    return {
      scope: {},
      templateUrl: "invite-members/lightbox-add-members.html",
      controller: "AddMembersCtrl",
      controllerAs: "vm",
      link: link
    };
  };

  angular.module("taigaAdmin").directive("tgLbAddMembers", ["lightboxService", LightboxAddMembersDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: invite-members/suggest-add-members/suggest-add-members.controller.coffee
 */

(function() {
  var SuggestAddMembersController, taiga;

  taiga = this.taiga;

  SuggestAddMembersController = (function() {
    SuggestAddMembersController.$inject = [];

    function SuggestAddMembersController() {
      this.contactQuery = "";
    }

    SuggestAddMembersController.prototype.isEmail = function() {
      return taiga.isEmail(this.contactQuery);
    };

    SuggestAddMembersController.prototype.filterContacts = function() {
      return this.filteredContacts = this.contacts.filter((function(_this) {
        return function(contact) {
          return contact.get('full_name_display').toLowerCase().includes(_this.contactQuery.toLowerCase()) || contact.get('username').toLowerCase().includes(_this.contactQuery.toLowerCase());
        };
      })(this)).slice(0, 12);
    };

    SuggestAddMembersController.prototype.setInvited = function(contact) {
      return this.onInviteSuggested({
        'contact': contact
      });
    };

    return SuggestAddMembersController;

  })();

  angular.module("taigaAdmin").controller("SuggestAddMembersCtrl", SuggestAddMembersController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: invite-members/suggest-add-members/suggest-add-members.directive.coffee
 */

(function() {
  var SuggestAddMembersDirective;

  SuggestAddMembersDirective = function(lightboxService) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return scope.$watch("vm.contacts", (function(_this) {
        return function(contacts) {
          if (contacts) {
            return ctrl.filterContacts();
          }
        };
      })(this));
    };
    return {
      scope: {},
      templateUrl: "invite-members/suggest-add-members/suggest-add-members.html",
      controller: "SuggestAddMembersCtrl",
      controllerAs: "vm",
      bindToController: {
        contacts: '=',
        onInviteSuggested: '&',
        onInviteEmail: '&'
      },
      link: link
    };
  };

  angular.module("taigaAdmin").directive("tgSuggestAddMembers", ["lightboxService", SuggestAddMembersDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: navigation-bar/dropdown-notifications/dropdown-notifications.directive.coffee
 */

(function() {
  var DropdownNotificationsDirective, timeout;

  timeout = this.taiga.timeout;

  DropdownNotificationsDirective = function($rootScope, notificationsService, currentUserService) {
    var directive, link;
    link = function($scope, $el, $attrs, $ctrl) {
      $scope.notificationsList = [];
      $scope.loading = false;
      $scope.$on("notifications:loaded", function(event, total) {
        $scope.loading = false;
        if ($scope.total !== void 0 && total > $scope.total) {
          $scope.newEvent = true;
          timeout(100, function() {
            $scope.total = total;
            return $scope.$apply();
          });
          return timeout(2000, function() {
            return $scope.newEvent = false;
          });
        } else {
          return $scope.total = total;
        }
      });
      $scope.$on("notifications:loading", function() {
        return $scope.loading = true;
      });
      return $scope.setAllAsRead = function() {
        return notificationsService.setNotificationsAsRead().then(function() {
          return $rootScope.$emit("notifications:dismiss-all");
        });
      };
    };
    directive = {
      templateUrl: "navigation-bar/dropdown-notifications/dropdown-notifications.html",
      scope: {
        active: "="
      },
      link: link
    };
    return directive;
  };

  angular.module("taigaNavigationBar").directive("tgDropdownNotifications", ["$rootScope", "tgNotificationsService", "tgCurrentUserService", DropdownNotificationsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: navigation-bar/dropdown-project-list/dropdown-project-list.directive.coffee
 */

(function() {
  var DropdownProjectListDirective;

  DropdownProjectListDirective = function(rootScope, currentUserService, projectsService) {
    var directive, link;
    link = function(scope, el, attrs, ctrl) {
      var updateLinks;
      scope.vm = {};
      taiga.defineImmutableProperty(scope.vm, "projects", function() {
        return currentUserService.projects.get("recents");
      });
      scope.vm.newProject = function() {
        return projectsService.newProject();
      };
      updateLinks = function() {
        return el.find(".dropdown-project-list ul li a").data("fullUrl", "");
      };
      return rootScope.$on("dropdown-project-list:updated", updateLinks);
    };
    directive = {
      templateUrl: "navigation-bar/dropdown-project-list/dropdown-project-list.html",
      scope: {
        active: "="
      },
      link: link
    };
    return directive;
  };

  DropdownProjectListDirective.$inject = ["$rootScope", "tgCurrentUserService", "tgProjectsService"];

  angular.module("taigaNavigationBar").directive("tgDropdownProjectList", DropdownProjectListDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: navigation-bar/dropdown-user/dropdown-user.directive.coffee
 */

(function() {
  var DropdownUserDirective;

  DropdownUserDirective = function(authService, configService, locationService, navUrlsService, feedbackService, $rootScope) {
    var directive, link;
    link = function(scope, el, attrs, ctrl) {
      scope.vm = {};
      scope.vm.isFeedbackEnabled = configService.get("feedbackEnabled");
      scope.vm.customSupportUrl = configService.get("supportUrl");
      taiga.defineImmutableProperty(scope.vm, "user", function() {
        return authService.userData;
      });
      scope.vm.logout = function() {
        authService.logout();
        locationService.url(navUrlsService.resolve("discover"));
        return locationService.search({});
      };
      scope.vm.sendFeedback = function() {
        return feedbackService.sendFeedback();
      };
      return scope.vm.userSettingsPlugins = _.filter($rootScope.userSettingsPlugins, {
        userMenu: true
      });
    };
    directive = {
      templateUrl: "navigation-bar/dropdown-user/dropdown-user.html",
      scope: {},
      link: link
    };
    return directive;
  };

  DropdownUserDirective.$inject = ["$tgAuth", "$tgConfig", "$tgLocation", "$tgNavUrls", "tgFeedbackService", "$rootScope"];

  angular.module("taigaNavigationBar").directive("tgDropdownUser", DropdownUserDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: navigation-bar/navigation-bar.directive.coffee
 */

(function() {
  var NavigationBarDirective;

  NavigationBarDirective = function(currentUserService, navigationBarService, locationService, navUrlsService, config) {
    var directive, link;
    link = function(scope, el, attrs, ctrl) {
      scope.vm = {};
      taiga.defineImmutableProperty(scope.vm, "projects", function() {
        return currentUserService.projects.get("recents");
      });
      taiga.defineImmutableProperty(scope.vm, "isAuthenticated", function() {
        return currentUserService.isAuthenticated();
      });
      taiga.defineImmutableProperty(scope.vm, "isEnabledHeader", function() {
        return navigationBarService.isEnabledHeader();
      });
      scope.vm.publicRegisterEnabled = config.get("publicRegisterEnabled");
      scope.vm.customSupportUrl = config.get("supportUrl");
      scope.vm.login = function() {
        var nextUrl;
        nextUrl = encodeURIComponent(locationService.url());
        locationService.url(navUrlsService.resolve("login"));
        return locationService.search({
          next: nextUrl
        });
      };
      return scope.$on("$routeChangeSuccess", function() {
        scope.vm.active = null;
        switch (locationService.path()) {
          case "/":
            return scope.vm.active = 'dashboard';
          case "/discover":
            return scope.vm.active = 'discover';
          case "/notifications":
            return scope.vm.active = 'notifications';
          case "/projects/":
            return scope.vm.active = 'projects';
        }
      });
    };
    directive = {
      templateUrl: "navigation-bar/navigation-bar.html",
      scope: {},
      link: link
    };
    return directive;
  };

  NavigationBarDirective.$inject = ["tgCurrentUserService", "tgNavigationBarService", "$tgLocation", "$tgNavUrls", "$tgConfig"];

  angular.module("taigaNavigationBar").directive("tgNavigationBar", NavigationBarDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: navigation-bar/navigation-bar.service.coffee
 */

(function() {
  var NavigationBarService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  NavigationBarService = (function(superClass) {
    extend(NavigationBarService, superClass);

    function NavigationBarService() {
      this.disableHeader();
    }

    NavigationBarService.prototype.enableHeader = function() {
      return this.enabledHeader = true;
    };

    NavigationBarService.prototype.disableHeader = function() {
      return this.enabledHeader = false;
    };

    NavigationBarService.prototype.isEnabledHeader = function() {
      return this.enabledHeader;
    };

    return NavigationBarService;

  })(taiga.Service);

  angular.module("taigaNavigationBar").service("tgNavigationBarService", NavigationBarService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: notifications/notifications-list/notifications-list.directive.coffee
 */

(function() {
  var NotificationsListDirective;

  NotificationsListDirective = function() {
    return {
      templateUrl: "notifications/notifications-list/notifications-list.html",
      controller: "Notifications",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        infiniteScrollContainer: "@",
        infiniteScrollDistance: "=",
        infiniteScrollDisabled: "=",
        onlyUnread: "=onlyUnread"
      }
    };
  };

  angular.module("taigaNotifications").directive("tgNotificationsList", NotificationsListDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: notifications/notifications.controller.coffee
 */

(function() {
  var NotificationsController, debounceLeading, mixOf, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  debounceLeading = this.taiga.debounceLeading;

  NotificationsController = (function(superClass) {
    extend(NotificationsController, superClass);

    NotificationsController.$inject = ["$rootScope", "$scope", "tgNotificationsService", "tgCurrentUserService", "$tgEvents", "$location", "$window"];

    function NotificationsController(rootScope, scope, notificationsService, currentUserService, events, location, window) {
      this.rootScope = rootScope;
      this.scope = scope;
      this.notificationsService = notificationsService;
      this.currentUserService = currentUserService;
      this.events = events;
      this.location = location;
      this.window = window;
      this.total = 0;
      this.user = this.currentUserService.getUser();
      this.scrollDisabled = false;
      this.initList();
      this.loadNotifications();
      this.rootScope.$on("notifications:dismiss", (function(_this) {
        return function(event) {
          if (_this.onlyUnread) {
            return _this.reloadList();
          }
        };
      })(this));
      this.rootScope.$on("notifications:new", (function(_this) {
        return function(event) {
          return _this.reloadList();
        };
      })(this));
      this.rootScope.$on("notifications:dismiss-all", (function(_this) {
        return function(event) {
          return _this.reloadList();
        };
      })(this));
    }

    NotificationsController.prototype.initList = function() {
      this.notificationsList = Immutable.List();
      this.list = this.notificationsService.getNotificationsList(this.user.get("id"), this.onlyUnread != null);
      return this.loading = this.list == null;
    };

    NotificationsController.prototype.reloadList = function() {
      this.initList();
      return this.loadNotifications();
    };

    NotificationsController.prototype.loadNotifications = function() {
      this.scrollDisabled = true;
      this.loading = true;
      this.scope.$emit("notifications:loading");
      return this.list.next().then((function(_this) {
        return function(response) {
          _this.notificationsList = _this.notificationsList.concat(response.get("items"));
          if (!_this.infiniteScrollDisabled && response.get("next")) {
            _this.scrollDisabled = false;
          }
          _this.total = response.get("total");
          _this.scope.$emit("notifications:loaded", _this.total);
          _this.loading = false;
          return _this.notificationsList;
        };
      })(this));
    };

    NotificationsController.prototype.setAsRead = function(notification, url) {
      return this.notificationsService.setNotificationAsRead(notification.get("id")).then((function(_this) {
        return function() {
          if (_this.location.$$url === url) {
            _this.window.location.reload();
          } else {
            _this.location.path(url);
          }
          return _this.rootScope.$broadcast("notifications:dismiss");
        };
      })(this));
    };

    NotificationsController.prototype.setAllAsRead = function() {
      return this.notificationsService.setNotificationsAsRead().then((function(_this) {
        return function() {
          return _this.rootScope.$broadcast("notifications:dismiss-all");
        };
      })(this));
    };

    return NotificationsController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  angular.module("taigaNotifications").controller("Notifications", NotificationsController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-notification/user-notification/user-notification.service.coffee
 */

(function() {
  var NotificationsService, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  NotificationsService = (function(superClass) {
    var _notificationTypes, _params;

    extend(NotificationsService, superClass);

    NotificationsService.$inject = ["tgResources", "tgUserTimelinePaginationSequenceService", "$translate", "$tgNavUrls", "$tgSections"];

    _notificationTypes = [
      {
        check: function(notification) {
          return notification.get('event_type') === 1;
        },
        key: 'EVENTS.ASSIGNED_YOU',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(notification) {
          return notification.get('event_type') === 2;
        },
        key: 'EVENTS.MENTIONED_YOU',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(notification) {
          return notification.get('event_type') === 3;
        },
        key: 'EVENTS.ADDED_YOU_AS_WATCHER',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(notification) {
          return notification.get('event_type') === 4;
        },
        key: 'EVENTS.ADDED_YOU_AS_MEMBER',
        translate_params: ['username']
      }, {
        check: function(notification) {
          return notification.get('event_type') === 5;
        },
        key: 'EVENTS.COMMENTED',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(notification) {
          return notification.get('event_type') === 6;
        },
        key: 'EVENTS.MENTIONED_YOU_IN_COMMENT',
        translate_params: ['username', 'obj_name']
      }
    ];

    _params = {
      username: function(notification) {
        var title_attr, url, user;
        user = notification.getIn(['data', 'user']);
        if (user.get('is_profile_visible')) {
          title_attr = this.translate.instant('COMMON.SEE_USER_PROFILE', {
            username: user.get('username')
          });
          url = this.navUrls.resolve('user-profile', {
            username: notification.getIn(['data', 'user', 'username'])
          });
          return this._getLink(notification, url, user.get('name'), 'user-link', title_attr);
        } else {
          return this._getUsernameSpan(user.get('name'));
        }
      },
      project_name: function(notification) {
        var url;
        url = this.navUrls.resolve('project', {
          project: notification.getIn(['data', 'project', 'slug'])
        });
        return this._getLink(notification, url, notification.getIn(["data", "project", "name"]), 'project-link');
      },
      obj_name: function(notification) {
        var obj, text, url;
        obj = this._getNotificationObject(notification);
        url = this._getDetailObjUrl(notification, obj.get('content_type'));
        text = '#' + obj.get('ref') + ' ' + obj.get('subject');
        return this._getLink(notification, url, text, 'object-link');
      }
    };

    function NotificationsService(rs, userTimelinePaginationSequenceService, translate, navUrls, tgSections) {
      this.rs = rs;
      this.userTimelinePaginationSequenceService = userTimelinePaginationSequenceService;
      this.translate = translate;
      this.navUrls = navUrls;
      this.tgSections = tgSections;
    }

    NotificationsService.prototype.getNotificationsList = function(userId, onlyUnread) {
      var config, total;
      total = 0;
      config = {};
      config.fetch = (function(_this) {
        return function(page) {
          return _this.rs.users.getNotifications(userId, page, onlyUnread).then(function(response) {
            return response;
          });
        };
      })(this);
      config.map = (function(_this) {
        return function(obj) {
          return _this._addNotificationAttributes(obj);
        };
      })(this);
      return this.userTimelinePaginationSequenceService.generate(config);
    };

    NotificationsService.prototype.setNotificationAsRead = function(notificationId) {
      return this.rs.users.setNotificationAsRead(notificationId);
    };

    NotificationsService.prototype.setNotificationsAsRead = function() {
      return this.rs.users.setNotificationsAsRead();
    };

    NotificationsService.prototype._getNotificationObject = function(notification) {
      if (notification.get('data').get('obj')) {
        return notification.get('data').get('obj');
      }
    };

    NotificationsService.prototype._getType = function(notification) {
      return _.find(_notificationTypes, function(obj) {
        return obj.check(notification);
      });
    };

    NotificationsService.prototype._addNotificationAttributes = function(notification) {
      var event_type, projectSectionPath, projectSlug, projectUrl, title, type;
      event_type = notification.get('event_type');
      type = this._getType(notification);
      title = this._getTitle(notification, event_type, type);
      notification = notification.set('title_html', title);
      projectSlug = notification.getIn(['data', 'project', 'slug']);
      projectSectionPath = this.tgSections.getPath(projectSlug);
      projectUrl = this.navUrls.resolve("project-" + projectSectionPath, {
        project: projectSlug
      });
      notification = notification.set('projectUrl', projectUrl);
      notification = notification.set('obj', this._getNotificationObject(notification));
      return notification;
    };

    NotificationsService.prototype._translateTitleParams = function(param, notification, event) {
      return _params[param].call(this, notification, event);
    };

    NotificationsService.prototype._getDetailObjUrl = function(notification, contentType) {
      var url, urlMapping;
      urlMapping = {
        "issue": "project-issues-detail",
        "task": "project-tasks-detail",
        "userstory": "project-userstories-detail"
      };
      url = this.navUrls.resolve(urlMapping[contentType], {
        project: notification.getIn(['data', 'project', 'slug']),
        ref: notification.getIn(['data', 'obj', 'ref'])
      });
      return url;
    };

    NotificationsService.prototype._getLink = function(notification, url, text, css, title) {
      var span;
      title = title || text;
      span = $('<span>').attr('ng-non-bindable', true).text(text);
      return $('<a href="">').attr('title', title).attr('class', css).attr('ng-click', "vm.setAsRead(notification, \"" + url + "\")").append(span).prop('outerHTML');
    };

    NotificationsService.prototype._getUsernameSpan = function(text) {
      var title;
      title = title || text;
      return $('<span>').addClass('username').text(text).prop('outerHTML');
    };

    NotificationsService.prototype._getParams = function(notification, event_type, notification_type) {
      var params;
      params = {};
      notification_type.translate_params.forEach((function(_this) {
        return function(param) {
          return params[param] = _this._translateTitleParams(param, notification, event_type);
        };
      })(this));
      return params;
    };

    NotificationsService.prototype._getTitle = function(notification, event_type, notification_type) {
      var params, paramsKeys, translation;
      params = this._getParams(notification, event_type, notification_type);
      paramsKeys = {};
      Object.keys(params).forEach(function(key) {
        return paramsKeys[key] = '{{' + key + '}}';
      });
      translation = this.translate.instant(notification_type.key, paramsKeys);
      Object.keys(params).forEach(function(key) {
        var find;
        find = '{{' + key + '}}';
        return translation = translation.replace(new RegExp(find, 'g'), params[key]);
      });
      return translation;
    };

    return NotificationsService;

  })(taiga.Service);

  angular.module("taigaNotifications").service("tgNotificationsService", NotificationsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-bar/profile-bar.controller.coffee
 */

(function() {
  var ProfileBarController;

  ProfileBarController = (function() {
    ProfileBarController.$inject = ["tgUserService"];

    function ProfileBarController(userService) {
      this.userService = userService;
      this.loadStats();
    }

    ProfileBarController.prototype.loadStats = function() {
      return this.userService.getStats(this.user.get("id")).then((function(_this) {
        return function(stats) {
          return _this.stats = stats;
        };
      })(this));
    };

    return ProfileBarController;

  })();

  angular.module("taigaProfile").controller("ProfileBar", ProfileBarController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-bar/profile-bar.directive.coffee
 */

(function() {
  var ProfileBarDirective;

  ProfileBarDirective = function() {
    return {
      templateUrl: "profile/profile-bar/profile-bar.html",
      controller: "ProfileBar",
      controllerAs: "vm",
      scope: {
        user: "=user",
        isCurrentUser: "=iscurrentuser"
      },
      bindToController: true
    };
  };

  angular.module("taigaProfile").directive("tgProfileBar", ProfileBarDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-contacts/profile-contacts.controller.coffee
 */

(function() {
  var ProfileContactsController;

  ProfileContactsController = (function() {
    ProfileContactsController.$inject = ["tgUserService", "tgCurrentUserService"];

    function ProfileContactsController(userService, currentUserService) {
      this.userService = userService;
      this.currentUserService = currentUserService;
      this.currentUser = this.currentUserService.getUser();
      this.isCurrentUser = false;
      if (this.currentUser && this.currentUser.get("id") === this.user.get("id")) {
        this.isCurrentUser = true;
      }
    }

    ProfileContactsController.prototype.loadContacts = function() {
      return this.userService.getContacts(this.user.get("id")).then((function(_this) {
        return function(contacts) {
          return _this.contacts = contacts;
        };
      })(this));
    };

    return ProfileContactsController;

  })();

  angular.module("taigaProfile").controller("ProfileContacts", ProfileContactsController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-contacts/profile-contacts.directive.coffee
 */

(function() {
  var ProfileContactsDirective;

  ProfileContactsDirective = function() {
    var link;
    link = function(scope, elm, attrs, ctrl) {
      return ctrl.loadContacts();
    };
    return {
      templateUrl: "profile/profile-contacts/profile-contacts.html",
      scope: {
        user: "="
      },
      controllerAs: "vm",
      controller: "ProfileContacts",
      link: link,
      bindToController: true
    };
  };

  angular.module("taigaProfile").directive("tgProfileContacts", ProfileContactsDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-favs/items/items.directive.coffee
 */

(function() {
  var FavItemDirective;

  FavItemDirective = function() {
    var link, templateUrl;
    link = function(scope, el, attrs, ctrl) {
      return scope.vm = {
        item: scope.item
      };
    };
    templateUrl = function(el, attrs) {
      if (attrs.itemType === "project") {
        return "profile/profile-favs/items/project.html";
      } else {
        return "profile/profile-favs/items/ticket.html";
      }
    };
    return {
      scope: {
        "item": "=tgFavItem"
      },
      link: link,
      templateUrl: templateUrl
    };
  };

  angular.module("taigaProfile").directive("tgFavItem", FavItemDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-favs/profile-favs.controller.coffee
 */

(function() {
  var FavsBaseController, ProfileLikedController, ProfileVotedController, ProfileWatchedController, debounceLeading,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  debounceLeading = this.taiga.debounceLeading;

  FavsBaseController = (function() {
    function FavsBaseController() {
      this._init();
    }

    FavsBaseController.prototype._init = function() {
      this.enableFilterByAll = true;
      this.enableFilterByProjects = true;
      this.enableFilterByEpics = true;
      this.enableFilterByUserStories = true;
      this.enableFilterByTasks = true;
      this.enableFilterByIssues = true;
      this.enableFilterByTextQuery = true;
      this._resetList();
      this.q = null;
      return this.type = null;
    };

    FavsBaseController.prototype._resetList = function() {
      this.items = Immutable.List();
      this.scrollDisabled = false;
      return this._page = 1;
    };

    FavsBaseController.prototype._enableLoadingSpinner = function() {
      return this.isLoading = true;
    };

    FavsBaseController.prototype._disableLoadingSpinner = function() {
      return this.isLoading = false;
    };

    FavsBaseController.prototype._enableScroll = function() {
      return this.scrollDisabled = false;
    };

    FavsBaseController.prototype._disableScroll = function() {
      return this.scrollDisabled = true;
    };

    FavsBaseController.prototype._checkIfHasMorePages = function(hasNext) {
      if (hasNext) {
        this._page += 1;
        return this._enableScroll();
      } else {
        return this._disableScroll();
      }
    };

    FavsBaseController.prototype._checkIfHasNoResults = function() {
      return this.hasNoResults = this.items.size === 0;
    };

    FavsBaseController.prototype.loadItems = function() {
      this._enableLoadingSpinner();
      this._disableScroll();
      return this._getItems(this.user.get("id"), this._page, this.type, this.q).then((function(_this) {
        return function(response) {
          _this.items = _this.items.concat(response.get("data"));
          _this._checkIfHasMorePages(response.get("next"));
          _this._checkIfHasNoResults();
          _this._disableLoadingSpinner();
          return _this.items;
        };
      })(this))["catch"]((function(_this) {
        return function() {
          _this._disableLoadingSpinner();
          return _this.items;
        };
      })(this));
    };

    FavsBaseController.prototype.filterByTextQuery = debounceLeading(500, function() {
      this._resetList();
      return this.loadItems();
    });

    FavsBaseController.prototype.showAll = function() {
      if (this.type !== null) {
        this.type = null;
        this._resetList();
        return this.loadItems();
      }
    };

    FavsBaseController.prototype.showProjectsOnly = function() {
      if (this.type !== "project") {
        this.type = "project";
        this._resetList();
        return this.loadItems();
      }
    };

    FavsBaseController.prototype.showEpicsOnly = function() {
      if (this.type !== "epic") {
        this.type = "epic";
        this._resetList();
        return this.loadItems();
      }
    };

    FavsBaseController.prototype.showUserStoriesOnly = function() {
      if (this.type !== "userstory") {
        this.type = "userstory";
        this._resetList();
        return this.loadItems();
      }
    };

    FavsBaseController.prototype.showTasksOnly = function() {
      if (this.type !== "task") {
        this.type = "task";
        this._resetList();
        return this.loadItems();
      }
    };

    FavsBaseController.prototype.showIssuesOnly = function() {
      if (this.type !== "issue") {
        this.type = "issue";
        this._resetList();
        return this.loadItems();
      }
    };

    return FavsBaseController;

  })();

  ProfileLikedController = (function(superClass) {
    extend(ProfileLikedController, superClass);

    ProfileLikedController.$inject = ["tgUserService"];

    function ProfileLikedController(userService) {
      this.userService = userService;
      ProfileLikedController.__super__.constructor.call(this);
      this.tabName = 'likes';
      this.enableFilterByAll = false;
      this.enableFilterByProjects = false;
      this.enableFilterByEpics = false;
      this.enableFilterByUserStories = false;
      this.enableFilterByTasks = false;
      this.enableFilterByIssues = false;
      this.enableFilterByTextQuery = true;
      this._getItems = this.userService.getLiked;
    }

    return ProfileLikedController;

  })(FavsBaseController);

  angular.module("taigaProfile").controller("ProfileLiked", ProfileLikedController);

  ProfileVotedController = (function(superClass) {
    extend(ProfileVotedController, superClass);

    ProfileVotedController.$inject = ["tgUserService"];

    function ProfileVotedController(userService) {
      this.userService = userService;
      ProfileVotedController.__super__.constructor.call(this);
      this.tabName = 'upvotes';
      this.enableFilterByAll = true;
      this.enableFilterByProjects = false;
      this.enableFilterByEpics = true;
      this.enableFilterByUserStories = true;
      this.enableFilterByTasks = true;
      this.enableFilterByIssues = true;
      this.enableFilterByTextQuery = true;
      this._getItems = this.userService.getVoted;
    }

    return ProfileVotedController;

  })(FavsBaseController);

  angular.module("taigaProfile").controller("ProfileVoted", ProfileVotedController);

  ProfileWatchedController = (function(superClass) {
    extend(ProfileWatchedController, superClass);

    ProfileWatchedController.$inject = ["tgUserService"];

    function ProfileWatchedController(userService) {
      this.userService = userService;
      ProfileWatchedController.__super__.constructor.call(this);
      this.tabName = 'watchers';
      this._getItems = this.userService.getWatched;
    }

    return ProfileWatchedController;

  })(FavsBaseController);

  angular.module("taigaProfile").controller("ProfileWatched", ProfileWatchedController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-favs/profile-favs.directive.coffee
 */

(function() {
  var ProfileLikedDirective, ProfileVotedDirective, ProfileWatchedDirective, base;

  base = {
    scope: {},
    bindToController: {
      user: "=",
      type: "@",
      q: "@",
      scrollDisabled: "@",
      isLoading: "@",
      hasNoResults: "@"
    },
    controller: null,
    controllerAs: "vm",
    templateUrl: "profile/profile-favs/profile-favs.html"
  };

  ProfileLikedDirective = function() {
    return _.extend({}, base, {
      controller: "ProfileLiked"
    });
  };

  angular.module("taigaProfile").directive("tgProfileLiked", ProfileLikedDirective);

  ProfileVotedDirective = function() {
    return _.extend({}, base, {
      controller: "ProfileVoted"
    });
  };

  angular.module("taigaProfile").directive("tgProfileVoted", ProfileVotedDirective);

  ProfileWatchedDirective = function() {
    return _.extend({}, base, {
      controller: "ProfileWatched"
    });
  };

  angular.module("taigaProfile").directive("tgProfileWatched", ProfileWatchedDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-hints/profile-hints.controller.coffee
 */

(function() {
  var ProfileHints;

  ProfileHints = (function() {
    ProfileHints.prototype.HINTS = [
      {
        url: "https://tree.taiga.io/support/admin/import-export-projects/"
      }, {
        url: "https://tree.taiga.io/support/admin/custom-fields/"
      }, {}, {}
    ];

    function ProfileHints(translate) {
      var hintKey;
      this.translate = translate;
      hintKey = Math.floor(Math.random() * this.HINTS.length) + 1;
      this.hint = this.HINTS[hintKey - 1];
      this.hint.linkText = this.hint.linkText || 'HINTS.LINK';
      this.hint.title = this.translate.instant("HINTS.HINT" + hintKey + "_TITLE");
      this.hint.text = this.translate.instant("HINTS.HINT" + hintKey + "_TEXT");
    }

    return ProfileHints;

  })();

  ProfileHints.$inject = ["$translate"];

  angular.module("taigaProfile").controller("ProfileHints", ProfileHints);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-hints/profile-hints.directive.coffee
 */

(function() {
  var ProfileHints;

  ProfileHints = function($translate) {
    return {
      scope: {},
      controller: "ProfileHints",
      controllerAs: "vm",
      templateUrl: "profile/profile-hints/profile-hints.html"
    };
  };

  ProfileHints.$inject = ["$translate"];

  angular.module("taigaProfile").directive("tgProfileHints", ProfileHints);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-projects/profile-projects.controller.coffee
 */

(function() {
  var ProfileProjectsController;

  ProfileProjectsController = (function() {
    ProfileProjectsController.$inject = ["tgProjectsService", "tgUserService"];

    function ProfileProjectsController(projectsService, userService) {
      this.projectsService = projectsService;
      this.userService = userService;
    }

    ProfileProjectsController.prototype.loadProjects = function() {
      return this.projectsService.getProjectsByUserId(this.user.get("id")).then((function(_this) {
        return function(projects) {
          return _this.userService.attachUserContactsToProjects(_this.user.get("id"), projects);
        };
      })(this)).then((function(_this) {
        return function(projects) {
          return _this.projects = projects;
        };
      })(this));
    };

    return ProfileProjectsController;

  })();

  angular.module("taigaProfile").controller("ProfileProjects", ProfileProjectsController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-projects/profile-projects.directive.coffee
 */

(function() {
  var ProfileProjectsDirective;

  ProfileProjectsDirective = function() {
    var link;
    link = function(scope, elm, attr, ctrl) {
      return ctrl.loadProjects();
    };
    return {
      templateUrl: "profile/profile-projects/profile-projects.html",
      scope: {
        user: "="
      },
      link: link,
      bindToController: true,
      controllerAs: "vm",
      controller: "ProfileProjects"
    };
  };

  angular.module("taigaProfile").directive("tgProfileProjects", ProfileProjectsDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-tab/profile-tab.directive.coffee
 */

(function() {
  var ProfileTabDirective;

  ProfileTabDirective = function() {
    var link;
    link = function(scope, element, attrs, ctrl, transclude) {
      scope.tab = {};
      attrs.$observe("tgProfileTab", function(name) {
        return scope.tab.name = name;
      });
      attrs.$observe("tabTitle", function(title) {
        return scope.tab.title = title;
      });
      scope.tab.icon = attrs.tabIcon;
      scope.tab.active = !!attrs.tabActive;
      if (scope.$eval(attrs.tabDisabled) !== true) {
        return ctrl.addTab(scope.tab);
      }
    };
    return {
      templateUrl: "profile/profile-tab/profile-tab.html",
      scope: {},
      require: "^tgProfileTabs",
      link: link,
      transclude: true
    };
  };

  angular.module("taigaProfile").directive("tgProfileTab", ProfileTabDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-tabs/profile-tabs.controller.coffee
 */

(function() {
  var ProfileTabsController;

  ProfileTabsController = (function() {
    function ProfileTabsController() {
      this.tabs = [];
    }

    ProfileTabsController.prototype.addTab = function(tab) {
      return this.tabs.push(tab);
    };

    ProfileTabsController.prototype.toggleTab = function(tab) {
      _.map(this.tabs, function(tab) {
        return tab.active = false;
      });
      return tab.active = true;
    };

    return ProfileTabsController;

  })();

  angular.module("taigaProfile").controller("ProfileTabs", ProfileTabsController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile-tabs/profile-tabs.directive.coffee
 */

(function() {
  var ProfileTabsDirective;

  ProfileTabsDirective = function() {
    return {
      scope: {},
      controller: "ProfileTabs",
      controllerAs: "vm",
      templateUrl: "profile/profile-tabs/profile-tabs.html",
      transclude: true
    };
  };

  angular.module("taigaProfile").directive("tgProfileTabs", ProfileTabsDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: profile/profile.controller.coffee
 */

(function() {
  var ProfileController;

  ProfileController = (function() {
    ProfileController.$inject = ["tgAppMetaService", "tgCurrentUserService", "$routeParams", "tgUserService", "tgXhrErrorService", "$translate"];

    function ProfileController(appMetaService, currentUserService, routeParams, userService, xhrError, translate) {
      this.appMetaService = appMetaService;
      this.currentUserService = currentUserService;
      this.routeParams = routeParams;
      this.userService = userService;
      this.xhrError = xhrError;
      this.translate = translate;
      this.isCurrentUser = false;
      if (this.routeParams.slug) {
        this.userService.getUserByUserName(this.routeParams.slug).then((function(_this) {
          return function(user) {
            if (!user.get('is_active')) {
              return _this.xhrError.notFound();
            } else {
              _this.user = user;
              _this.isCurrentUser = false;
              _this._setMeta(_this.user);
              return user;
            }
          };
        })(this))["catch"]((function(_this) {
          return function(xhr) {
            return _this.xhrError.response(xhr);
          };
        })(this));
      } else {
        this.user = this.currentUserService.getUser();
        this.isCurrentUser = true;
        this._setMeta(this.user);
      }
    }

    ProfileController.prototype._setMeta = function(user) {
      var ctx, description, title;
      ctx = {
        userFullName: user.get("full_name_display"),
        userUsername: user.get("username")
      };
      title = this.translate.instant("USER.PROFILE.PAGE_TITLE", ctx);
      description = user.get("bio");
      return this.appMetaService.setAll(title, description);
    };

    return ProfileController;

  })();

  angular.module("taigaProfile").controller("Profile", ProfileController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/blocked-project-explanation.directive.coffee
 */

(function() {
  var BlockedProjectExplanationDirective;

  BlockedProjectExplanationDirective = function() {
    return {
      templateUrl: "projects/project/blocked-project-explanation.html"
    };
  };

  angular.module("taigaProjects").directive("tgBlockedProjectExplanation", BlockedProjectExplanationDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/contact-project-button/contact-project-button.controller.coffee
 */

(function() {
  var ContactProjectButtonController;

  ContactProjectButtonController = (function() {
    ContactProjectButtonController.$inject = ['tgLightboxFactory'];

    function ContactProjectButtonController(lightboxFactory) {
      this.lightboxFactory = lightboxFactory;
    }

    ContactProjectButtonController.prototype.launchContactForm = function() {
      return this.lightboxFactory.create('tg-lb-contact-project', {
        "class": "lightbox lightbox-contact-project e2e-lightbox-contact-project",
        "project": "project"
      }, {
        "project": this.project
      });
    };

    return ContactProjectButtonController;

  })();

  angular.module("taigaProjects").controller("ContactProjectButtonCtrl", ContactProjectButtonController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/contact-project-button/contact-project-button.directive.coffee
 */

(function() {
  var ContactProjectButtonDirective;

  ContactProjectButtonDirective = function() {
    return {
      scope: {},
      controller: "ContactProjectButtonCtrl",
      bindToController: {
        project: '=',
        layout: '@'
      },
      controllerAs: "vm",
      templateUrl: "projects/components/contact-project-button/contact-project-button.html"
    };
  };

  angular.module("taigaProjects").directive("tgContactProjectButton", ContactProjectButtonDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/lb-contact-project/lb-contact-project.controller.coffee
 */

(function() {
  var ContactProjectLbController;

  ContactProjectLbController = (function() {
    ContactProjectLbController.$inject = ["lightboxService", "tgResources", "$tgConfirm"];

    function ContactProjectLbController(lightboxService, rs, confirm) {
      this.lightboxService = lightboxService;
      this.rs = rs;
      this.confirm = confirm;
      this.contact = {};
    }

    ContactProjectLbController.prototype.contactProject = function() {
      var message, project, promise;
      project = this.project.get('id');
      message = this.contact.message;
      promise = this.rs.projects.contactProject(project, message);
      this.sendingFeedback = true;
      return promise.then((function(_this) {
        return function() {
          _this.lightboxService.closeAll();
          _this.sendingFeedback = false;
          return _this.confirm.notify("success");
        };
      })(this));
    };

    return ContactProjectLbController;

  })();

  angular.module("taigaProjects").controller("ContactProjectLbCtrl", ContactProjectLbController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/lb-contact-project/lb-contact-project.directive.coffee
 */

(function() {
  var ContactProjectLbDirective;

  ContactProjectLbDirective = function(lightboxService) {
    var link;
    this.inject = ['lightboxService'];
    link = function(scope, el) {
      return lightboxService.open(el);
    };
    return {
      controller: "ContactProjectLbCtrl",
      bindToController: {
        project: '='
      },
      controllerAs: "vm",
      templateUrl: "projects/components/lb-contact-project/lb-contact-project.html",
      link: link
    };
  };

  angular.module("taigaProjects").directive("tgLbContactProject", ["lightboxService", ContactProjectLbDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/like-project-button/like-project-button.controller.coffee
 */

(function() {
  var LikeProjectButtonController;

  LikeProjectButtonController = (function() {
    LikeProjectButtonController.$inject = ["$tgConfirm", "tgLikeProjectButtonService"];

    function LikeProjectButtonController(confirm, likeButtonService) {
      this.confirm = confirm;
      this.likeButtonService = likeButtonService;
      this.isMouseOver = false;
      this.loading = false;
    }

    LikeProjectButtonController.prototype.showTextWhenMouseIsOver = function() {
      return this.isMouseOver = true;
    };

    LikeProjectButtonController.prototype.showTextWhenMouseIsLeave = function() {
      return this.isMouseOver = false;
    };

    LikeProjectButtonController.prototype.toggleLike = function() {
      var promise;
      this.loading = true;
      if (!this.project.get("is_fan")) {
        promise = this._like();
      } else {
        promise = this._unlike();
      }
      promise["finally"]((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
      return promise;
    };

    LikeProjectButtonController.prototype._like = function() {
      return this.likeButtonService.like(this.project.get('id')).then((function(_this) {
        return function() {
          return _this.showTextWhenMouseIsLeave();
        };
      })(this))["catch"]((function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this));
    };

    LikeProjectButtonController.prototype._unlike = function() {
      return this.likeButtonService.unlike(this.project.get('id'))["catch"]((function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this));
    };

    return LikeProjectButtonController;

  })();

  angular.module("taigaProjects").controller("LikeProjectButton", LikeProjectButtonController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/like-project-button/like-project-button.directive.coffee
 */

(function() {
  var LikeProjectButtonDirective;

  LikeProjectButtonDirective = function() {
    return {
      scope: {},
      controller: "LikeProjectButton",
      bindToController: {
        project: '='
      },
      controllerAs: "vm",
      templateUrl: "projects/components/like-project-button/like-project-button.html"
    };
  };

  angular.module("taigaProjects").directive("tgLikeProjectButton", LikeProjectButtonDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/like-project-button/like-project-button.service.coffee
 */

(function() {
  var LikeProjectButtonService, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  LikeProjectButtonService = (function(superClass) {
    extend(LikeProjectButtonService, superClass);

    LikeProjectButtonService.$inject = ["tgResources", "tgCurrentUserService", "tgProjectService"];

    function LikeProjectButtonService(rs, currentUserService, projectService) {
      this.rs = rs;
      this.currentUserService = currentUserService;
      this.projectService = projectService;
    }

    LikeProjectButtonService.prototype._getProjectIndex = function(projectId) {
      return this.currentUserService.projects.get('all').findIndex(function(project) {
        return project.get('id') === projectId;
      });
    };

    LikeProjectButtonService.prototype._updateProjects = function(projectId, isFan) {
      var projectIndex, projects;
      projectIndex = this._getProjectIndex(projectId);
      if (projectIndex === -1) {
        return;
      }
      projects = this.currentUserService.projects.get('all').update(projectIndex, function(project) {
        var totalFans;
        totalFans = project.get("total_fans");
        if (isFan) {
          totalFans++;
        } else {
          totalFans--;
        }
        return project.merge({
          is_fan: isFan,
          total_fans: totalFans
        });
      });
      return this.currentUserService.setProjects(projects);
    };

    LikeProjectButtonService.prototype._updateCurrentProject = function(isFan) {
      var project, totalFans;
      totalFans = this.projectService.project.get("total_fans");
      if (isFan) {
        totalFans++;
      } else {
        totalFans--;
      }
      project = this.projectService.project.merge({
        is_fan: isFan,
        total_fans: totalFans
      });
      return this.projectService.setProject(project);
    };

    LikeProjectButtonService.prototype.like = function(projectId) {
      return this.rs.projects.likeProject(projectId).then((function(_this) {
        return function() {
          _this._updateProjects(projectId, true);
          return _this._updateCurrentProject(true);
        };
      })(this));
    };

    LikeProjectButtonService.prototype.unlike = function(projectId) {
      return this.rs.projects.unlikeProject(projectId).then((function(_this) {
        return function() {
          _this._updateProjects(projectId, false);
          return _this._updateCurrentProject(false);
        };
      })(this));
    };

    return LikeProjectButtonService;

  })(taiga.Service);

  angular.module("taigaProjects").service("tgLikeProjectButtonService", LikeProjectButtonService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/sort-projects.directive.coffee
 */

(function() {
  var SortProjectsDirective;

  SortProjectsDirective = function(currentUserService) {
    var directive, link;
    link = function(scope, el, attrs, ctrl) {
      var drake, itemEl, scroll;
      itemEl = null;
      drake = dragula([el[0]], {
        copySortSource: false,
        copy: false,
        mirrorContainer: el[0],
        moves: function(item) {
          return $(item).hasClass('list-itemtype-project');
        }
      });
      drake.on('dragend', function(item) {
        var i, index, len, project, sortData, sorted_project_ids, value;
        itemEl = $(item);
        project = itemEl.scope().project;
        index = itemEl.index();
        sorted_project_ids = _.map(scope.projects.toJS(), function(p) {
          return p.id;
        });
        sorted_project_ids = _.without(sorted_project_ids, project.get("id"));
        sorted_project_ids.splice(index, 0, project.get('id'));
        sortData = [];
        for (index = i = 0, len = sorted_project_ids.length; i < len; index = ++i) {
          value = sorted_project_ids[index];
          sortData.push({
            "project_id": value,
            "order": index
          });
        }
        return currentUserService.bulkUpdateProjectsOrder(sortData);
      });
      scroll = autoScroll(window, {
        margin: 20,
        pixels: 30,
        scrollWhenOutside: true,
        autoScroll: function() {
          return this.down && drake.dragging;
        }
      });
      return scope.$on("$destroy", function() {
        el.off();
        return drake.destroy();
      });
    };
    directive = {
      scope: {
        projects: "=tgSortProjects"
      },
      link: link
    };
    return directive;
  };

  angular.module("taigaProjects").directive("tgSortProjects", ["tgCurrentUserService", SortProjectsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/watch-project-button/watch-project-button.controller.coffee
 */

(function() {
  var WatchProjectButtonController;

  WatchProjectButtonController = (function() {
    WatchProjectButtonController.$inject = ["$tgConfirm", "tgWatchProjectButtonService"];

    function WatchProjectButtonController(confirm, watchButtonService) {
      this.confirm = confirm;
      this.watchButtonService = watchButtonService;
      this.showWatchOptions = false;
      this.loading = false;
    }

    WatchProjectButtonController.prototype.toggleWatcherOptions = function() {
      return this.showWatchOptions = !this.showWatchOptions;
    };

    WatchProjectButtonController.prototype.closeWatcherOptions = function() {
      return this.showWatchOptions = false;
    };

    WatchProjectButtonController.prototype.watch = function(notifyLevel) {
      if (notifyLevel === this.project.get('notify_level')) {
        return;
      }
      this.loading = true;
      this.closeWatcherOptions();
      return this.watchButtonService.watch(this.project.get('id'), notifyLevel)["catch"]((function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this))["finally"]((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
    };

    WatchProjectButtonController.prototype.unwatch = function() {
      this.loading = true;
      this.closeWatcherOptions();
      return this.watchButtonService.unwatch(this.project.get('id'))["catch"]((function(_this) {
        return function() {
          return _this.confirm.notify("error");
        };
      })(this))["finally"]((function(_this) {
        return function() {
          return _this.loading = false;
        };
      })(this));
    };

    return WatchProjectButtonController;

  })();

  angular.module("taigaProjects").controller("WatchProjectButton", WatchProjectButtonController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/watch-project-button/watch-project-button.directive.coffee
 */

(function() {
  var WatchProjectButtonDirective;

  WatchProjectButtonDirective = function() {
    return {
      scope: {},
      controller: "WatchProjectButton",
      bindToController: {
        project: "="
      },
      controllerAs: "vm",
      templateUrl: "projects/components/watch-project-button/watch-project-button.html"
    };
  };

  angular.module("taigaProjects").directive("tgWatchProjectButton", WatchProjectButtonDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/components/watch-project-button/watch-project-button.service.coffee
 */

(function() {
  var WatchProjectButtonService, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  WatchProjectButtonService = (function(superClass) {
    extend(WatchProjectButtonService, superClass);

    WatchProjectButtonService.$inject = ["tgResources", "tgCurrentUserService", "tgProjectService"];

    function WatchProjectButtonService(rs, currentUserService, projectService) {
      this.rs = rs;
      this.currentUserService = currentUserService;
      this.projectService = projectService;
    }

    WatchProjectButtonService.prototype._getProjectIndex = function(projectId) {
      return this.currentUserService.projects.get('all').findIndex(function(project) {
        return project.get('id') === projectId;
      });
    };

    WatchProjectButtonService.prototype._updateProjects = function(projectId, notifyLevel, isWatcher) {
      var projectIndex, projects;
      projectIndex = this._getProjectIndex(projectId);
      if (projectIndex === -1) {
        return;
      }
      projects = this.currentUserService.projects.get('all').update(projectIndex, (function(_this) {
        return function(project) {
          var totalWatchers;
          totalWatchers = project.get('total_watchers');
          if (!_this.projectService.project.get('is_watcher') && isWatcher) {
            totalWatchers++;
          } else if (_this.projectService.project.get('is_watcher') && !isWatcher) {
            totalWatchers--;
          }
          return project.merge({
            is_watcher: isWatcher,
            total_watchers: totalWatchers,
            notify_level: notifyLevel
          });
        };
      })(this));
      return this.currentUserService.setProjects(projects);
    };

    WatchProjectButtonService.prototype._updateCurrentProject = function(notifyLevel, isWatcher) {
      var project, totalWatchers;
      totalWatchers = this.projectService.project.get("total_watchers");
      if (!this.projectService.project.get('is_watcher') && isWatcher) {
        totalWatchers++;
      } else if (this.projectService.project.get('is_watcher') && !isWatcher) {
        totalWatchers--;
      }
      project = this.projectService.project.merge({
        is_watcher: isWatcher,
        notify_level: notifyLevel,
        total_watchers: totalWatchers
      });
      return this.projectService.setProject(project);
    };

    WatchProjectButtonService.prototype.watch = function(projectId, notifyLevel) {
      return this.rs.projects.watchProject(projectId, notifyLevel).then((function(_this) {
        return function() {
          _this._updateProjects(projectId, notifyLevel, true);
          return _this._updateCurrentProject(notifyLevel, true);
        };
      })(this));
    };

    WatchProjectButtonService.prototype.unwatch = function(projectId) {
      return this.rs.projects.unwatchProject(projectId).then((function(_this) {
        return function() {
          _this._updateProjects(projectId, null, false);
          return _this._updateCurrentProject(null, false);
        };
      })(this));
    };

    return WatchProjectButtonService;

  })(taiga.Service);

  angular.module("taigaProjects").service("tgWatchProjectButtonService", WatchProjectButtonService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/asana-import/asana-import-project-form/asana-import-project-form.controller.coffee
 */

(function() {
  var AsanaImportProjectFormController;

  AsanaImportProjectFormController = (function() {
    AsanaImportProjectFormController.$inject = ["tgCurrentUserService"];

    function AsanaImportProjectFormController(currentUserService) {
      this.currentUserService = currentUserService;
      this.canCreatePublicProjects = this.currentUserService.canCreatePublicProjects();
      this.canCreatePrivateProjects = this.currentUserService.canCreatePrivateProjects();
      this.projectForm = this.project.toJS();
      this.platformName = "Asana";
      this.projectForm.is_private = false;
      this.projectForm.keepExternalReference = false;
      this.projectForm.project_type = "scrum";
      if (!this.canCreatePublicProjects.valid && this.canCreatePrivateProjects.valid) {
        this.projectForm.is_private = true;
      }
    }

    AsanaImportProjectFormController.prototype.checkUsersLimit = function() {
      this.limitMembersPrivateProject = this.currentUserService.canAddMembersPrivateProject(this.members.size);
      return this.limitMembersPublicProject = this.currentUserService.canAddMembersPublicProject(this.members.size);
    };

    AsanaImportProjectFormController.prototype.saveForm = function() {
      return this.onSaveProjectDetails({
        project: Immutable.fromJS(this.projectForm)
      });
    };

    AsanaImportProjectFormController.prototype.canCreateProject = function() {
      if (this.projectForm.is_private) {
        return this.canCreatePrivateProjects.valid;
      } else {
        return this.canCreatePublicProjects.valid;
      }
    };

    AsanaImportProjectFormController.prototype.isDisabled = function() {
      return !this.canCreateProject();
    };

    return AsanaImportProjectFormController;

  })();

  angular.module('taigaProjects').controller('AsanaImportProjectFormCtrl', AsanaImportProjectFormController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/asana-import/asana-import-project-form/asana-import-project-form.directive.coffee
 */

(function() {
  var AsanaImportProjectFormDirective;

  AsanaImportProjectFormDirective = function() {
    return {
      link: function(scope, elm, attr, ctrl) {
        return scope.$watch('vm.members', ctrl.checkUsersLimit.bind(ctrl));
      },
      templateUrl: "projects/create/asana-import/asana-import-project-form/asana-import-project-form.html",
      controller: "AsanaImportProjectFormCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        members: '<',
        project: '<',
        onSaveProjectDetails: '&',
        onCancelForm: '&',
        fetchingUsers: '<'
      }
    };
  };

  AsanaImportProjectFormDirective.$inject = [];

  angular.module("taigaProjects").directive("tgAsanaImportProjectForm", AsanaImportProjectFormDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/asana-import/asana-import.controller.coffee
 */

(function() {
  var AsanaImportController;

  AsanaImportController = (function() {
    AsanaImportController.$inject = ['tgAsanaImportService', '$tgConfirm', '$translate', 'tgImportProjectService'];

    function AsanaImportController(asanaImportService, confirm, translate, importProjectService) {
      this.asanaImportService = asanaImportService;
      this.confirm = confirm;
      this.translate = translate;
      this.importProjectService = importProjectService;
      this.step = 'autorization-asana';
      this.project = null;
      taiga.defineImmutableProperty(this, 'projects', (function(_this) {
        return function() {
          return _this.asanaImportService.projects;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'members', (function(_this) {
        return function() {
          return _this.asanaImportService.projectUsers;
        };
      })(this));
    }

    AsanaImportController.prototype.startProjectSelector = function() {
      this.step = 'project-select-asana';
      return this.asanaImportService.fetchProjects();
    };

    AsanaImportController.prototype.onSelectProject = function(project) {
      this.step = 'project-form-asana';
      this.project = project;
      this.fetchingUsers = true;
      return this.asanaImportService.fetchUsers(this.project.get('id')).then((function(_this) {
        return function() {
          return _this.fetchingUsers = false;
        };
      })(this));
    };

    AsanaImportController.prototype.onSaveProjectDetails = function(project) {
      this.project = project;
      return this.step = 'project-members-asana';
    };

    AsanaImportController.prototype.onCancelMemberSelection = function() {
      return this.step = 'project-form-asana';
    };

    AsanaImportController.prototype.startImport = function(users) {
      var loader, promise;
      loader = this.confirm.loader(this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.TITLE'), this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.DESCRIPTION'), true);
      loader.start();
      promise = this.asanaImportService.importProject(this.project.get('name'), this.project.get('description'), this.project.get('id'), users, this.project.get('keepExternalReference'), this.project.get('is_private'), this.project.get('project_type'));
      return this.importProjectService.importPromise(promise).then((function(_this) {
        return function() {
          return loader.stop();
        };
      })(this));
    };

    AsanaImportController.prototype.submitUserSelection = function(users) {
      this.startImport(users);
      return null;
    };

    return AsanaImportController;

  })();

  angular.module('taigaProjects').controller('AsanaImportCtrl', AsanaImportController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/asana-import/asana-import.directive.coffee
 */

(function() {
  var AsanaImportDirective;

  AsanaImportDirective = function() {
    return {
      link: function(scope, elm, attrs, ctrl) {
        return ctrl.startProjectSelector();
      },
      templateUrl: "projects/create/asana-import/asana-import.html",
      controller: "AsanaImportCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        onCancel: '&'
      }
    };
  };

  AsanaImportDirective.$inject = [];

  angular.module("taigaProjects").directive("tgAsanaImport", AsanaImportDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/asana-import/asana-import.service.coffee
 */

(function() {
  var AsanaImportService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  AsanaImportService = (function(superClass) {
    extend(AsanaImportService, superClass);

    AsanaImportService.$inject = ['tgResources', '$location'];

    function AsanaImportService(resources, location) {
      this.resources = resources;
      this.location = location;
      this.projects = Immutable.List();
      this.projectUsers = Immutable.List();
      this.token = null;
    }

    AsanaImportService.prototype.setToken = function(token) {
      return this.token = token;
    };

    AsanaImportService.prototype.fetchProjects = function() {
      return this.resources.asanaImporter.listProjects(this.token).then((function(_this) {
        return function(projects) {
          return _this.projects = projects;
        };
      })(this));
    };

    AsanaImportService.prototype.fetchUsers = function(projectId) {
      return this.resources.asanaImporter.listUsers(this.token, projectId).then((function(_this) {
        return function(users) {
          return _this.projectUsers = users;
        };
      })(this));
    };

    AsanaImportService.prototype.importProject = function(name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType) {
      return this.resources.asanaImporter.importProject(this.token, name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType);
    };

    AsanaImportService.prototype.getAuthUrl = function() {
      return new Promise((function(_this) {
        return function(resolve) {
          return _this.resources.asanaImporter.getAuthUrl().then(function(response) {
            _this.authUrl = response.data.url;
            return resolve(_this.authUrl);
          });
        };
      })(this));
    };

    AsanaImportService.prototype.authorize = function(code) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.resources.asanaImporter.authorize(code).then((function(response) {
            _this.token = response.data.token;
            return resolve(_this.token);
          }), function(error) {
            return reject(new Error(error.status));
          });
        };
      })(this));
    };

    return AsanaImportService;

  })(taiga.Service);

  angular.module("taigaProjects").service("tgAsanaImportService", AsanaImportService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/create-project-form/create-project-form.controller.coffee
 */

(function() {
  var CreatetProjectFormController;

  CreatetProjectFormController = (function() {
    CreatetProjectFormController.$inject = ["tgCurrentUserService", "tgProjectsService", "$projectUrl", "$location", "$tgNavUrls", "$tgAnalytics"];

    function CreatetProjectFormController(currentUserService, projectsService, projectUrl, location, navUrls, analytics) {
      this.currentUserService = currentUserService;
      this.projectsService = projectsService;
      this.projectUrl = projectUrl;
      this.location = location;
      this.navUrls = navUrls;
      this.analytics = analytics;
      this.projectForm = {
        is_private: false
      };
      this.canCreatePublicProjects = this.currentUserService.canCreatePublicProjects();
      this.canCreatePrivateProjects = this.currentUserService.canCreatePrivateProjects();
      if (!this.canCreatePublicProjects.valid && this.canCreatePrivateProjects.valid) {
        this.projectForm.is_private = true;
      }
      if (this.type === 'scrum') {
        this.projectForm.creation_template = 1;
      } else {
        this.projectForm.creation_template = 2;
      }
    }

    CreatetProjectFormController.prototype.submit = function() {
      this.formSubmitLoading = true;
      return this.projectsService.create(this.projectForm).then((function(_this) {
        return function(project) {
          _this.analytics.trackEvent("project", "create", "project creation", {
            slug: project.get('slug'),
            id: project.get('id')
          });
          _this.location.url(_this.projectUrl.get(project));
          return _this.currentUserService.loadProjects();
        };
      })(this));
    };

    CreatetProjectFormController.prototype.onCancelForm = function() {
      return this.location.path(this.navUrls.resolve("create-project"));
    };

    CreatetProjectFormController.prototype.canCreateProject = function() {
      if (this.projectForm.is_private) {
        return this.canCreatePrivateProjects.valid;
      } else {
        return this.canCreatePublicProjects.valid;
      }
    };

    CreatetProjectFormController.prototype.isDisabled = function() {
      return this.formSubmitLoading || !this.canCreateProject();
    };

    return CreatetProjectFormController;

  })();

  angular.module('taigaProjects').controller('CreateProjectFormCtrl', CreatetProjectFormController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/create-project-form/create-project-form.directive.coffee
 */

(function() {
  var CreateProjectFormDirective;

  CreateProjectFormDirective = function() {
    return {
      templateUrl: "projects/create/create-project-form/create-project-form.html",
      controller: "CreateProjectFormCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        type: '@'
      }
    };
  };

  angular.module("taigaProjects").directive("tgCreateProjectForm", CreateProjectFormDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/create-project-members-restrictions/create-project-members-restrictions.directive.coffee
 */

(function() {
  var createProjectMembersRestrictionsDirective, module;

  module = angular.module("taigaProject");

  createProjectMembersRestrictionsDirective = function() {
    return {
      scope: {
        isPrivate: '=',
        limitMembersPrivateProject: '=',
        limitMembersPublicProject: '='
      },
      templateUrl: "projects/create/create-project-members-restrictions/create-project-members-restrictions.html"
    };
  };

  module.directive('tgCreateProjectMembersRestrictions', [createProjectMembersRestrictionsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/create-project-restrictions/create-project-restrictions.directive.coffee
 */

(function() {
  var createProjectRestrictionsDirective, module;

  module = angular.module("taigaProject");

  createProjectRestrictionsDirective = function() {
    return {
      scope: {
        isPrivate: '=',
        canCreatePrivateProjects: '=',
        canCreatePublicProjects: '='
      },
      templateUrl: "projects/create/create-project-restrictions/create-project-restrictions.html"
    };
  };

  module.directive('tgCreateProjectRestrictions', [createProjectRestrictionsDirective]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/create-project.controller.coffee
 */

(function() {
  var CreateProjectController;

  CreateProjectController = (function() {
    CreateProjectController.$inject = ["tgAppMetaService", "$translate", "tgProjectService", "$location", "$tgAuth"];

    function CreateProjectController(appMetaService, translate, projectService, location, authService) {
      this.appMetaService = appMetaService;
      this.translate = translate;
      this.projectService = projectService;
      this.location = location;
      this.authService = authService;
      taiga.defineImmutableProperty(this, "project", (function(_this) {
        return function() {
          return _this.projectService.project;
        };
      })(this));
      this.appMetaService.setfn(this._setMeta.bind(this));
      this.authService.refresh();
      this.displayScrumDesc = false;
      this.displayKanbanDesc = false;
    }

    CreateProjectController.prototype._setMeta = function() {
      var ctx;
      if (!this.project) {
        return null;
      }
      ctx = {
        projectName: this.project.get("name")
      };
      return {
        title: this.translate.instant("PROJECT.PAGE_TITLE", ctx),
        description: this.project.get("description")
      };
    };

    CreateProjectController.prototype.displayHelp = function(type, $event) {
      $event.stopPropagation();
      $event.preventDefault();
      if (type === 'scrum') {
        this.displayScrumDesc = !this.displayScrumDesc;
      }
      if (type === 'kanban') {
        return this.displayKanbanDesc = !this.displayKanbanDesc;
      }
    };

    return CreateProjectController;

  })();

  angular.module("taigaProjects").controller("CreateProjectCtrl", CreateProjectController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/duplicate/duplicate-project.controller.coffee
 */

(function() {
  var DuplicateProjectController;

  DuplicateProjectController = (function() {
    DuplicateProjectController.$inject = ["tgCurrentUserService", "tgProjectsService", "$tgLocation", "$tgNavUrls"];

    function DuplicateProjectController(currentUserService, projectsService, location, navUrls) {
      this.currentUserService = currentUserService;
      this.projectsService = projectsService;
      this.location = location;
      this.navUrls = navUrls;
      this.user = this.currentUserService.getUser();
      this.members = Immutable.List();
      this.canCreatePublicProjects = this.currentUserService.canCreatePublicProjects();
      this.canCreatePrivateProjects = this.currentUserService.canCreatePrivateProjects();
      taiga.defineImmutableProperty(this, 'projects', (function(_this) {
        return function() {
          return _this.currentUserService.projects.get("all");
        };
      })(this));
      this.projectForm = {
        is_private: false
      };
      if (!this.canCreatePublicProjects.valid && this.canCreatePrivateProjects.valid) {
        this.projectForm.is_private = true;
      }
    }

    DuplicateProjectController.prototype.refreshReferenceProject = function(slug) {
      return this.projectsService.getProjectBySlug(slug).then((function(_this) {
        return function(project) {
          _this.referenceProject = project;
          _this.members = project.get('members').filter(function(it) {
            return it.get('id') !== _this.user.get('id');
          });
          _this.invitedMembers = _this.members.map(function(it) {
            return it.get('id');
          });
          return _this.checkUsersLimit();
        };
      })(this));
    };

    DuplicateProjectController.prototype.toggleInvitedMember = function(member) {
      if (this.invitedMembers.includes(member)) {
        this.invitedMembers = this.invitedMembers.filter(function(it) {
          return it !== member;
        });
      } else {
        this.invitedMembers = this.invitedMembers.push(member);
      }
      return this.checkUsersLimit();
    };

    DuplicateProjectController.prototype.checkUsersLimit = function() {
      this.limitMembersPrivateProject = this.currentUserService.canAddMembersPrivateProject(this.invitedMembers.size + 1);
      return this.limitMembersPublicProject = this.currentUserService.canAddMembersPublicProject(this.invitedMembers.size + 1);
    };

    DuplicateProjectController.prototype.submit = function() {
      var data, projectId;
      projectId = this.referenceProject.get('id');
      data = this.projectForm;
      data.users = this.invitedMembers;
      this.formSubmitLoading = true;
      return this.projectsService.duplicate(projectId, data).then((function(_this) {
        return function(newProject) {
          _this.formSubmitLoading = false;
          _this.location.path(_this.navUrls.resolve("project", {
            project: newProject.data.slug
          }));
          return _this.currentUserService.loadProjects();
        };
      })(this));
    };

    DuplicateProjectController.prototype.canCreateProject = function() {
      if (this.projectForm.is_private) {
        return this.canCreatePrivateProjects.valid && this.limitMembersPrivateProject.valid;
      } else {
        return this.canCreatePublicProjects.valid && this.limitMembersPublicProject.valid;
      }
    };

    DuplicateProjectController.prototype.isDisabled = function() {
      return this.formSubmitLoading || !this.canCreateProject();
    };

    DuplicateProjectController.prototype.onCancelForm = function() {
      return this.location.path(this.navUrls.resolve("create-project"));
    };

    return DuplicateProjectController;

  })();

  angular.module("taigaProjects").controller("DuplicateProjectCtrl", DuplicateProjectController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/duplicate/duplicate-project.directive.coffee
 */

(function() {
  var DuplicateProjectDirective;

  DuplicateProjectDirective = function() {
    var link;
    link = function(scope, el, attr, ctrl) {};
    return {
      link: link,
      templateUrl: "projects/create/duplicate/duplicate-project.html",
      controller: "DuplicateProjectCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {}
    };
  };

  DuplicateProjectDirective.$inject = [];

  angular.module("taigaProjects").directive("tgDuplicateProject", DuplicateProjectDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/github-import/github-import-project-form/github-import-project-form.controller.coffee
 */

(function() {
  var GithubImportProjectFormController;

  GithubImportProjectFormController = (function() {
    GithubImportProjectFormController.$inject = ["tgCurrentUserService"];

    function GithubImportProjectFormController(currentUserService) {
      this.currentUserService = currentUserService;
      this.canCreatePublicProjects = this.currentUserService.canCreatePublicProjects();
      this.canCreatePrivateProjects = this.currentUserService.canCreatePrivateProjects();
      this.projectForm = this.project.toJS();
      this.platformName = "Github";
      this.projectForm.is_private = false;
      this.projectForm.keepExternalReference = false;
      this.projectForm.project_type = "kanban";
      if (!this.canCreatePublicProjects.valid && this.canCreatePrivateProjects.valid) {
        this.projectForm.is_private = true;
      }
    }

    GithubImportProjectFormController.prototype.checkUsersLimit = function() {
      this.limitMembersPrivateProject = this.currentUserService.canAddMembersPrivateProject(this.members.size);
      return this.limitMembersPublicProject = this.currentUserService.canAddMembersPublicProject(this.members.size);
    };

    GithubImportProjectFormController.prototype.saveForm = function() {
      return this.onSaveProjectDetails({
        project: Immutable.fromJS(this.projectForm)
      });
    };

    GithubImportProjectFormController.prototype.canCreateProject = function() {
      if (this.projectForm.is_private) {
        return this.canCreatePrivateProjects.valid;
      } else {
        return this.canCreatePublicProjects.valid;
      }
    };

    GithubImportProjectFormController.prototype.isDisabled = function() {
      return !this.canCreateProject();
    };

    return GithubImportProjectFormController;

  })();

  angular.module('taigaProjects').controller('GithubImportProjectFormCtrl', GithubImportProjectFormController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/github-import/github-import-project-form/github-import-project-form.directive.coffee
 */

(function() {
  var GithubImportProjectFormDirective;

  GithubImportProjectFormDirective = function() {
    return {
      link: function(scope, elm, attr, ctrl) {
        return scope.$watch('vm.members', ctrl.checkUsersLimit.bind(ctrl));
      },
      templateUrl: "projects/create/github-import/github-import-project-form/github-import-project-form.html",
      controller: "GithubImportProjectFormCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        members: '<',
        project: '<',
        onSaveProjectDetails: '&',
        onCancelForm: '&',
        fetchingUsers: '<'
      }
    };
  };

  GithubImportProjectFormDirective.$inject = [];

  angular.module("taigaProjects").directive("tgGithubImportProjectForm", GithubImportProjectFormDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/github-import/github-import.controller.coffee
 */

(function() {
  var GithubImportController;

  GithubImportController = (function() {
    GithubImportController.$inject = ['tgGithubImportService', '$tgConfirm', '$translate', 'tgImportProjectService'];

    function GithubImportController(githubImportService, confirm, translate, importProjectService) {
      this.githubImportService = githubImportService;
      this.confirm = confirm;
      this.translate = translate;
      this.importProjectService = importProjectService;
      this.step = 'autorization-github';
      this.project = null;
      taiga.defineImmutableProperty(this, 'projects', (function(_this) {
        return function() {
          return _this.githubImportService.projects;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'members', (function(_this) {
        return function() {
          return _this.githubImportService.projectUsers;
        };
      })(this));
    }

    GithubImportController.prototype.startProjectSelector = function() {
      this.step = 'project-select-github';
      return this.githubImportService.fetchProjects();
    };

    GithubImportController.prototype.onSelectProject = function(project) {
      this.step = 'project-form-github';
      this.project = project;
      this.fetchingUsers = true;
      return this.githubImportService.fetchUsers(this.project.get('id')).then((function(_this) {
        return function() {
          return _this.fetchingUsers = false;
        };
      })(this));
    };

    GithubImportController.prototype.onSaveProjectDetails = function(project) {
      this.project = project;
      return this.step = 'project-members-github';
    };

    GithubImportController.prototype.onCancelMemberSelection = function() {
      return this.step = 'project-form-github';
    };

    GithubImportController.prototype.startImport = function(users) {
      var loader, promise;
      loader = this.confirm.loader(this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.TITLE'), this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.DESCRIPTION'), true);
      loader.start();
      promise = this.githubImportService.importProject(this.project.get('name'), this.project.get('description'), this.project.get('id'), users, this.project.get('keepExternalReference'), this.project.get('is_private'), this.project.get('project_type'));
      return this.importProjectService.importPromise(promise).then((function(_this) {
        return function() {
          return loader.stop();
        };
      })(this));
    };

    GithubImportController.prototype.submitUserSelection = function(users) {
      this.startImport(users);
      return null;
    };

    return GithubImportController;

  })();

  angular.module('taigaProjects').controller('GithubImportCtrl', GithubImportController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/github-import/github-import.directive.coffee
 */

(function() {
  var GithubImportDirective;

  GithubImportDirective = function() {
    return {
      link: function(scope, elm, attrs, ctrl) {
        return ctrl.startProjectSelector();
      },
      templateUrl: "projects/create/github-import/github-import.html",
      controller: "GithubImportCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        onCancel: '&'
      }
    };
  };

  GithubImportDirective.$inject = [];

  angular.module("taigaProjects").directive("tgGithubImport", GithubImportDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/github-import/github-import.service.coffee
 */

(function() {
  var GithubImportService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  GithubImportService = (function(superClass) {
    extend(GithubImportService, superClass);

    GithubImportService.$inject = ['tgResources'];

    function GithubImportService(resources, location) {
      this.resources = resources;
      this.location = location;
      this.projects = Immutable.List();
      this.projectUsers = Immutable.List();
    }

    GithubImportService.prototype.setToken = function(token) {
      return this.token = token;
    };

    GithubImportService.prototype.fetchProjects = function() {
      return this.resources.githubImporter.listProjects(this.token).then((function(_this) {
        return function(projects) {
          return _this.projects = projects;
        };
      })(this));
    };

    GithubImportService.prototype.fetchUsers = function(projectId) {
      return this.resources.githubImporter.listUsers(this.token, projectId).then((function(_this) {
        return function(users) {
          return _this.projectUsers = users;
        };
      })(this));
    };

    GithubImportService.prototype.importProject = function(name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType) {
      return this.resources.githubImporter.importProject(this.token, name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType);
    };

    GithubImportService.prototype.getAuthUrl = function(callbackUri) {
      return new Promise((function(_this) {
        return function(resolve) {
          return _this.resources.githubImporter.getAuthUrl(callbackUri).then(function(response) {
            _this.authUrl = response.data.url;
            return resolve(_this.authUrl);
          });
        };
      })(this));
    };

    GithubImportService.prototype.authorize = function(code) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.resources.githubImporter.authorize(code).then((function(response) {
            _this.token = response.data.token;
            return resolve(_this.token);
          }), function(error) {
            return reject(new Error(error.status));
          });
        };
      })(this));
    };

    return GithubImportService;

  })(taiga.Service);

  angular.module("taigaProjects").service("tgGithubImportService", GithubImportService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import-project-members/import-project-members.controller.coffee
 */

(function() {
  var ImportProjectMembersController;

  ImportProjectMembersController = (function() {
    ImportProjectMembersController.$inject = ['tgCurrentUserService', 'tgUserService'];

    function ImportProjectMembersController(currentUserService, userService) {
      this.currentUserService = currentUserService;
      this.userService = userService;
      this.selectImportUserLightbox = false;
      this.warningImportUsers = false;
      this.displayEmailSelector = true;
      this.cancelledUsers = Immutable.List();
      this.selectedUsers = Immutable.List();
      this.selectableUsers = Immutable.List();
      this.userContacts = Immutable.List();
    }

    ImportProjectMembersController.prototype.fetchUser = function() {
      this.currentUser = this.currentUserService.getUser();
      return this.userService.getContacts(this.currentUser.get('id')).then((function(_this) {
        return function(userContacts) {
          _this.userContacts = userContacts;
          return _this.refreshSelectableUsers();
        };
      })(this));
    };

    ImportProjectMembersController.prototype.searchUser = function(user) {
      this.selectImportUserLightbox = true;
      return this.searchingUser = user;
    };

    ImportProjectMembersController.prototype.beforeSubmitUsers = function() {
      if (this.selectedUsers.size !== this.members.size) {
        return this.warningImportUsers = true;
      } else {
        return this.submit();
      }
    };

    ImportProjectMembersController.prototype.confirmUser = function(externalUser, taigaUser) {
      var user;
      this.selectImportUserLightbox = false;
      user = Immutable.Map();
      user = user.set('user', externalUser);
      user = user.set('taigaUser', taigaUser);
      this.selectedUsers = this.selectedUsers.push(user);
      this.discardSuggestedUser(externalUser);
      return this.refreshSelectableUsers();
    };

    ImportProjectMembersController.prototype.unselectUser = function(user) {
      var index;
      index = this.selectedUsers.findIndex(function(it) {
        return it.getIn(['user', 'id']) === user.get('id');
      });
      this.selectedUsers = this.selectedUsers["delete"](index);
      return this.refreshSelectableUsers();
    };

    ImportProjectMembersController.prototype.discardSuggestedUser = function(member) {
      return this.cancelledUsers = this.cancelledUsers.push(member.get('id'));
    };

    ImportProjectMembersController.prototype.getSelectedMember = function(member) {
      return this.selectedUsers.find(function(it) {
        return it.getIn(['user', 'id']) === member.get('id');
      });
    };

    ImportProjectMembersController.prototype.isMemberSelected = function(member) {
      return !!this.getSelectedMember(member);
    };

    ImportProjectMembersController.prototype.getUser = function(user) {
      var userSelected;
      userSelected = this.getSelectedMember(user);
      if (userSelected) {
        return userSelected.get('taigaUser');
      } else {
        return null;
      }
    };

    ImportProjectMembersController.prototype.submit = function() {
      var users;
      this.warningImportUsers = false;
      users = Immutable.Map();
      this.selectedUsers.map(function(it) {
        var id;
        id = '';
        if (_.isString(it.get('taigaUser'))) {
          id = it.get('taigaUser');
        } else {
          id = it.getIn(['taigaUser', 'id']);
        }
        return users = users.set(it.getIn(['user', 'id']), id);
      });
      return this.onSubmit({
        users: users
      });
    };

    ImportProjectMembersController.prototype.checkUsersLimit = function() {
      this.limitMembersPrivateProject = this.currentUserService.canAddMembersPrivateProject(this.members.size + 1);
      return this.limitMembersPublicProject = this.currentUserService.canAddMembersPublicProject(this.members.size + 1);
    };

    ImportProjectMembersController.prototype.showSuggestedMatch = function(member) {
      return member.get('user') && this.cancelledUsers.indexOf(member.get('id')) === -1 && !this.isMemberSelected(member);
    };

    ImportProjectMembersController.prototype.getDistinctSelectedTaigaUsers = function() {
      var ids, users;
      ids = [];
      users = this.selectedUsers.filter(function(it) {
        var id;
        id = it.getIn(['taigaUser', 'id']);
        if (ids.indexOf(id) === -1) {
          ids.push(id);
          return true;
        }
        return false;
      });
      return users.filter((function(_this) {
        return function(it) {
          return it.getIn(['taigaUser', 'id']) !== _this.currentUser.get('id');
        };
      })(this));
    };

    ImportProjectMembersController.prototype.refreshSelectableUsers = function() {
      var users;
      this.importMoreUsersDisabled = this.isImportMoreUsersDisabled();
      if (this.importMoreUsersDisabled) {
        users = this.getDistinctSelectedTaigaUsers();
        this.selectableUsers = users.map(function(it) {
          return it.get('taigaUser');
        });
        this.displayEmailSelector = false;
      } else {
        this.selectableUsers = this.userContacts;
        this.displayEmailSelector = true;
      }
      return this.selectableUsers = this.selectableUsers.push(this.currentUser);
    };

    ImportProjectMembersController.prototype.isImportMoreUsersDisabled = function() {
      var total, users;
      users = this.getDistinctSelectedTaigaUsers();
      total = users.size + 2;
      if (this.project.get('is_private')) {
        return !this.currentUserService.canAddMembersPrivateProject(total).valid;
      } else {
        return !this.currentUserService.canAddMembersPublicProject(total).valid;
      }
    };

    return ImportProjectMembersController;

  })();

  angular.module('taigaProjects').controller('ImportProjectMembersCtrl', ImportProjectMembersController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import-project-members/import-project-members.directive.coffee
 */

(function() {
  var ImportProjectMembersDirective;

  ImportProjectMembersDirective = function() {
    return {
      link: function(scope, elm, attr, ctrl) {
        ctrl.fetchUser();
        return scope.$watch('vm.members', ctrl.checkUsersLimit.bind(ctrl));
      },
      templateUrl: "projects/create/import-project-members/import-project-members.html",
      controller: "ImportProjectMembersCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        members: '<',
        project: '<',
        onSubmit: '&',
        platform: '@',
        logo: '@',
        onCancel: '&'
      }
    };
  };

  ImportProjectMembersDirective.$inject = [];

  angular.module("taigaProjects").directive("tgImportProjectMembers", ImportProjectMembersDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import-project-selector/import-project-selector.controller.coffee
 */

(function() {
  var ImportProjectSelectorController;

  ImportProjectSelectorController = (function() {
    function ImportProjectSelectorController() {}

    ImportProjectSelectorController.prototype.selectProject = function(project) {
      return this.onSelectProject({
        project: Immutable.fromJS(project)
      });
    };

    return ImportProjectSelectorController;

  })();

  angular.module('taigaProjects').controller('ImportProjectSelectorCtrl', ImportProjectSelectorController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import-project-selector/import-project-selector.directive.coffee
 */

(function() {
  var ImportProjectSelectorDirective;

  ImportProjectSelectorDirective = function() {
    return {
      templateUrl: "projects/create/import-project-selector/import-project-selector.html",
      controller: "ImportProjectSelectorCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        projects: '<',
        onCancel: '&',
        onSelectProject: '&',
        logo: '@',
        noProjectsMsg: '@',
        search: '@'
      }
    };
  };

  angular.module("taigaProjects").directive("tgImportProjectSelector", ImportProjectSelectorDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import-taiga/import-taiga.controller.coffee
 */

(function() {
  var ImportTaigaController;

  ImportTaigaController = (function() {
    ImportTaigaController.$inject = ['$tgConfirm', '$tgResources', 'tgImportProjectService', '$translate', '$tgAnalytics'];

    function ImportTaigaController(confirm, rs, importProjectService, translate, analytics) {
      this.confirm = confirm;
      this.rs = rs;
      this.importProjectService = importProjectService;
      this.translate = translate;
      this.analytics = analytics;
    }

    ImportTaigaController.prototype.importTaiga = function(files) {
      var file, loader, promise;
      this.analytics.trackEvent("import", "taiga", "Start import from taiga", 1);
      file = files[0];
      loader = this.confirm.loader(this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.TITLE'), this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.DESCRIPTION'), true);
      loader.start();
      promise = this.rs.projects["import"](file, loader.update);
      this.importProjectService.importPromise(promise)["finally"](function() {
        return loader.stop();
      });
    };

    return ImportTaigaController;

  })();

  angular.module("taigaProjects").controller("ImportTaigaCtrl", ImportTaigaController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import-taiga/import-taiga.directive.coffee
 */

(function() {
  var ImportTaigaDirective;

  ImportTaigaDirective = function() {
    return {
      templateUrl: "projects/create/import-taiga/import-taiga.html",
      controller: "ImportTaigaCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {}
    };
  };

  angular.module("taigaProjects").directive("tgImportTaiga", ImportTaigaDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import/import-project-error-lb.directive.coffee
 */

(function() {
  var LbImportErrorDirective;

  LbImportErrorDirective = function(lightboxService) {
    var link;
    link = function(scope, el, attrs) {
      lightboxService.open(el);
      return scope.close = function() {
        lightboxService.close(el);
      };
    };
    return {
      templateUrl: "projects/create/import/import-project-error-lb.html",
      link: link
    };
  };

  LbImportErrorDirective.$inject = ["lightboxService"];

  angular.module("taigaProjects").directive("tgLbImportError", LbImportErrorDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import/import-project.controller.coffee
 */

(function() {
  var ImportProjectController;

  ImportProjectController = (function() {
    ImportProjectController.$inject = ['tgTrelloImportService', 'tgJiraImportService', 'tgGithubImportService', 'tgAsanaImportService', '$location', '$window', '$routeParams', '$tgNavUrls', '$tgConfig', '$tgConfirm', '$tgAnalytics'];

    function ImportProjectController(trelloService, jiraService, githubService, asanaService, location, window, routeParams, tgNavUrls, config, confirm, analytics) {
      this.trelloService = trelloService;
      this.jiraService = jiraService;
      this.githubService = githubService;
      this.asanaService = asanaService;
      this.location = location;
      this.window = window;
      this.routeParams = routeParams;
      this.tgNavUrls = tgNavUrls;
      this.config = config;
      this.confirm = confirm;
      this.analytics = analytics;
    }

    ImportProjectController.prototype.start = function() {
      var asanaOauthToken, githubOauthToken, jiraOauthToken, jiraOauthVerifier, locationSearch, trelloOauthToken;
      this.token = null;
      this.from = this.routeParams.platform;
      locationSearch = this.location.search();
      if (this.from) {
        this.analytics.trackEvent("import", this.from, "Start import from " + this.from, 1);
      }
      if (this.from === "asana") {
        asanaOauthToken = locationSearch.code;
        if (locationSearch.code) {
          asanaOauthToken = locationSearch.code;
          return this.asanaService.authorize(asanaOauthToken).then(((function(_this) {
            return function(token) {
              return _this.location.search({
                token: encodeURIComponent(JSON.stringify(token))
              });
            };
          })(this)), this.cancelCurrentImport.bind(this));
        } else {
          this.token = JSON.parse(decodeURIComponent(locationSearch.token));
          this.asanaService.setToken(this.token);
        }
      }
      if (this.from === 'trello') {
        if (locationSearch.oauth_verifier) {
          trelloOauthToken = locationSearch.oauth_verifier;
          return this.trelloService.authorize(trelloOauthToken).then(((function(_this) {
            return function(token) {
              return _this.location.search({
                token: token
              });
            };
          })(this)), this.cancelCurrentImport.bind(this));
        } else if (locationSearch.token) {
          this.token = locationSearch.token;
          this.trelloService.setToken(locationSearch.token);
        }
      }
      if (this.from === "github") {
        if (locationSearch.code) {
          githubOauthToken = locationSearch.code;
          return this.githubService.authorize(githubOauthToken).then(((function(_this) {
            return function(token) {
              return _this.location.search({
                token: token
              });
            };
          })(this)), this.cancelCurrentImport.bind(this));
        } else if (locationSearch.token) {
          this.token = locationSearch.token;
          this.githubService.setToken(locationSearch.token);
        }
      }
      if (this.from === "jira") {
        jiraOauthToken = locationSearch.oauth_token;
        if (jiraOauthToken) {
          jiraOauthVerifier = locationSearch.oauth_verifier;
          return this.jiraService.authorize(jiraOauthVerifier).then(((function(_this) {
            return function(data) {
              return _this.location.search({
                token: data.token,
                url: data.url
              });
            };
          })(this)), this.cancelCurrentImport.bind(this));
        } else {
          this.token = locationSearch.token;
          return this.jiraService.setToken(locationSearch.token, locationSearch.url);
        }
      }
    };

    ImportProjectController.prototype.select = function(from) {
      var callbackUri;
      if (from === "trello") {
        return this.trelloService.getAuthUrl().then((function(_this) {
          return function(url) {
            return _this.window.open(url, "_self");
          };
        })(this));
      } else if (from === "jira") {
        return this.jiraService.getAuthUrl(this.jiraUrl).then((function(_this) {
          return function(url) {
            return _this.window.open(url, "_self");
          };
        })(this), (function(_this) {
          return function(err) {
            return _this.confirm.notify('error', err);
          };
        })(this));
      } else if (from === "github") {
        callbackUri = this.location.absUrl() + "/github";
        return this.githubService.getAuthUrl(callbackUri).then((function(_this) {
          return function(url) {
            return _this.window.open(url, "_self");
          };
        })(this));
      } else if (from === "asana") {
        return this.asanaService.getAuthUrl().then((function(_this) {
          return function(url) {
            return _this.window.open(url, "_self");
          };
        })(this));
      } else {
        return this.from = from;
      }
    };

    ImportProjectController.prototype.unfoldOptions = function(options) {
      return this.unfoldedOptions = options;
    };

    ImportProjectController.prototype.isActiveImporter = function(importer) {
      if (this.config.get('importers').indexOf(importer) === -1) {
        return false;
      }
      return true;
    };

    ImportProjectController.prototype.cancelCurrentImport = function() {
      return this.location.url(this.tgNavUrls.resolve('create-project-import'));
    };

    ImportProjectController.prototype.backToCreate = function() {
      return this.location.url(this.tgNavUrls.resolve('create-project'));
    };

    return ImportProjectController;

  })();

  angular.module("taigaProjects").controller("ImportProjectCtrl", ImportProjectController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import/import-project.directive.coffee
 */

(function() {
  var ImportProjectDirective;

  ImportProjectDirective = function() {
    var link;
    link = function(scope, el, attr, ctrl) {
      return ctrl.start();
    };
    return {
      link: link,
      templateUrl: "projects/create/import/import-project.html",
      controller: "ImportProjectCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        onCancelImport: '&'
      }
    };
  };

  ImportProjectDirective.$inject = [];

  angular.module("taigaProjects").directive("tgImportProject", ImportProjectDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/import/import-project.service.coffee
 */

(function() {
  var ImportProjectService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ImportProjectService = (function(superClass) {
    extend(ImportProjectService, superClass);

    ImportProjectService.$inject = ['tgCurrentUserService', '$tgAuth', 'tgLightboxFactory', '$translate', '$tgConfirm', '$location', '$tgNavUrls'];

    function ImportProjectService(currentUserService, tgAuth, lightboxFactory, translate, confirm, location, tgNavUrls) {
      this.currentUserService = currentUserService;
      this.tgAuth = tgAuth;
      this.lightboxFactory = lightboxFactory;
      this.translate = translate;
      this.confirm = confirm;
      this.location = location;
      this.tgNavUrls = tgNavUrls;
    }

    ImportProjectService.prototype.importPromise = function(promise) {
      return promise.then(this.importSuccess.bind(this), this.importError.bind(this));
    };

    ImportProjectService.prototype.importSuccess = function(result) {
      var promise;
      promise = this.currentUserService.loadProjects();
      promise.then((function(_this) {
        return function() {
          var ctx, message, msg, title;
          if (result.status === 202) {
            title = _this.translate.instant('PROJECT.IMPORT.ASYNC_IN_PROGRESS_TITLE');
            message = _this.translate.instant('PROJECT.IMPORT.ASYNC_IN_PROGRESS_MESSAGE');
            _this.location.path(_this.tgNavUrls.resolve('home'));
            return _this.confirm.success(title, message);
          } else {
            ctx = {
              project: result.data.slug
            };
            _this.location.path(_this.tgNavUrls.resolve('project-admin-project-profile-details', ctx));
            msg = _this.translate.instant('PROJECT.IMPORT.SYNC_SUCCESS');
            return _this.confirm.notify('success', msg);
          }
        };
      })(this));
      return promise;
    };

    ImportProjectService.prototype.importError = function(result) {
      var promise;
      promise = this.tgAuth.refresh();
      promise.then((function(_this) {
        return function() {
          var errorMsg, ref, restrictionError;
          restrictionError = _this.getRestrictionError(result);
          if (restrictionError) {
            return _this.lightboxFactory.create('tg-lb-import-error', {
              "class": 'lightbox lightbox-import-error'
            }, restrictionError);
          } else {
            errorMsg = _this.translate.instant("PROJECT.IMPORT.ERROR");
            if (result.status === 429) {
              errorMsg = _this.translate.instant("PROJECT.IMPORT.ERROR_TOO_MANY_REQUEST");
            } else if ((ref = result.data) != null ? ref._error_message : void 0) {
              errorMsg = _this.translate.instant("PROJECT.IMPORT.ERROR_MESSAGE", {
                error_message: result.data._error_message
              });
            }
            return _this.confirm.notify("error", errorMsg);
          }
        };
      })(this));
      return promise;
    };

    ImportProjectService.prototype.getRestrictionError = function(result) {
      var errorKey, maxMemberships, membersError, privateError, publicError, user;
      if (result.headers) {
        errorKey = '';
        user = this.currentUserService.getUser();
        maxMemberships = null;
        if (result.headers.isPrivate) {
          privateError = !this.currentUserService.canCreatePrivateProjects().valid;
          if (user.get('max_memberships_private_projects') !== null && result.headers.memberships >= user.get('max_memberships_private_projects')) {
            membersError = true;
          } else {
            membersError = false;
          }
          if (privateError && membersError) {
            errorKey = 'private-space-members';
            maxMemberships = user.get('max_memberships_private_projects');
          } else if (privateError) {
            errorKey = 'private-space';
          } else if (membersError) {
            errorKey = 'private-members';
            maxMemberships = user.get('max_memberships_private_projects');
          }
        } else {
          publicError = !this.currentUserService.canCreatePublicProjects().valid;
          if (user.get('max_memberships_public_projects') !== null && result.headers.memberships >= user.get('max_memberships_public_projects')) {
            membersError = true;
          } else {
            membersError = false;
          }
          if (publicError && membersError) {
            errorKey = 'public-space-members';
            maxMemberships = user.get('max_memberships_public_projects');
          } else if (publicError) {
            errorKey = 'public-space';
          } else if (membersError) {
            errorKey = 'public-members';
            maxMemberships = user.get('max_memberships_public_projects');
          }
        }
        if (!errorKey) {
          return false;
        }
        return {
          key: errorKey,
          values: {
            max_memberships: maxMemberships,
            members: result.headers.memberships
          }
        };
      } else {
        return false;
      }
    };

    return ImportProjectService;

  })(taiga.Service);

  angular.module("taigaProjects").service("tgImportProjectService", ImportProjectService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/invite-members/invite-members.controller.coffee
 */

(function() {
  var InviteMembersController;

  InviteMembersController = (function() {
    function InviteMembersController() {}

    InviteMembersController.$inject = [];

    InviteMembersController.prototype.isDisabled = function(id) {
      return this.invitedMembers.indexOf(id) === -1;
    };

    return InviteMembersController;

  })();

  angular.module("taigaProjects").controller("InviteMembersCtrl", InviteMembersController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/invite-members/invite-members.directive.coffee
 */

(function() {
  var InviteMembersDirective;

  InviteMembersDirective = function() {
    var link;
    link = function(scope, el, attr, ctrl) {};
    return {
      link: link,
      templateUrl: "projects/create/invite-members/invite-members.html",
      controller: "InviteMembersCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        invitedMembers: '<',
        members: '<',
        onToggleInvitedMember: '&'
      }
    };
  };

  InviteMembersDirective.$inject = [];

  angular.module("taigaProjects").directive("tgInviteMembers", InviteMembersDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/invite-members/single-member/single-member.directive.coffee
 */

(function() {
  var SingleMemberDirective;

  SingleMemberDirective = function() {
    return {
      templateUrl: "projects/create/invite-members/single-member/single-member.html",
      scope: {
        disabled: "<",
        avatar: "="
      }
    };
  };

  SingleMemberDirective.$inject = [];

  angular.module("taigaProjects").directive("tgSingleMember", SingleMemberDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/jira-import/jira-import-project-form/jira-import-project-form.controller.coffee
 */

(function() {
  var JiraImportProjectFormController;

  JiraImportProjectFormController = (function() {
    JiraImportProjectFormController.$inject = ["tgCurrentUserService"];

    function JiraImportProjectFormController(currentUserService) {
      this.currentUserService = currentUserService;
      this.canCreatePublicProjects = this.currentUserService.canCreatePublicProjects();
      this.canCreatePrivateProjects = this.currentUserService.canCreatePrivateProjects();
      this.projectForm = this.project.toJS();
      this.projectForm.is_private = false;
      this.projectForm.keepExternalReference = false;
      if (this.projectForm.importer_type === "agile") {
        this.projectForm.project_type = null;
      } else {
        this.projectForm.project_type = "scrum";
      }
      this.projectForm.create_subissues = true;
      if (!this.canCreatePublicProjects.valid && this.canCreatePrivateProjects.valid) {
        this.projectForm.is_private = true;
      }
    }

    JiraImportProjectFormController.prototype.checkUsersLimit = function() {
      this.limitMembersPrivateProject = this.currentUserService.canAddMembersPrivateProject(this.members.size);
      return this.limitMembersPublicProject = this.currentUserService.canAddMembersPublicProject(this.members.size);
    };

    JiraImportProjectFormController.prototype.saveForm = function() {
      return this.onSaveProjectDetails({
        project: Immutable.fromJS(this.projectForm)
      });
    };

    JiraImportProjectFormController.prototype.canCreateProject = function() {
      if (this.projectForm.is_private) {
        return this.canCreatePrivateProjects.valid;
      } else {
        return this.canCreatePublicProjects.valid;
      }
    };

    JiraImportProjectFormController.prototype.isDisabled = function() {
      return !this.canCreateProject();
    };

    return JiraImportProjectFormController;

  })();

  angular.module('taigaProjects').controller('JiraImportProjectFormCtrl', JiraImportProjectFormController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/jira-import/jira-import-project-form/jira-import-project-form.directive.coffee
 */

(function() {
  var JiraImportProjectFormDirective;

  JiraImportProjectFormDirective = function() {
    return {
      link: function(scope, elm, attr, ctrl) {
        return scope.$watch('vm.members', ctrl.checkUsersLimit.bind(ctrl));
      },
      templateUrl: "projects/create/jira-import/jira-import-project-form/jira-import-project-form.html",
      controller: "JiraImportProjectFormCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        members: '<',
        project: '<',
        onSaveProjectDetails: '&',
        onCancelForm: '&',
        fetchingUsers: '<'
      }
    };
  };

  JiraImportProjectFormDirective.$inject = [];

  angular.module("taigaProjects").directive("tgJiraImportProjectForm", JiraImportProjectFormDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/jira-import/jira-import.controller.coffee
 */

(function() {
  var JiraImportController;

  JiraImportController = (function() {
    JiraImportController.$inject = ['tgJiraImportService', '$tgConfirm', '$translate', 'tgImportProjectService'];

    function JiraImportController(jiraImportService, confirm, translate, importProjectService) {
      this.jiraImportService = jiraImportService;
      this.confirm = confirm;
      this.translate = translate;
      this.importProjectService = importProjectService;
      this.step = 'autorization-jira';
      this.project = null;
      taiga.defineImmutableProperty(this, 'projects', (function(_this) {
        return function() {
          return _this.jiraImportService.projects;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'members', (function(_this) {
        return function() {
          return _this.jiraImportService.projectUsers;
        };
      })(this));
    }

    JiraImportController.prototype.startProjectSelector = function() {
      this.step = 'project-select-jira';
      return this.jiraImportService.fetchProjects();
    };

    JiraImportController.prototype.onSelectProject = function(project) {
      this.step = 'project-form-jira';
      this.project = project;
      this.fetchingUsers = true;
      return this.jiraImportService.fetchUsers(this.project.get('id')).then((function(_this) {
        return function() {
          return _this.fetchingUsers = false;
        };
      })(this));
    };

    JiraImportController.prototype.onSaveProjectDetails = function(project) {
      this.project = project;
      return this.step = 'project-members-jira';
    };

    JiraImportController.prototype.onCancelMemberSelection = function() {
      return this.step = 'project-form-jira';
    };

    JiraImportController.prototype.startImport = function(users) {
      var loader, projectType, promise;
      loader = this.confirm.loader(this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.TITLE'), this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.DESCRIPTION'), true);
      loader.start();
      projectType = this.project.get('project_type');
      if (projectType === "issues" && this.project.get('create_subissues')) {
        projectType = "issues-with-subissues";
      }
      promise = this.jiraImportService.importProject(this.project.get('name'), this.project.get('description'), this.project.get('id'), users, this.project.get('keepExternalReference'), this.project.get('is_private'), projectType, this.project.get('importer_type'));
      return this.importProjectService.importPromise(promise).then((function(_this) {
        return function() {
          return loader.stop();
        };
      })(this));
    };

    JiraImportController.prototype.submitUserSelection = function(users) {
      this.startImport(users);
      return null;
    };

    return JiraImportController;

  })();

  angular.module('taigaProjects').controller('JiraImportCtrl', JiraImportController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/jira-import/jira-import.directive.coffee
 */

(function() {
  var JiraImportDirective;

  JiraImportDirective = function() {
    return {
      link: function(scope, elm, attrs, ctrl) {
        return ctrl.startProjectSelector();
      },
      templateUrl: "projects/create/jira-import/jira-import.html",
      controller: "JiraImportCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        onCancel: '&'
      }
    };
  };

  JiraImportDirective.$inject = [];

  angular.module("taigaProjects").directive("tgJiraImport", JiraImportDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/jira-import/jira-import.service.coffee
 */

(function() {
  var JiraImportService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  JiraImportService = (function(superClass) {
    extend(JiraImportService, superClass);

    JiraImportService.$inject = ['tgResources', '$location'];

    function JiraImportService(resources, location) {
      this.resources = resources;
      this.location = location;
      this.projects = Immutable.List();
      this.projectUsers = Immutable.List();
    }

    JiraImportService.prototype.setToken = function(token, url) {
      this.token = token;
      return this.url = url;
    };

    JiraImportService.prototype.fetchProjects = function() {
      return this.resources.jiraImporter.listProjects(this.url, this.token).then((function(_this) {
        return function(projects) {
          return _this.projects = projects;
        };
      })(this));
    };

    JiraImportService.prototype.fetchUsers = function(projectId) {
      return this.resources.jiraImporter.listUsers(this.url, this.token, projectId).then((function(_this) {
        return function(users) {
          return _this.projectUsers = users;
        };
      })(this));
    };

    JiraImportService.prototype.importProject = function(name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType, importerType) {
      return this.resources.jiraImporter.importProject(this.url, this.token, name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType, importerType);
    };

    JiraImportService.prototype.getAuthUrl = function(url) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.resources.jiraImporter.getAuthUrl(url).then(function(response) {
            _this.authUrl = response.data.url;
            return resolve(_this.authUrl);
          }, function(err) {
            return reject(err.data._error_message);
          });
        };
      })(this));
    };

    JiraImportService.prototype.authorize = function(oauth_verifier) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.resources.jiraImporter.authorize(oauth_verifier).then((function(response) {
            _this.token = response.data.token;
            _this.url = response.data.url;
            return resolve(response.data);
          }), function(error) {
            return reject(new Error(error.status));
          });
        };
      })(this));
    };

    return JiraImportService;

  })(taiga.Service);

  angular.module("taigaProjects").service("tgJiraImportService", JiraImportService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/select-import-user-lightbox/select-import-user-lightbox.controller.coffee
 */

(function() {
  var SelectImportUserLightboxCtrl;

  SelectImportUserLightboxCtrl = (function() {
    SelectImportUserLightboxCtrl.$inject = [];

    function SelectImportUserLightboxCtrl() {}

    SelectImportUserLightboxCtrl.prototype.start = function() {
      this.mode = 'search';
      return this.invalid = false;
    };

    SelectImportUserLightboxCtrl.prototype.assignUser = function() {
      return this.onSelectUser({
        user: this.user,
        taigaUser: this.userEmail
      });
    };

    SelectImportUserLightboxCtrl.prototype.selectUser = function(taigaUser) {
      return this.onSelectUser({
        user: this.user,
        taigaUser: Immutable.fromJS(taigaUser)
      });
    };

    return SelectImportUserLightboxCtrl;

  })();

  angular.module('taigaProjects').controller('SelectImportUserLightboxCtrl', SelectImportUserLightboxCtrl);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/select-import-user-lightbox/select-import-user-lightbox.directive.coffee
 */

(function() {
  var SelectImportUserLightboxDirective;

  SelectImportUserLightboxDirective = function(lightboxService, lightboxKeyboardNavigationService) {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return scope.$watch('vm.visible', function(visible) {
        if (visible && !el.hasClass('open')) {
          ctrl.start();
          return lightboxService.open(el, null, scope.vm.onClose).then(function() {
            el.find('input').focus();
            return lightboxKeyboardNavigationService.init(el);
          });
        } else if (!visible && el.hasClass('open')) {
          return lightboxService.close(el).then(function() {
            ctrl.userEmail = '';
            return ctrl.usersSearch = '';
          });
        }
      });
    };
    return {
      controller: "SelectImportUserLightboxCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        user: '<',
        visible: '<',
        onClose: '&',
        onSelectUser: '&',
        selectableUsers: '<',
        isPrivate: '<',
        limitMembersPrivateProject: '<',
        limitMembersPublicProject: '<',
        displayEmailSelector: '<'
      },
      templateUrl: 'projects/create/select-import-user-lightbox/select-import-user-lightbox.html',
      link: link
    };
  };

  SelectImportUserLightboxDirective.$inject = ['lightboxService', 'lightboxKeyboardNavigationService'];

  angular.module("taigaProjects").directive("tgSelectImportUserLightbox", SelectImportUserLightboxDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/trello-import/trello-import-project-form/trello-import-project-form.controller.coffee
 */

(function() {
  var TrelloImportProjectFormController;

  TrelloImportProjectFormController = (function() {
    TrelloImportProjectFormController.$inject = ["tgCurrentUserService"];

    function TrelloImportProjectFormController(currentUserService) {
      this.currentUserService = currentUserService;
      this.canCreatePublicProjects = this.currentUserService.canCreatePublicProjects();
      this.canCreatePrivateProjects = this.currentUserService.canCreatePrivateProjects();
      this.projectForm = this.project.toJS();
      this.platformName = "Trello";
      this.projectForm.is_private = false;
      this.projectForm.keepExternalReference = false;
      if (!this.canCreatePublicProjects.valid && this.canCreatePrivateProjects.valid) {
        this.projectForm.is_private = true;
      }
    }

    TrelloImportProjectFormController.prototype.checkUsersLimit = function() {
      this.limitMembersPrivateProject = this.currentUserService.canAddMembersPrivateProject(this.members.size);
      return this.limitMembersPublicProject = this.currentUserService.canAddMembersPublicProject(this.members.size);
    };

    TrelloImportProjectFormController.prototype.saveForm = function() {
      return this.onSaveProjectDetails({
        project: Immutable.fromJS(this.projectForm)
      });
    };

    TrelloImportProjectFormController.prototype.canCreateProject = function() {
      if (this.projectForm.is_private) {
        return this.canCreatePrivateProjects.valid;
      } else {
        return this.canCreatePublicProjects.valid;
      }
    };

    TrelloImportProjectFormController.prototype.isDisabled = function() {
      return !this.canCreateProject();
    };

    return TrelloImportProjectFormController;

  })();

  angular.module('taigaProjects').controller('TrelloImportProjectFormCtrl', TrelloImportProjectFormController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/trello-import/trello-import-project-form/trello-import-project-form.directive.coffee
 */

(function() {
  var TrelloImportProjectFormDirective;

  TrelloImportProjectFormDirective = function() {
    return {
      link: function(scope, elm, attr, ctrl) {
        return scope.$watch('vm.members', ctrl.checkUsersLimit.bind(ctrl));
      },
      templateUrl: "projects/create/trello-import/trello-import-project-form/trello-import-project-form.html",
      controller: "TrelloImportProjectFormCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        members: '<',
        project: '<',
        onSaveProjectDetails: '&',
        onCancelForm: '&',
        fetchingUsers: '<'
      }
    };
  };

  TrelloImportProjectFormDirective.$inject = [];

  angular.module("taigaProjects").directive("tgTrelloImportProjectForm", TrelloImportProjectFormDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/trello-import/trello-import.controller.coffee
 */

(function() {
  var TrelloImportController;

  TrelloImportController = (function() {
    TrelloImportController.$inject = ['tgTrelloImportService', '$tgConfirm', '$translate', 'tgImportProjectService'];

    function TrelloImportController(trelloImportService, confirm, translate, importProjectService) {
      this.trelloImportService = trelloImportService;
      this.confirm = confirm;
      this.translate = translate;
      this.importProjectService = importProjectService;
      this.project = null;
      taiga.defineImmutableProperty(this, 'projects', (function(_this) {
        return function() {
          return _this.trelloImportService.projects;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'members', (function(_this) {
        return function() {
          return _this.trelloImportService.projectUsers;
        };
      })(this));
    }

    TrelloImportController.prototype.startProjectSelector = function() {
      return this.trelloImportService.fetchProjects().then((function(_this) {
        return function() {
          return _this.step = 'project-select-trello';
        };
      })(this));
    };

    TrelloImportController.prototype.onSelectProject = function(project) {
      this.step = 'project-form-trello';
      this.project = project;
      this.fetchingUsers = true;
      return this.trelloImportService.fetchUsers(this.project.get('id')).then((function(_this) {
        return function() {
          return _this.fetchingUsers = false;
        };
      })(this));
    };

    TrelloImportController.prototype.onSaveProjectDetails = function(project) {
      this.project = project;
      return this.step = 'project-members-trello';
    };

    TrelloImportController.prototype.onCancelMemberSelection = function() {
      return this.step = 'project-form-trello';
    };

    TrelloImportController.prototype.startImport = function(users) {
      var loader, promise;
      loader = this.confirm.loader(this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.TITLE'), this.translate.instant('PROJECT.IMPORT.IN_PROGRESS.DESCRIPTION'), true);
      loader.start();
      promise = this.trelloImportService.importProject(this.project.get('name'), this.project.get('description'), this.project.get('id'), users, this.project.get('keepExternalReference'), this.project.get('is_private'));
      return this.importProjectService.importPromise(promise).then((function(_this) {
        return function() {
          return loader.stop();
        };
      })(this));
    };

    TrelloImportController.prototype.submitUserSelection = function(users) {
      this.startImport(users);
      return null;
    };

    return TrelloImportController;

  })();

  angular.module('taigaProjects').controller('TrelloImportCtrl', TrelloImportController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/trello-import/trello-import.directive.coffee
 */

(function() {
  var TrelloImportDirective;

  TrelloImportDirective = function() {
    return {
      link: function(scope, elm, attrs, ctrl) {
        return ctrl.startProjectSelector();
      },
      templateUrl: "projects/create/trello-import/trello-import.html",
      controller: "TrelloImportCtrl",
      controllerAs: "vm",
      bindToController: true,
      scope: {
        onCancel: '&'
      }
    };
  };

  TrelloImportDirective.$inject = [];

  angular.module("taigaProjects").directive("tgTrelloImport", TrelloImportDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/trello-import/trello-import.service.coffee
 */

(function() {
  var TrelloImportService,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  TrelloImportService = (function(superClass) {
    extend(TrelloImportService, superClass);

    TrelloImportService.$inject = ['tgResources'];

    function TrelloImportService(resources) {
      this.resources = resources;
      this.projects = Immutable.List();
      this.projectUsers = Immutable.List();
      this.token = null;
    }

    TrelloImportService.prototype.setToken = function(token) {
      return this.token = token;
    };

    TrelloImportService.prototype.fetchProjects = function() {
      return this.resources.trelloImporter.listProjects(this.token).then((function(_this) {
        return function(projects) {
          return _this.projects = projects;
        };
      })(this));
    };

    TrelloImportService.prototype.fetchUsers = function(projectId) {
      return this.resources.trelloImporter.listUsers(this.token, projectId).then((function(_this) {
        return function(users) {
          return _this.projectUsers = users;
        };
      })(this));
    };

    TrelloImportService.prototype.importProject = function(name, description, projectId, userBindings, keepExternalReference, isPrivate) {
      return this.resources.trelloImporter.importProject(this.token, name, description, projectId, userBindings, keepExternalReference, isPrivate);
    };

    TrelloImportService.prototype.getAuthUrl = function() {
      return new Promise((function(_this) {
        return function(resolve) {
          return _this.resources.trelloImporter.getAuthUrl().then(function(response) {
            _this.authUrl = response.data.url;
            return resolve(_this.authUrl);
          });
        };
      })(this));
    };

    TrelloImportService.prototype.authorize = function(verifyCode) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.resources.trelloImporter.authorize(verifyCode).then((function(response) {
            _this.token = response.data.token;
            return resolve(_this.token);
          }), function(error) {
            return reject(new Error(error.status));
          });
        };
      })(this));
    };

    return TrelloImportService;

  })(taiga.Service);

  angular.module("taigaProjects").service("tgTrelloImportService", TrelloImportService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/create/warning-user-import-lightbox/warning-user-import-lightbox.directive.coffee
 */

(function() {
  var WarningUserImportDirective;

  WarningUserImportDirective = function(lightboxService, lightboxKeyboardNavigationService) {
    return {
      link: function(scope, el, attr) {
        return scope.$watch('visible', function(visible) {
          if (visible && !el.hasClass('open')) {
            return lightboxService.open(el, scope.onClose).then(function() {
              el.find('input').focus();
              return lightboxKeyboardNavigationService.init(el);
            });
          } else if (!visible && el.hasClass('open')) {
            return lightboxService.close(el);
          }
        });
      },
      templateUrl: "projects/create/warning-user-import-lightbox/warning-user-import-lightbox.html",
      scope: {
        visible: '<',
        onClose: '&',
        onConfirm: '&'
      }
    };
  };

  WarningUserImportDirective.$inject = ['lightboxService', 'lightboxKeyboardNavigationService'];

  angular.module("taigaProjects").directive("tgWarningUserImportLightbox", WarningUserImportDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/listing/projects-listing.controller.coffee
 */

(function() {
  var ProjectsListingController;

  ProjectsListingController = (function() {
    ProjectsListingController.$inject = ["tgCurrentUserService"];

    function ProjectsListingController(currentUserService) {
      this.currentUserService = currentUserService;
      taiga.defineImmutableProperty(this, "projects", (function(_this) {
        return function() {
          return _this.currentUserService.projects.get("all");
        };
      })(this));
    }

    return ProjectsListingController;

  })();

  angular.module("taigaProjects").controller("ProjectsListing", ProjectsListingController);

}).call(this);


/*
 * Copyright (C) 2014-2017 Taiga Agile LLC <taiga@taiga.io>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: project-router.controller.coffee
 */

(function() {
  var ProjectRouterController;

  ProjectRouterController = (function() {
    ProjectRouterController.$inject = ["$routeParams", "$location", "tgProjectService", "$tgResources", "$tgSections"];

    function ProjectRouterController(routeParams, location, projectService, rs, tgSections) {
      this.routeParams = routeParams;
      this.location = location;
      this.projectService = projectService;
      this.rs = rs;
      this.tgSections = tgSections;
      this.getProjectHomepage().then((function(_this) {
        return function(section) {
          if (section) {
            return _this.location.url("project/" + _this.routeParams.pslug + "/" + section);
          } else {
            return _this.gotoDefaultProjectHomepage();
          }
        };
      })(this)).then(null, function() {
        return this.gotoDefaultProjectHomepage();
      });
    }

    ProjectRouterController.prototype.gotoDefaultProjectHomepage = function() {
      return this.location.url("project/" + this.routeParams.pslug + "/timeline");
    };

    ProjectRouterController.prototype.getProjectHomepage = function() {
      var project;
      project = this.projectService.project.toJS();
      return this.rs.userProjectSettings.list({
        project: project.id
      }).then((function(_this) {
        return function(userProjectSettings) {
          var settings;
          settings = _.find(userProjectSettings, {
            "project": project.id
          });
          if (!settings) {
            return;
          }
          return _this.tgSections.getPath(project.slug, settings.homepage);
        };
      })(this));
    };

    return ProjectRouterController;

  })();

  angular.module("taigaProjects").controller("ProjectRouter", ProjectRouterController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/project/project.controller.coffee
 */

(function() {
  var ProjectController;

  ProjectController = (function() {
    ProjectController.$inject = ["$routeParams", "tgAppMetaService", "$tgAuth", "$translate", "tgProjectService", "$tgConfig", "$tgNavUrls", "$location"];

    function ProjectController(routeParams, appMetaService, auth, translate, projectService, config, navUrls, location) {
      var nextUrl;
      this.routeParams = routeParams;
      this.appMetaService = appMetaService;
      this.auth = auth;
      this.translate = translate;
      this.projectService = projectService;
      this.config = config;
      this.navUrls = navUrls;
      this.location = location;
      this.user = this.auth.userData;
      taiga.defineImmutableProperty(this, "project", (function(_this) {
        return function() {
          return _this.projectService.project;
        };
      })(this));
      taiga.defineImmutableProperty(this, "members", (function(_this) {
        return function() {
          return _this.projectService.activeMembers;
        };
      })(this));
      taiga.defineImmutableProperty(this, "isAuthenticated", (function(_this) {
        return function() {
          return !!_this.user;
        };
      })(this));
      nextUrl = this.location.url();
      this.registerUrl = (this.navUrls.resolve("register")) + "?next=" + nextUrl;
      this.loginUrl = (this.navUrls.resolve("login")) + "?next=" + nextUrl;
      this.publicRegisterEnabled = this.config.get("publicRegisterEnabled");
      this.appMetaService.setfn(this._setMeta.bind(this));
    }

    ProjectController.prototype._setMeta = function() {
      var ctx;
      if (!this.project) {
        return null;
      }
      ctx = {
        projectName: this.project.get("name")
      };
      return {
        title: this.translate.instant("PROJECT.PAGE_TITLE", ctx),
        description: this.project.get("description")
      };
    };

    return ProjectController;

  })();

  angular.module("taigaProjects").controller("Project", ProjectController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/projects.service.coffee
 */

(function() {
  var ProjectsService, groupBy, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  groupBy = this.taiga.groupBy;

  ProjectsService = (function(superClass) {
    extend(ProjectsService, superClass);

    ProjectsService.$inject = ["tgResources", "$projectUrl"];

    function ProjectsService(rs, projectUrl) {
      this.rs = rs;
      this.projectUrl = projectUrl;
    }

    ProjectsService.prototype.create = function(data) {
      return this.rs.projects.create(data);
    };

    ProjectsService.prototype.duplicate = function(projectId, data) {
      return this.rs.projects.duplicate(projectId, data);
    };

    ProjectsService.prototype.getProjectBySlug = function(projectSlug) {
      return this.rs.projects.getProjectBySlug(projectSlug).then((function(_this) {
        return function(project) {
          return _this._decorate(project);
        };
      })(this));
    };

    ProjectsService.prototype.getProjectStats = function(projectId) {
      return this.rs.projects.getProjectStats(projectId);
    };

    ProjectsService.prototype.getProjectsByUserId = function(userId, paginate) {
      return this.rs.projects.getProjectsByUserId(userId, paginate).then((function(_this) {
        return function(projects) {
          return projects.map(_this._decorate.bind(_this));
        };
      })(this));
    };

    ProjectsService.prototype.getListProjectsByUserId = function(userId, paginate) {
      return this.rs.projects.getListProjectsByUserId(userId, paginate).then((function(_this) {
        return function(projects) {
          return projects.map(_this._decorate.bind(_this));
        };
      })(this));
    };

    ProjectsService.prototype._decorate = function(project) {
      var url;
      url = this.projectUrl.get(project.toJS());
      project = project.set("url", url);
      return project;
    };

    ProjectsService.prototype.bulkUpdateProjectsOrder = function(sortData) {
      return this.rs.projects.bulkUpdateOrder(sortData);
    };

    ProjectsService.prototype.transferValidateToken = function(projectId, token) {
      return this.rs.projects.transferValidateToken(projectId, token);
    };

    ProjectsService.prototype.transferAccept = function(projectId, token, reason) {
      return this.rs.projects.transferAccept(projectId, token, reason);
    };

    ProjectsService.prototype.transferReject = function(projectId, token, reason) {
      return this.rs.projects.transferReject(projectId, token, reason);
    };

    return ProjectsService;

  })(taiga.Service);

  angular.module("taigaProjects").service("tgProjectsService", ProjectsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/transfer/cant-own-project-explanation.directive.coffee
 */

(function() {
  var CantOwnProjectExplanationDirective;

  CantOwnProjectExplanationDirective = function() {
    return {
      templateUrl: "projects/transfer/cant-own-project-explanation.html"
    };
  };

  angular.module("taigaProjects").directive("tgCantOwnProjectExplanation", CantOwnProjectExplanationDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/transfer/transfer-project.controller.coffee
 */

(function() {
  var TransferProject, module;

  module = angular.module('taigaProjects');

  TransferProject = (function() {
    TransferProject.$inject = ["$routeParams", "tgProjectsService", "tgProjectService", "$location", "$tgAuth", "tgCurrentUserService", "$tgNavUrls", "$translate", "$tgConfirm", "tgErrorHandlingService"];

    function TransferProject(routeParams, projectsService, projectService, location, authService, currentUserService, navUrls, translate, confirmService, errorHandlingService) {
      this.routeParams = routeParams;
      this.projectsService = projectsService;
      this.projectService = projectService;
      this.location = location;
      this.authService = authService;
      this.currentUserService = currentUserService;
      this.navUrls = navUrls;
      this.translate = translate;
      this.confirmService = confirmService;
      this.errorHandlingService = errorHandlingService;
    }

    TransferProject.prototype.initialize = function() {
      this.projectId = this.project.get("id");
      this.token = this.routeParams.token;
      this.showAddComment = false;
      return this._refreshUserData();
    };

    TransferProject.prototype._validateToken = function() {
      return this.projectsService.transferValidateToken(this.projectId, this.token).then(null, (function(_this) {
        return function(data, status) {
          return _this.errorHandlingService.notfound();
        };
      })(this));
    };

    TransferProject.prototype._refreshUserData = function() {
      return this.authService.refresh().then((function(_this) {
        return function() {
          _this._validateToken();
          _this._setProjectData();
          return _this._checkOwnerData();
        };
      })(this));
    };

    TransferProject.prototype._setProjectData = function() {
      return this.canBeOwnedByUser = this.currentUserService.canOwnProject(this.project);
    };

    TransferProject.prototype._checkOwnerData = function() {
      var currentUser, maxMemberships;
      currentUser = this.currentUserService.getUser();
      if (this.project.get('is_private')) {
        this.ownerMessage = 'ADMIN.PROJECT_TRANSFER.OWNER_MESSAGE.PRIVATE';
        this.maxProjects = currentUser.get('max_private_projects');
        if (this.maxProjects === null) {
          this.maxProjects = this.translate.instant('ADMIN.PROJECT_TRANSFER.UNLIMITED_PROJECTS');
        }
        this.currentProjects = currentUser.get('total_private_projects');
        maxMemberships = currentUser.get('max_memberships_private_projects');
      } else {
        this.ownerMessage = 'ADMIN.PROJECT_TRANSFER.OWNER_MESSAGE.PUBLIC';
        this.maxProjects = currentUser.get('max_public_projects');
        if (this.maxProjects === null) {
          this.maxProjects = this.translate.instant('ADMIN.PROJECT_TRANSFER.UNLIMITED_PROJECTS');
        }
        this.currentProjects = currentUser.get('total_public_projects');
        maxMemberships = currentUser.get('max_memberships_public_projects');
      }
      return this.validNumberOfMemberships = maxMemberships === null || this.project.get('total_memberships') <= maxMemberships;
    };

    TransferProject.prototype.transferAccept = function(token, reason) {
      this.loadingAccept = true;
      return this.projectsService.transferAccept(this.project.get("id"), token, reason).then((function(_this) {
        return function() {
          return _this.projectService.fetchProject().then(function() {
            var newUrl;
            newUrl = _this.navUrls.resolve("project-admin-project-profile-details", {
              project: _this.project.get("slug")
            });
            _this.loadingAccept = false;
            _this.location.path(newUrl);
            _this.confirmService.notify("success", _this.translate.instant("ADMIN.PROJECT_TRANSFER.ACCEPTED_PROJECT_OWNERNSHIP"), '', 5000);
          });
        };
      })(this));
    };

    TransferProject.prototype.transferReject = function(token, reason) {
      this.loadingReject = true;
      return this.projectsService.transferReject(this.project.get("id"), token, reason).then((function(_this) {
        return function() {
          var newUrl;
          newUrl = _this.navUrls.resolve("home", {
            project: _this.project.get("slug")
          });
          _this.loadingReject = false;
          _this.location.path(newUrl);
          _this.confirmService.notify("success", _this.translate.instant("ADMIN.PROJECT_TRANSFER.REJECTED_PROJECT_OWNERNSHIP"), '', 5000);
        };
      })(this));
    };

    TransferProject.prototype.addComment = function() {
      return this.showAddComment = true;
    };

    TransferProject.prototype.hideComment = function() {
      this.showAddComment = false;
      return this.reason = '';
    };

    return TransferProject;

  })();

  module.controller("TransferProjectController", TransferProject);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: projects/transfer/transfer-project.directive.coffee
 */

(function() {
  var TransferProjectDirective, module;

  module = angular.module('taigaProjects');

  TransferProjectDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return ctrl.initialize();
    };
    return {
      link: link,
      scope: {},
      bindToController: {
        project: "="
      },
      templateUrl: "projects/transfer/transfer-project.html",
      controller: 'TransferProjectController',
      controllerAs: 'vm'
    };
  };

  module.directive('tgTransferProject', TransferProjectDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/attachments-resource.service.coffee
 */

(function() {
  var Resource, module, sizeFormat, taiga;

  taiga = this.taiga;

  sizeFormat = this.taiga.sizeFormat;

  Resource = function(urlsService, http, config, $rootScope, $q, storage) {
    var service;
    service = {};
    service.list = function(type, objectId, projectId) {
      var httpOptions, params, url, urlname;
      urlname = "attachments/" + type;
      params = {
        object_id: objectId,
        project: projectId
      };
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      url = urlsService.resolve(urlname);
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.get = function(type, id) {
      var url, urlname;
      urlname = "attachments/" + type;
      url = urlsService.resolve(urlname) + ("/" + id);
      return http.get(url);
    };
    service["delete"] = function(type, id) {
      var url, urlname;
      urlname = "attachments/" + type;
      url = urlsService.resolve(urlname) + ("/" + id);
      return http["delete"](url);
    };
    service.patch = function(type, id, patch) {
      var url, urlname;
      urlname = "attachments/" + type;
      url = urlsService.resolve(urlname) + ("/" + id);
      return http.patch(url, patch);
    };
    service.create = function(type, projectId, objectId, file, from_comment) {
      var data, defered, maxFileSize, response, token, uploadComplete, uploadFailed, uploadProgress, url, urlname, xhr;
      urlname = "attachments/" + type;
      url = urlsService.resolve(urlname);
      defered = $q.defer();
      if (file === void 0) {
        defered.reject(null);
        return defered.promise;
      }
      maxFileSize = config.get("maxUploadFileSize", null);
      if (maxFileSize && file.size > maxFileSize) {
        response = {
          status: 413,
          data: {
            _error_message: "'" + file.name + "' (" + (sizeFormat(file.size)) + ") is too heavy for our oompa loompas, try it with a smaller than (" + (sizeFormat(maxFileSize)) + ")"
          }
        };
        defered.reject(response);
        return defered.promise;
      }
      uploadProgress = (function(_this) {
        return function(evt) {
          return $rootScope.$apply(function() {
            file.status = "in-progress";
            file.size = sizeFormat(evt.total);
            file.progressMessage = "upload " + (sizeFormat(evt.loaded)) + " of " + (sizeFormat(evt.total));
            return file.progressPercent = (Math.round((evt.loaded / evt.total) * 100)) + "%";
          });
        };
      })(this);
      uploadComplete = (function(_this) {
        return function(evt) {
          return $rootScope.$apply(function() {
            var attachment, ref, status;
            file.status = "done";
            status = evt.target.status;
            try {
              attachment = JSON.parse(evt.target.responseText);
            } catch (error) {
              attachment = {};
            }
            if (status >= 200 && status < 400) {
              attachment = Immutable.fromJS(attachment);
              return defered.resolve(attachment);
            } else {
              response = {
                status: status,
                data: {
                  _error_message: (ref = data['attached_file']) != null ? ref[0] : void 0
                }
              };
              return defered.reject(response);
            }
          });
        };
      })(this);
      uploadFailed = (function(_this) {
        return function(evt) {
          return $rootScope.$apply(function() {
            file.status = "error";
            return defered.reject("fail");
          });
        };
      })(this);
      data = new FormData();
      data.append("project", projectId);
      data.append("object_id", objectId);
      data.append("attached_file", file);
      data.append("from_comment", from_comment);
      xhr = new XMLHttpRequest();
      xhr.upload.addEventListener("progress", uploadProgress, false);
      xhr.addEventListener("load", uploadComplete, false);
      xhr.addEventListener("error", uploadFailed, false);
      token = storage.get('token');
      xhr.open("POST", url);
      xhr.setRequestHeader("Authorization", "Bearer " + token);
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send(data);
      return defered.promise;
    };
    return function() {
      return {
        "attachments": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp", "$tgConfig", "$rootScope", "$q", "$tgStorage"];

  module = angular.module("taigaResources2");

  module.factory("tgAttachmentsResource", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/epics-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http) {
    var service;
    service = {};
    service.listInAllProjects = function(params) {
      var httpOptions, url;
      url = urlsService.resolve("epics");
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.list = function(projectId, page) {
      var params, url;
      if (page == null) {
        page = 0;
      }
      url = urlsService.resolve("epics");
      params = {
        project: projectId,
        page: page
      };
      return http.get(url, params).then(function(result) {
        return {
          list: Immutable.fromJS(result.data),
          headers: result.headers
        };
      });
    };
    service.patch = function(id, patch) {
      var url;
      url = urlsService.resolve("epics") + ("/" + id);
      return http.patch(url, patch).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.post = function(params) {
      var url;
      url = urlsService.resolve("epics");
      return http.post(url, params).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.reorder = function(id, data, setOrders) {
      var options, url;
      url = urlsService.resolve("epics") + ("/" + id);
      options = {
        "headers": {
          "set-orders": JSON.stringify(setOrders)
        }
      };
      return http.patch(url, data, null, options).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.addRelatedUserstory = function(epicId, userstoryId) {
      var params, url;
      url = urlsService.resolve("epic-related-userstories", epicId);
      params = {
        user_story: userstoryId,
        epic: epicId
      };
      return http.post(url, params);
    };
    service.reorderRelatedUserstory = function(epicId, userstoryId, data, setOrders) {
      var options, url;
      url = urlsService.resolve("epic-related-userstories", epicId) + ("/" + userstoryId);
      options = {
        "headers": {
          "set-orders": JSON.stringify(setOrders)
        }
      };
      return http.patch(url, data, null, options);
    };
    service.bulkCreateRelatedUserStories = function(epicId, projectId, bulk_userstories) {
      var params, url;
      url = urlsService.resolve("epic-related-userstories-bulk-create", epicId);
      params = {
        bulk_userstories: bulk_userstories,
        project_id: projectId
      };
      return http.post(url, params);
    };
    service.deleteRelatedUserstory = function(epicId, userstoryId) {
      var url;
      url = urlsService.resolve("epic-related-userstories", epicId) + ("/" + userstoryId);
      return http["delete"](url);
    };
    return function() {
      return {
        "epics": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgEpicsResource", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/external-apps-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http) {
    var service;
    service = {};
    service.getApplicationToken = function(applicationId, state) {
      var url;
      url = urlsService.resolve("applications");
      url = url + "/" + applicationId + "/token?state=" + state;
      return http.get(url).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.authorizeApplicationToken = function(applicationId, state) {
      var data, url;
      url = urlsService.resolve("application-tokens");
      url = url + "/authorize";
      data = {
        "state": state,
        "application": applicationId
      };
      return http.post(url, data).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    return function() {
      return {
        "externalapps": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgExternalAppsResource", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/history-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http) {
    var service;
    service = {};
    service.getHistory = function(historyType, contentType, objectId, page) {
      var url;
      url = urlsService.resolve("history/" + contentType);
      return http.get(url + "/" + objectId, {
        page: page,
        type: historyType
      }).then(function(result) {
        return {
          list: Immutable.fromJS(result.data),
          headers: result.headers
        };
      });
    };
    return function() {
      return {
        "history": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgHistory", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/importers-resource.service.coffee
 */

(function() {
  var AsanaResource, GithubResource, JiraResource, TrelloResource, module, taiga;

  taiga = this.taiga;

  TrelloResource = function(urlsService, http) {
    var service;
    service = {};
    service.getAuthUrl = function(url) {
      url = urlsService.resolve("importers-trello-auth-url");
      return http.get(url);
    };
    service.authorize = function(verifyCode) {
      var url;
      url = urlsService.resolve("importers-trello-authorize");
      return http.post(url, {
        code: verifyCode
      });
    };
    service.listProjects = function(token) {
      var url;
      url = urlsService.resolve("importers-trello-list-projects");
      return http.post(url, {
        token: token
      }).then(function(response) {
        return Immutable.fromJS(response.data);
      });
    };
    service.listUsers = function(token, projectId) {
      var url;
      url = urlsService.resolve("importers-trello-list-users");
      return http.post(url, {
        token: token,
        project: projectId
      }).then(function(response) {
        return Immutable.fromJS(response.data);
      });
    };
    service.importProject = function(token, name, description, projectId, userBindings, keepExternalReference, isPrivate) {
      var data, url;
      url = urlsService.resolve("importers-trello-import-project");
      data = {
        token: token,
        name: name,
        description: description,
        project: projectId,
        users_bindings: userBindings.toJS(),
        keep_external_reference: keepExternalReference,
        is_private: isPrivate,
        template: "kanban"
      };
      return http.post(url, data);
    };
    return function() {
      return {
        "trelloImporter": service
      };
    };
  };

  TrelloResource.$inject = ["$tgUrls", "$tgHttp"];

  JiraResource = function(urlsService, http) {
    var service;
    service = {};
    service.getAuthUrl = function(jira_url) {
      var url;
      url = urlsService.resolve("importers-jira-auth-url") + "?url=" + jira_url;
      return http.get(url);
    };
    service.authorize = function(oauth_verifier) {
      var url;
      url = urlsService.resolve("importers-jira-authorize");
      return http.post(url, {
        oauth_verifier: oauth_verifier
      });
    };
    service.listProjects = function(jira_url, token) {
      var url;
      url = urlsService.resolve("importers-jira-list-projects");
      return http.post(url, {
        url: jira_url,
        token: token
      }).then(function(response) {
        return Immutable.fromJS(response.data);
      });
    };
    service.listUsers = function(jira_url, token, projectId) {
      var url;
      url = urlsService.resolve("importers-jira-list-users");
      return http.post(url, {
        url: jira_url,
        token: token,
        project: projectId
      }).then(function(response) {
        return Immutable.fromJS(response.data);
      });
    };
    service.importProject = function(jira_url, token, name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType, importerType) {
      var data, projectTemplate, url;
      url = urlsService.resolve("importers-jira-import-project");
      projectTemplate = "kanban";
      if (projectType !== "kanban") {
        projectTemplate = "scrum";
      }
      data = {
        url: jira_url,
        token: token,
        name: name,
        description: description,
        project: projectId,
        users_bindings: userBindings.toJS(),
        keep_external_reference: keepExternalReference,
        is_private: isPrivate,
        project_type: projectType,
        importer_type: importerType,
        template: projectTemplate
      };
      return http.post(url, data);
    };
    return function() {
      return {
        "jiraImporter": service
      };
    };
  };

  JiraResource.$inject = ["$tgUrls", "$tgHttp"];

  GithubResource = function(urlsService, http) {
    var service;
    service = {};
    service.getAuthUrl = function(callbackUri) {
      var url;
      url = urlsService.resolve("importers-github-auth-url") + "?uri=" + callbackUri;
      return http.get(url);
    };
    service.authorize = function(code) {
      var url;
      url = urlsService.resolve("importers-github-authorize");
      return http.post(url, {
        code: code
      });
    };
    service.listProjects = function(token) {
      var url;
      url = urlsService.resolve("importers-github-list-projects");
      return http.post(url, {
        token: token
      }).then(function(response) {
        return Immutable.fromJS(response.data);
      });
    };
    service.listUsers = function(token, projectId) {
      var url;
      url = urlsService.resolve("importers-github-list-users");
      return http.post(url, {
        token: token,
        project: projectId
      }).then(function(response) {
        return Immutable.fromJS(response.data);
      });
    };
    service.importProject = function(token, name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType) {
      var data, url;
      url = urlsService.resolve("importers-github-import-project");
      data = {
        token: token,
        name: name,
        description: description,
        project: projectId,
        users_bindings: userBindings.toJS(),
        keep_external_reference: keepExternalReference,
        is_private: isPrivate,
        template: projectType
      };
      return http.post(url, data);
    };
    return function() {
      return {
        "githubImporter": service
      };
    };
  };

  GithubResource.$inject = ["$tgUrls", "$tgHttp"];

  AsanaResource = function(urlsService, http) {
    var service;
    service = {};
    service.getAuthUrl = function() {
      var url;
      url = urlsService.resolve("importers-asana-auth-url");
      return http.get(url);
    };
    service.authorize = function(code) {
      var url;
      url = urlsService.resolve("importers-asana-authorize");
      return http.post(url, {
        code: code
      });
    };
    service.listProjects = function(token) {
      var url;
      url = urlsService.resolve("importers-asana-list-projects");
      return http.post(url, {
        token: token
      }).then(function(response) {
        return Immutable.fromJS(response.data);
      });
    };
    service.listUsers = function(token, projectId) {
      var url;
      url = urlsService.resolve("importers-asana-list-users");
      return http.post(url, {
        token: token,
        project: projectId
      }).then(function(response) {
        return Immutable.fromJS(response.data);
      });
    };
    service.importProject = function(token, name, description, projectId, userBindings, keepExternalReference, isPrivate, projectType) {
      var data, url;
      url = urlsService.resolve("importers-asana-import-project");
      data = {
        token: token,
        name: name,
        description: description,
        project: projectId,
        users_bindings: userBindings.toJS(),
        keep_external_reference: keepExternalReference,
        is_private: isPrivate,
        template: projectType
      };
      return http.post(url, data);
    };
    return function() {
      return {
        "asanaImporter": service
      };
    };
  };

  AsanaResource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgTrelloImportResource", TrelloResource);

  module.factory("tgJiraImportResource", JiraResource);

  module.factory("tgGithubImportResource", GithubResource);

  module.factory("tgAsanaImportResource", AsanaResource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/issues-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http) {
    var service;
    service = {};
    service.listInAllProjects = function(params) {
      var httpOptions, url;
      url = urlsService.resolve("issues");
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    return function() {
      return {
        "issues": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgIssuesResource", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/projects-resource.service.coffee
 */

(function() {
  var Resource, module, pagination;

  pagination = function() {};

  Resource = function(urlsService, http, paginateResponseService) {
    var service;
    service = {};
    service.create = function(data) {
      var url;
      url = urlsService.resolve('projects');
      return http.post(url, JSON.stringify(data)).then((function(_this) {
        return function(result) {
          return Immutable.fromJS(result.data);
        };
      })(this));
    };
    service.duplicate = function(projectId, data) {
      var members, params, url;
      url = urlsService.resolve("projects");
      url = url + "/" + projectId + "/duplicate";
      members = data.users.map((function(_this) {
        return function(member) {
          return {
            "id": member
          };
        };
      })(this));
      params = {
        "name": data.name,
        "description": data.description,
        "is_private": data.is_private,
        "users": members
      };
      return http.post(url, params);
    };
    service.getProjects = function(params, pagination) {
      var httpOptions, url;
      if (params == null) {
        params = {};
      }
      if (pagination == null) {
        pagination = true;
      }
      url = urlsService.resolve("projects");
      httpOptions = {};
      if (!pagination) {
        httpOptions = {
          headers: {
            "x-lazy-pagination": true
          }
        };
      }
      return http.get(url, params, httpOptions);
    };
    service.getProjectBySlug = function(projectSlug) {
      var url;
      url = urlsService.resolve("projects");
      url = url + "/by_slug?slug=" + projectSlug;
      return http.get(url).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.getProjectsByUserId = function(userId, paginate) {
      var httpOptions, params, url;
      if (paginate == null) {
        paginate = false;
      }
      url = urlsService.resolve("projects");
      httpOptions = {};
      if (!paginate) {
        httpOptions.headers = {
          "x-disable-pagination": "1"
        };
      }
      params = {
        "member": userId,
        "order_by": "user_order"
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.getListProjectsByUserId = function(userId, paginate) {
      var httpOptions, params, url;
      if (paginate == null) {
        paginate = false;
      }
      url = urlsService.resolve("projects");
      httpOptions = {};
      if (!paginate) {
        httpOptions.headers = {
          "x-disable-pagination": "1"
        };
      }
      params = {
        "member": userId,
        "order_by": "user_order",
        "slight": true
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.getProjectStats = function(projectId) {
      var url;
      url = urlsService.resolve("projects");
      url = url + "/" + projectId;
      return http.get(url).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.bulkUpdateOrder = function(bulkData) {
      var url;
      url = urlsService.resolve("bulk-update-projects-order");
      return http.post(url, bulkData);
    };
    service.getTimeline = function(projectId, page) {
      var params, url;
      params = {
        page: page,
        only_relevant: true
      };
      url = urlsService.resolve("timeline-project");
      url = url + "/" + projectId;
      return http.get(url, params, {
        headers: {
          'x-lazy-pagination': true
        }
      }).then(function(result) {
        result = Immutable.fromJS(result);
        return paginateResponseService(result);
      });
    };
    service.likeProject = function(projectId) {
      var url;
      url = urlsService.resolve("project-like", projectId);
      return http.post(url);
    };
    service.unlikeProject = function(projectId) {
      var url;
      url = urlsService.resolve("project-unlike", projectId);
      return http.post(url);
    };
    service.watchProject = function(projectId, notifyLevel) {
      var data, url;
      data = {
        notify_level: notifyLevel,
        live_notify_level: notifyLevel
      };
      url = urlsService.resolve("project-watch", projectId);
      return http.post(url, data);
    };
    service.unwatchProject = function(projectId) {
      var url;
      url = urlsService.resolve("project-unwatch", projectId);
      return http.post(url);
    };
    service.contactProject = function(projectId, message) {
      var params, url;
      params = {
        project: projectId,
        comment: message
      };
      url = urlsService.resolve("project-contact");
      return http.post(url, params);
    };
    service.transferValidateToken = function(projectId, token) {
      var data, url;
      data = {
        token: token
      };
      url = urlsService.resolve("project-transfer-validate-token", projectId);
      return http.post(url, data);
    };
    service.transferAccept = function(projectId, token, reason) {
      var data, url;
      data = {
        token: token,
        reason: reason
      };
      url = urlsService.resolve("project-transfer-accept", projectId);
      return http.post(url, data);
    };
    service.transferReject = function(projectId, token, reason) {
      var data, url;
      data = {
        token: token,
        reason: reason
      };
      url = urlsService.resolve("project-transfer-reject", projectId);
      return http.post(url, data);
    };
    service.transferRequest = function(projectId) {
      var url;
      url = urlsService.resolve("project-transfer-request", projectId);
      return http.post(url);
    };
    service.transferStart = function(projectId, userId, reason) {
      var data, url;
      data = {
        user: userId,
        reason: reason
      };
      url = urlsService.resolve("project-transfer-start", projectId);
      return http.post(url, data);
    };
    return function() {
      return {
        "projects": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp", "tgPaginateResponseService"];

  module = angular.module("taigaResources2");

  module.factory("tgProjectsResources", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/resources.coffee
 */

(function() {
  var Resources, services;

  services = ["tgProjectsResources", "tgUserResources", "tgUsersResources", "tgUserstoriesResource", "tgTasksResource", "tgIssuesResource", "tgExternalAppsResource", "tgAttachmentsResource", "tgStatsResource", "tgHistory", "tgEpicsResource", "tgTrelloImportResource", "tgJiraImportResource", "tgGithubImportResource", "tgAsanaImportResource"];

  Resources = function($injector) {
    var i, j, len, len1, ref, service, serviceFn, serviceName, serviceProperty;
    for (i = 0, len = services.length; i < len; i++) {
      serviceName = services[i];
      serviceFn = $injector.get(serviceName);
      service = $injector.invoke(serviceFn);
      ref = Object.keys(service);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        serviceProperty = ref[j];
        if (this[serviceProperty]) {
          console.warn("repeated resource " + serviceProperty);
        }
        this[serviceProperty] = service[serviceProperty];
      }
    }
    return this;
  };

  Resources.$inject = ["$injector"];

  angular.module("taigaResources2").service("tgResources", Resources);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/stats-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http) {
    var service;
    service = {};
    service.discover = function(applicationId, state) {
      var url;
      url = urlsService.resolve("stats-discover");
      return http.get(url).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    return function() {
      return {
        "stats": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgStatsResource", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/tasks-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http) {
    var service;
    service = {};
    service.listInAllProjects = function(params) {
      var httpOptions, url;
      url = urlsService.resolve("tasks");
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    return function() {
      return {
        "tasks": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgTasksResource", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/user-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http, paginateResponseService) {
    var service;
    service = {};
    service.getUserStorage = function(key) {
      var httpOptions, url;
      url = urlsService.resolve("user-storage");
      if (key) {
        url += '/' + key;
      }
      httpOptions = {};
      return http.get(url, {}).then(function(response) {
        return response.data.value;
      });
    };
    service.setUserStorage = function(key, value) {
      var params, url;
      url = urlsService.resolve("user-storage") + '/' + key;
      params = {
        key: key,
        value: value
      };
      return http.put(url, params);
    };
    service.createUserStorage = function(key, value) {
      var params, url;
      url = urlsService.resolve("user-storage");
      params = {
        key: key,
        value: value
      };
      return http.post(url, params);
    };
    return function() {
      return {
        "user": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgUserResources", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/users-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http, paginateResponseService) {
    var service;
    service = {};
    service.getUserByUsername = function(username) {
      var httpOptions, params, url;
      url = urlsService.resolve("by_username");
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      params = {
        username: username
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.getStats = function(userId) {
      var httpOptions, url;
      url = urlsService.resolve("user-stats", userId);
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      return http.get(url, {}, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.getContacts = function(userId, excludeProjectId) {
      var httpOptions, params, url;
      url = urlsService.resolve("user-contacts", userId);
      params = {};
      if (excludeProjectId != null) {
        params.exclude_project = excludeProjectId;
      }
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.getLiked = function(userId, page, type, q) {
      var params, url;
      url = urlsService.resolve("user-liked", userId);
      params = {};
      if (page != null) {
        params.page = page;
      }
      if (type != null) {
        params.type = type;
      }
      if (q != null) {
        params.q = q;
      }
      params.only_relevant = true;
      return http.get(url, params, {
        headers: {
          'x-lazy-pagination': true
        }
      }).then(function(result) {
        result = Immutable.fromJS(result);
        return paginateResponseService(result);
      });
    };
    service.getVoted = function(userId, page, type, q) {
      var params, url;
      url = urlsService.resolve("user-voted", userId);
      params = {};
      if (page != null) {
        params.page = page;
      }
      if (type != null) {
        params.type = type;
      }
      if (q != null) {
        params.q = q;
      }
      return http.get(url, params, {
        headers: {
          'x-lazy-pagination': true
        }
      }).then(function(result) {
        result = Immutable.fromJS(result);
        return paginateResponseService(result);
      });
    };
    service.getWatched = function(userId, page, type, q) {
      var params, url;
      url = urlsService.resolve("user-watched", userId);
      params = {};
      if (page != null) {
        params.page = page;
      }
      if (type != null) {
        params.type = type;
      }
      if (q != null) {
        params.q = q;
      }
      return http.get(url, params, {
        headers: {
          'x-lazy-pagination': true
        }
      }).then(function(result) {
        result = Immutable.fromJS(result);
        return paginateResponseService(result);
      });
    };
    service.getProfileTimeline = function(userId, page) {
      var params, url;
      params = {
        page: page
      };
      url = urlsService.resolve("timeline-profile");
      url = url + "/" + userId;
      return http.get(url, params, {
        headers: {
          'x-lazy-pagination': true
        }
      }).then(function(result) {
        result = Immutable.fromJS(result);
        return paginateResponseService(result);
      });
    };
    service.getUserTimeline = function(userId, page) {
      var params, url;
      params = {
        page: page,
        only_relevant: true
      };
      url = urlsService.resolve("timeline-user");
      url = url + "/" + userId;
      return http.get(url, params, {
        headers: {
          'x-lazy-pagination': true
        }
      }).then(function(result) {
        result = Immutable.fromJS(result);
        return paginateResponseService(result);
      });
    };
    service.getNotifications = function(userId, page, onlyUnread) {
      var params, url;
      params = {
        page: page
      };
      if (onlyUnread) {
        params['only_unread'] = true;
      }
      url = urlsService.resolve("notifications");
      return http.get(url, params, {
        headers: {
          'x-lazy-pagination': true
        }
      }).then(function(result) {
        var paginateResponse;
        result = Immutable.fromJS(result);
        paginateResponse = Immutable.Map({
          "data": result.get("data").get("objects"),
          "next": !!result.get("headers")("x-pagination-next"),
          "prev": !!result.get("headers")("x-pagination-prev"),
          "current": result.get("headers")("x-pagination-current"),
          "count": result.get("headers")("x-pagination-count"),
          "total": result.get("data").get("total")
        });
        return paginateResponse;
      });
    };
    service.setNotificationAsRead = function(notificationId) {
      var url;
      url = (urlsService.resolve("notifications")) + "/" + notificationId + "/set-as-read";
      return http.patch(url).then(function(result) {
        return result;
      });
    };
    service.setNotificationsAsRead = function() {
      var url;
      url = (urlsService.resolve("notifications")) + "/set-as-read";
      return http.post(url).then(function(result) {
        return result;
      });
    };
    return function() {
      return {
        "users": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp", "tgPaginateResponseService"];

  module = angular.module("taigaResources2");

  module.factory("tgUsersResources", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: resources/userstories-resource.service.coffee
 */

(function() {
  var Resource, module;

  Resource = function(urlsService, http) {
    var service;
    service = {};
    service.listInAllProjects = function(params, pagination) {
      var httpOptions, url;
      if (pagination == null) {
        pagination = false;
      }
      url = urlsService.resolve("userstories");
      if (!pagination) {
        httpOptions = {
          headers: {
            "x-disable-pagination": "1"
          }
        };
      }
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.listAllInProject = function(projectId) {
      var httpOptions, params, url;
      url = urlsService.resolve("userstories");
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      params = {
        project: projectId
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    service.listInEpic = function(epicIid) {
      var httpOptions, params, url;
      url = urlsService.resolve("userstories");
      httpOptions = {
        headers: {
          "x-disable-pagination": "1"
        }
      };
      params = {
        epic: epicIid,
        order_by: 'epic_order',
        include_tasks: true
      };
      return http.get(url, params, httpOptions).then(function(result) {
        return Immutable.fromJS(result.data);
      });
    };
    return function() {
      return {
        "userstories": service
      };
    };
  };

  Resource.$inject = ["$tgUrls", "$tgHttp"];

  module = angular.module("taigaResources2");

  module.factory("tgUserstoriesResource", Resource);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/app-meta.service.coffee
 */

(function() {
  var AppMetaService, taiga, truncate;

  taiga = this.taiga;

  truncate = taiga.truncate;

  AppMetaService = (function() {
    AppMetaService.$inject = ["$rootScope"];

    function AppMetaService(rootScope) {
      this.rootScope = rootScope;
    }

    AppMetaService.prototype._set = function(key, value) {
      var meta;
      if (!key) {
        return;
      }
      if (key === "title") {
        meta = $("head title");
        if (meta.length === 0) {
          meta = $("<title></title>");
          $("head").append(meta);
        }
        return meta.text(value || "");
      } else if (key.indexOf("og:") === 0) {
        meta = $("head meta[property='" + key + "']");
        if (meta.length === 0) {
          meta = $("<meta property='" + key + "'/>");
          $("head").append(meta);
        }
        return meta.attr("content", value || "");
      } else {
        meta = $("head meta[name='" + key + "']");
        if (meta.length === 0) {
          meta = $("<meta name='" + key + "'/>");
          $("head").append(meta);
        }
        return meta.attr("content", value || "");
      }
    };

    AppMetaService.prototype.setTitle = function(title) {
      return this._set('title', title);
    };

    AppMetaService.prototype.setDescription = function(description) {
      return this._set("description", truncate(description, 250));
    };

    AppMetaService.prototype.setTwitterMetas = function(title, description) {
      this._set("twitter:card", "summary");
      this._set("twitter:site", "@taigaio");
      this._set("twitter:title", title);
      this._set("twitter:description", truncate(description, 300));
      return this._set("twitter:image", window.location.origin + "/" + window._version + "/images/logo-color.png");
    };

    AppMetaService.prototype.setOpenGraphMetas = function(title, description) {
      this._set("og:type", "object");
      this._set("og:site_name", "Taiga - Love your projects");
      this._set("og:title", title);
      this._set("og:description", truncate(description, 300));
      this._set("og:image", window.location.origin + "/" + window._version + "/images/logo-color.png");
      return this._set("og:url", window.location.href);
    };

    AppMetaService.prototype.setAll = function(title, description) {
      this.setTitle(title);
      this.setDescription(description);
      this.setTwitterMetas(title, description);
      return this.setOpenGraphMetas(title, description);
    };

    AppMetaService.prototype.addMobileViewport = function() {
      return $("head").append("<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\">");
    };

    AppMetaService.prototype.removeMobileViewport = function() {
      return $("head meta[name=\"viewport\"]").remove();
    };

    AppMetaService.prototype.setfn = function(fn) {
      if (this.listener) {
        this._listener();
      }
      return this._listener = this.rootScope.$watchCollection(fn, (function(_this) {
        return function(metas) {
          if (metas) {
            _this.setAll(metas.title, metas.description);
            return _this._listener();
          }
        };
      })(this));
    };

    return AppMetaService;

  })();

  angular.module("taigaCommon").service("tgAppMetaService", AppMetaService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/attachments.service.coffee
 */

(function() {
  var AttachmentsService, sizeFormat;

  sizeFormat = this.taiga.sizeFormat;

  AttachmentsService = (function() {
    AttachmentsService.$inject = ["$tgConfirm", "$tgConfig", "$translate", "tgResources"];

    function AttachmentsService(confirm, config, translate, rs) {
      this.confirm = confirm;
      this.config = config;
      this.translate = translate;
      this.rs = rs;
      this.maxFileSize = this.getMaxFileSize();
      if (this.maxFileSize) {
        this.maxFileSizeFormated = sizeFormat(this.maxFileSize);
      }
    }

    AttachmentsService.prototype.sizeError = function(file) {
      var message;
      message = this.translate.instant("ATTACHMENT.ERROR_MAX_SIZE_EXCEEDED", {
        fileName: file.name,
        fileSize: sizeFormat(file.size),
        maxFileSize: this.maxFileSizeFormated
      });
      return this.confirm.notify("error", message);
    };

    AttachmentsService.prototype.validate = function(file) {
      if (this.maxFileSize && file.size > this.maxFileSize) {
        this.sizeError(file);
        return false;
      }
      return true;
    };

    AttachmentsService.prototype.getMaxFileSize = function() {
      return this.config.get("maxUploadFileSize", null);
    };

    AttachmentsService.prototype.list = function(type, objId, projectId) {
      return this.rs.attachments.list(type, objId, projectId).then((function(_this) {
        return function(attachments) {
          return attachments.sortBy(function(attachment) {
            return attachment.get('order');
          });
        };
      })(this));
    };

    AttachmentsService.prototype.get = function(type, id) {
      return this.rs.attachments.get(type, id);
    };

    AttachmentsService.prototype["delete"] = function(type, id) {
      return this.rs.attachments["delete"](type, id);
    };

    AttachmentsService.prototype.saveError = function(file, data) {
      var message;
      message = "";
      if (file) {
        message = this.translate.instant("ATTACHMENT.ERROR_UPLOAD_ATTACHMENT", {
          fileName: file.name,
          errorMessage: data.data._error_message
        });
      }
      return this.confirm.notify("error", message);
    };

    AttachmentsService.prototype.upload = function(file, objId, projectId, type, from_comment) {
      var promise;
      if (from_comment == null) {
        from_comment = false;
      }
      promise = this.rs.attachments.create(type, projectId, objId, file, from_comment);
      promise.then(null, this.saveError.bind(this, file));
      return promise;
    };

    AttachmentsService.prototype.patch = function(id, type, patch) {
      var promise;
      promise = this.rs.attachments.patch(type, id, patch);
      promise.then(null, this.saveError.bind(this, null));
      return promise;
    };

    return AttachmentsService;

  })();

  angular.module("taigaCommon").service("tgAttachmentsService", AttachmentsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/avatar.service.coffee
 */

(function() {
  var AvatarService,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  AvatarService = (function() {
    function AvatarService(config) {
      var COLORS, IMAGES;
      this.config = config;
      IMAGES = ["/" + window._version + "/images/user-avatars/user-avatar-01.png", "/" + window._version + "/images/user-avatars/user-avatar-02.png", "/" + window._version + "/images/user-avatars/user-avatar-03.png", "/" + window._version + "/images/user-avatars/user-avatar-04.png", "/" + window._version + "/images/user-avatars/user-avatar-05.png"];
      COLORS = ["rgba( 178, 176, 204, 1 )", "rgba( 183, 203, 131, 1 )", "rgba( 210, 198, 139, 1 )", "rgba( 214, 161, 212, 1 )", "rgba( 247, 154, 154, 1 )"];
      this.logos = _.cartesianProduct(IMAGES, COLORS);
    }

    AvatarService.prototype.getDefault = function(key) {
      var idx, logo;
      idx = modulo(murmurhash3_32_gc(key, 42), this.logos.length);
      logo = this.logos[idx];
      return {
        src: logo[0],
        color: logo[1]
      };
    };

    AvatarService.prototype.getUnnamed = function() {
      return {
        url: "/" + window._version + "/images/unnamed.png",
        username: ''
      };
    };

    AvatarService.prototype.getAvatar = function(user, type) {
      var avatarParamName, gravatar, logo, logoUrl, photo, root, username;
      if (!user) {
        return this.getUnnamed();
      }
      avatarParamName = 'photo';
      if (type === 'avatarBig') {
        avatarParamName = 'big_photo';
      }
      photo = null;
      if (user instanceof Immutable.Map) {
        gravatar = user.get('gravatar_id');
        photo = user.get(avatarParamName);
        username = "@" + (user.get('username'));
      } else {
        gravatar = user.gravatar_id;
        photo = user[avatarParamName];
        username = "@" + user.username;
      }
      if (!gravatar) {
        return this.getUnnamed();
      }
      if (photo) {
        return {
          url: photo,
          username: username
        };
      } else if (location.host.indexOf('localhost') !== -1 || !this.config.get("gravatar", true)) {
        root = location.protocol + '//' + location.host;
        logo = this.getDefault(gravatar);
        return {
          url: root + logo.src,
          bg: logo.color,
          username: username
        };
      } else {
        root = location.protocol + '//' + location.host;
        logo = this.getDefault(gravatar);
        logoUrl = encodeURIComponent(root + logo.src);
        return {
          url: 'https://www.gravatar.com/avatar/' + gravatar + "?s=200&d=" + logoUrl,
          bg: logo.color,
          username: username
        };
      }
    };

    return AvatarService;

  })();

  angular.module("taigaCommon").service("tgAvatarService", ["$tgConfig", AvatarService]);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/check-permissions.service.coffee
 */

(function() {
  var CheckPermissionsService, taiga;

  taiga = this.taiga;

  CheckPermissionsService = (function() {
    CheckPermissionsService.$inject = ["tgProjectService"];

    function CheckPermissionsService(projectService) {
      this.projectService = projectService;
    }

    CheckPermissionsService.prototype.check = function(permission) {
      if (!this.projectService.project) {
        return false;
      }
      return this.projectService.project.get('my_permissions').indexOf(permission) !== -1;
    };

    return CheckPermissionsService;

  })();

  angular.module("taigaCommon").service("tgCheckPermissionsService", CheckPermissionsService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/current-user.service.coffee
 */

(function() {
  var CurrentUserService, groupBy, taiga;

  taiga = this.taiga;

  groupBy = this.taiga.groupBy;

  CurrentUserService = (function() {
    CurrentUserService.$inject = ["tgProjectsService", "$tgStorage", "tgResources"];

    function CurrentUserService(projectsService, storageService, rs) {
      this.projectsService = projectsService;
      this.storageService = storageService;
      this.rs = rs;
      this._user = null;
      this._projects = Immutable.Map();
      this._projectsById = Immutable.Map();
      this._joyride = null;
      taiga.defineImmutableProperty(this, "projects", (function(_this) {
        return function() {
          return _this._projects;
        };
      })(this));
      taiga.defineImmutableProperty(this, "projectsById", (function(_this) {
        return function() {
          return _this._projectsById;
        };
      })(this));
    }

    CurrentUserService.prototype.isAuthenticated = function() {
      if (this.getUser() !== null) {
        return true;
      }
      return false;
    };

    CurrentUserService.prototype.getUser = function() {
      var userData;
      if (!this._user) {
        userData = this.storageService.get("userInfo");
        if (userData) {
          userData = Immutable.fromJS(userData);
          this.setUser(userData);
        }
      }
      return this._user;
    };

    CurrentUserService.prototype.removeUser = function() {
      this._user = null;
      this._projects = Immutable.Map();
      this._projectsById = Immutable.Map();
      return this._joyride = null;
    };

    CurrentUserService.prototype.setUser = function(user) {
      this._user = user;
      return this._loadUserInfo();
    };

    CurrentUserService.prototype.bulkUpdateProjectsOrder = function(sortData) {
      return this.projectsService.bulkUpdateProjectsOrder(sortData).then((function(_this) {
        return function() {
          return _this.loadProjects();
        };
      })(this));
    };

    CurrentUserService.prototype.loadProjects = function() {
      return this.projectsService.getProjectsByUserId(this._user.get("id")).then((function(_this) {
        return function(projects) {
          return _this.setProjects(projects);
        };
      })(this));
    };

    CurrentUserService.prototype.loadProjectsList = function() {
      return this.projectsService.getListProjectsByUserId(this._user.get("id"), null).then((function(_this) {
        return function(projects) {
          return _this.setProjects(projects);
        };
      })(this));
    };

    CurrentUserService.prototype.disableJoyRide = function(section) {
      if (!this.isAuthenticated()) {
        return;
      }
      if (section) {
        this._joyride[section] = false;
      } else {
        this._joyride = {
          backlog: false,
          kanban: false,
          dashboard: false
        };
      }
      return this.rs.user.setUserStorage('joyride', this._joyride);
    };

    CurrentUserService.prototype.loadJoyRideConfig = function() {
      return new Promise((function(_this) {
        return function(resolve) {
          if (_this._joyride !== null) {
            resolve(_this._joyride);
            return;
          }
          return _this.rs.user.getUserStorage('joyride').then(function(config) {
            _this._joyride = config;
            return resolve(_this._joyride);
          })["catch"](function() {
            _this._joyride = {
              backlog: true,
              kanban: true,
              dashboard: true
            };
            _this.rs.user.createUserStorage('joyride', _this._joyride);
            return resolve(_this._joyride);
          });
        };
      })(this));
    };

    CurrentUserService.prototype._loadUserInfo = function() {
      return Promise.all([this.loadProjectsList()]);
    };

    CurrentUserService.prototype.setProjects = function(projects) {
      this._projects = this._projects.set("all", projects);
      this._projects = this._projects.set("recents", projects.slice(0, 10));
      this._projects = this._projects.set("unblocked", projects.filter(function(project) {
        return project.toJS().blocked_code === null;
      }));
      this._projectsById = Immutable.fromJS(groupBy(projects.toJS(), function(p) {
        return p.id;
      }));
      return this.projects;
    };

    CurrentUserService.prototype.canCreatePrivateProjects = function() {
      var user;
      user = this.getUser();
      if (user.get('max_private_projects') !== null && user.get('total_private_projects') >= user.get('max_private_projects')) {
        return {
          valid: false,
          reason: 'max_private_projects',
          type: 'private_project',
          current: user.get('total_private_projects'),
          max: user.get('max_private_projects')
        };
      }
      return {
        valid: true
      };
    };

    CurrentUserService.prototype.canCreatePublicProjects = function() {
      var user;
      user = this.getUser();
      if (user.get('max_public_projects') !== null && user.get('total_public_projects') >= user.get('max_public_projects')) {
        return {
          valid: false,
          reason: 'max_public_projects',
          type: 'public_project',
          current: user.get('total_public_projects'),
          max: user.get('max_public_projects')
        };
      }
      return {
        valid: true
      };
    };

    CurrentUserService.prototype.canAddMembersPublicProject = function(totalMembers) {
      var user;
      user = this.getUser();
      if (user.get('max_memberships_public_projects') !== null && totalMembers > user.get('max_memberships_public_projects')) {
        return {
          valid: false,
          reason: 'max_members_public_projects',
          type: 'public_project',
          current: totalMembers,
          max: user.get('max_memberships_public_projects')
        };
      }
      return {
        valid: true
      };
    };

    CurrentUserService.prototype.canAddMembersPrivateProject = function(totalMembers) {
      var user;
      user = this.getUser();
      if (user.get('max_memberships_private_projects') !== null && totalMembers > user.get('max_memberships_private_projects')) {
        return {
          valid: false,
          reason: 'max_members_private_projects',
          type: 'private_project',
          current: totalMembers,
          max: user.get('max_memberships_private_projects')
        };
      }
      return {
        valid: true
      };
    };

    CurrentUserService.prototype.canOwnProject = function(project) {
      var membersResult, result, user;
      user = this.getUser();
      if (project.get('is_private')) {
        result = this.canCreatePrivateProjects();
        if (!result.valid) {
          return result;
        }
        membersResult = this.canAddMembersPrivateProject(project.get('total_memberships'));
        if (!membersResult.valid) {
          return membersResult;
        }
      } else {
        result = this.canCreatePublicProjects();
        if (!result.valid) {
          return result;
        }
        membersResult = this.canAddMembersPublicProject(project.get('total_memberships'));
        if (!membersResult.valid) {
          return membersResult;
        }
      }
      return {
        valid: true
      };
    };

    return CurrentUserService;

  })();

  angular.module("taigaCommon").service("tgCurrentUserService", CurrentUserService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/error-handling.service.coffee
 */

(function() {
  var ErrorHandlingService, taiga;

  taiga = this.taiga;

  ErrorHandlingService = (function() {
    ErrorHandlingService.$inject = ["$rootScope"];

    function ErrorHandlingService(rootScope) {
      this.rootScope = rootScope;
    }

    ErrorHandlingService.prototype.init = function() {
      return this.rootScope.errorHandling = {};
    };

    ErrorHandlingService.prototype.notfound = function() {
      this.rootScope.errorHandling.showingError = true;
      return this.rootScope.errorHandling.notfound = true;
    };

    ErrorHandlingService.prototype.error = function() {
      this.rootScope.errorHandling.showingError = true;
      return this.rootScope.errorHandling.error = true;
    };

    ErrorHandlingService.prototype.permissionDenied = function() {
      this.rootScope.errorHandling.showingError = true;
      return this.rootScope.errorHandling.permissionDenied = true;
    };

    ErrorHandlingService.prototype.block = function() {
      this.rootScope.errorHandling.showingError = true;
      return this.rootScope.errorHandling.blocked = true;
    };

    return ErrorHandlingService;

  })();

  angular.module("taigaCommon").service("tgErrorHandlingService", ErrorHandlingService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/lightbox-factory.service.coffee
 */

(function() {
  var LightboxFactory;

  LightboxFactory = (function() {
    LightboxFactory.$inject = ["$rootScope", "$compile"];

    function LightboxFactory(rootScope, compile) {
      this.rootScope = rootScope;
      this.compile = compile;
    }

    LightboxFactory.prototype.create = function(name, attrs, scopeAttrs) {
      var elm, html, scope;
      scope = this.rootScope.$new();
      scope = _.merge(scope, scopeAttrs);
      elm = $("<div>").attr(name, true).attr("tg-bind-scope", true);
      if (attrs) {
        elm.attr(attrs);
      }
      elm.addClass("remove-on-close");
      html = this.compile(elm)(scope);
      $(document.body).append(html);
    };

    return LightboxFactory;

  })();

  angular.module("taigaCommon").service("tgLightboxFactory", LightboxFactory);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/paginate-response.service.coffee
 */

(function() {
  var PaginateResponse;

  PaginateResponse = function() {
    return function(result) {
      var paginateResponse;
      paginateResponse = Immutable.Map({
        "data": result.get("data"),
        "next": !!result.get("headers")("x-pagination-next"),
        "prev": !!result.get("headers")("x-pagination-prev"),
        "current": result.get("headers")("x-pagination-current"),
        "count": result.get("headers")("x-pagination-count")
      });
      return paginateResponse;
    };
  };

  angular.module("taigaCommon").factory("tgPaginateResponseService", PaginateResponse);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/project-logo.service.coffee
 */

(function() {
  var ProjectLogoService,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  ProjectLogoService = (function() {
    function ProjectLogoService() {
      var COLORS, IMAGES;
      IMAGES = ["/" + window._version + "/images/project-logos/project-logo-01.png", "/" + window._version + "/images/project-logos/project-logo-02.png", "/" + window._version + "/images/project-logos/project-logo-03.png", "/" + window._version + "/images/project-logos/project-logo-04.png", "/" + window._version + "/images/project-logos/project-logo-05.png"];
      COLORS = ["rgba( 153,  214, 220, 1 )", "rgba( 213,  156,  156, 1 )", "rgba( 214, 161, 212,  1 )", "rgba( 164, 162, 219, 1 )", "rgba( 152, 224, 168,  1 )"];
      this.logos = _.cartesianProduct(IMAGES, COLORS);
    }

    ProjectLogoService.prototype.getDefaultProjectLogo = function(slug, id) {
      var idx, key, logo;
      key = slug + "-" + id;
      idx = modulo(murmurhash3_32_gc(key, 42), this.logos.length);
      logo = this.logos[idx];
      return {
        src: logo[0],
        color: logo[1]
      };
    };

    return ProjectLogoService;

  })();

  angular.module("taigaCommon").service("tgProjectLogoService", ProjectLogoService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/project.service.coffee
 */

(function() {
  var ProjectService, taiga,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  taiga = this.taiga;

  ProjectService = (function() {
    ProjectService.$inject = ["$rootScope", "tgProjectsService", "tgXhrErrorService", "tgUserActivityService", "$interval"];

    function ProjectService(rootScope, projectsService, xhrError, userActivityService, interval) {
      this.rootScope = rootScope;
      this.projectsService = projectsService;
      this.xhrError = xhrError;
      this.userActivityService = userActivityService;
      this.interval = interval;
      this.manageProjectSignal = bind(this.manageProjectSignal, this);
      this._project = null;
      this._section = null;
      this._sectionsBreadcrumb = Immutable.List();
      this._activeMembers = Immutable.List();
      taiga.defineImmutableProperty(this, "project", (function(_this) {
        return function() {
          return _this._project;
        };
      })(this));
      taiga.defineImmutableProperty(this, "section", (function(_this) {
        return function() {
          return _this._section;
        };
      })(this));
      taiga.defineImmutableProperty(this, "sectionsBreadcrumb", (function(_this) {
        return function() {
          return _this._sectionsBreadcrumb;
        };
      })(this));
      taiga.defineImmutableProperty(this, "activeMembers", (function(_this) {
        return function() {
          return _this._activeMembers;
        };
      })(this));
      if (!window.localStorage.e2e) {
        this.autoRefresh();
      }
      this.watchSignals();
    }

    ProjectService.prototype.watchSignals = function() {
      var fetchRequiredSignals, i, len, results, signal;
      fetchRequiredSignals = ["admin:project-modules:updated", "admin:project-roles:updated", "admin:project-default-values:updated", "admin:project-values:updated", "admin:project-values:move", "admin:project-custom-attributes:updated", "sprintform:create:success", "sprintform:edit:success", "sprintform:remove:success", "tags:updated"];
      results = [];
      for (i = 0, len = fetchRequiredSignals.length; i < len; i++) {
        signal = fetchRequiredSignals[i];
        results.push(this.rootScope.$on(signal, this.manageProjectSignal));
      }
      return results;
    };

    ProjectService.prototype.manageProjectSignal = function(ctx) {
      return this.fetchProject();
    };

    ProjectService.prototype.cleanProject = function() {
      this._project = null;
      this._activeMembers = Immutable.List();
      this._section = null;
      return this._sectionsBreadcrumb = Immutable.List();
    };

    ProjectService.prototype.autoRefresh = function() {
      var intervalId;
      intervalId = this.interval((function(_this) {
        return function() {
          return _this.fetchProject();
        };
      })(this), 60 * 10 * 1000);
      this.userActivityService.onInactive((function(_this) {
        return function() {
          return _this.interval.cancel(intervalId);
        };
      })(this));
      return this.userActivityService.onActive((function(_this) {
        return function() {
          _this.fetchProject();
          return _this.autoRefresh();
        };
      })(this));
    };

    ProjectService.prototype.setSection = function(section) {
      this._section = section;
      if (section) {
        return this._sectionsBreadcrumb = this._sectionsBreadcrumb.push(this._section);
      } else {
        return this._sectionsBreadcrumb = Immutable.List();
      }
    };

    ProjectService.prototype.setProject = function(project) {
      this._project = project;
      return this._activeMembers = this._project.get('members').filter(function(member) {
        return member.get('is_active');
      });
    };

    ProjectService.prototype.setProjectBySlug = function(pslug) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (!_this.project || _this.project.get('slug') !== pslug) {
            return _this.projectsService.getProjectBySlug(pslug).then(function(project) {
              _this.setProject(project);
              return resolve();
            })["catch"](function(xhr) {
              return _this.xhrError.response(xhr);
            });
          } else {
            return resolve();
          }
        };
      })(this));
    };

    ProjectService.prototype.fetchProject = function() {
      var pslug;
      if (!this.project) {
        return;
      }
      pslug = this.project.get('slug');
      return this.projectsService.getProjectBySlug(pslug).then((function(_this) {
        return function(project) {
          return _this.setProject(project);
        };
      })(this));
    };

    ProjectService.prototype.hasPermission = function(permission) {
      return this._project.get('my_permissions').indexOf(permission) !== -1;
    };

    ProjectService.prototype.isEpicsDashboardEnabled = function() {
      return this._project.get("is_epics_activated");
    };

    return ProjectService;

  })();

  angular.module("taigaCommon").service("tgProjectService", ProjectService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/theme.service.coffee
 */

(function() {
  var ThemeService, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  ThemeService = (function(superClass) {
    extend(ThemeService, superClass);

    function ThemeService() {
      return ThemeService.__super__.constructor.apply(this, arguments);
    }

    ThemeService.prototype.use = function(themeName) {
      var stylesheetEl;
      stylesheetEl = $("link[rel='stylesheet']:first");
      if (stylesheetEl.length === 0) {
        stylesheetEl = $("<link rel='stylesheet' href='' type='text/css'>");
        $("head").append(stylesheetEl);
      }
      return stylesheetEl.attr("href", "/" + window._version + "/styles/theme-" + themeName + ".css");
    };

    return ThemeService;

  })(taiga.Service);

  angular.module("taigaCommon").service("tgThemeService", ThemeService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/user-activity.service.coffee
 */

(function() {
  var UserActivityService, groupBy, taiga;

  taiga = this.taiga;

  groupBy = this.taiga.groupBy;

  UserActivityService = (function() {
    UserActivityService.$inject = ['$timeout'];

    UserActivityService.prototype.idleTimeout = 60 * 5 * 1000;

    function UserActivityService(timeout) {
      this.timeout = timeout;
      if (window.localStorage.e2e) {
        return null;
      }
      window.addEventListener('mousemove', this.resetTimer.bind(this), false);
      window.addEventListener('mousedown', this.resetTimer.bind(this), false);
      window.addEventListener('keypress', this.resetTimer.bind(this), false);
      window.addEventListener('mousewheel', this.resetTimer.bind(this), false);
      window.addEventListener('touchmove', this.resetTimer.bind(this), false);
      this.subscriptionsActive = [];
      this.subscriptionsInactive = [];
      this.isActive = true;
      this.startTimer();
    }

    UserActivityService.prototype.startTimer = function() {
      return this.timerId = this.timeout(this._fireInactive.bind(this), this.idleTimeout);
    };

    UserActivityService.prototype.resetTimer = function() {
      if (!this.isActive) {
        this._fireActive();
      }
      this.timeout.cancel(this.timerId);
      this.startTimer();
      return this.isActive = true;
    };

    UserActivityService.prototype.onActive = function(cb) {
      this.subscriptionsActive.push(cb);
      return this._unSubscriptionsActive.bind(this, cb);
    };

    UserActivityService.prototype.onInactive = function(cb) {
      this.subscriptionsInactive.push(cb);
      return this._unSubscriptionsInactive.bind(this, cb);
    };

    UserActivityService.prototype._fireActive = function() {
      return this.subscriptionsActive.forEach(function(it) {
        return it();
      });
    };

    UserActivityService.prototype._fireInactive = function() {
      this.isActive = false;
      return this.subscriptionsInactive.forEach(function(it) {
        return it();
      });
    };

    UserActivityService.prototype._unSubscriptionsActive = function(cb) {
      return this.subscriptionsActive = this.subscriptionsActive.filter(function(fn) {
        return fn !== cb;
      });
    };

    UserActivityService.prototype._unSubscriptionsInactive = function(cb) {
      return this.subscriptionsInactive = this.subscriptionsInactive.filter(function(fn) {
        return fn !== cb;
      });
    };

    return UserActivityService;

  })();

  angular.module("taigaCommon").service("tgUserActivityService", UserActivityService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/user-list.service.coffee
 */

(function() {
  var UserListService, normalizeString, taiga;

  taiga = this.taiga;

  normalizeString = this.taiga.normalizeString;

  UserListService = (function() {
    UserListService.$inject = ["tgCurrentUserService", "tgProjectService"];

    function UserListService(currentUserService, projectService) {
      this.currentUserService = currentUserService;
      this.projectService = projectService;
    }

    UserListService.prototype.filterUsers = function(text, user) {
      var username;
      username = user.full_name_display.toUpperCase();
      username = normalizeString(username);
      text = text.toUpperCase();
      text = normalizeString(text);
      return _.includes(username, text);
    };

    UserListService.prototype.searchUsers = function(text, excludedUser) {
      var users;
      this.currentUser = this.currentUserService.getUser();
      users = _.clone(this.projectService.activeMembers.toJS(), true);
      if (excludedUser) {
        users = _.reject(users, {
          "id": excludedUser.id
        });
      }
      users = _.sortBy(users, (function(_this) {
        return function(o) {
          var ref;
          if (o.id === ((ref = _this.currentUser) != null ? ref.get('id') : void 0)) {
            return 0;
          } else {
            return o.id;
          }
        };
      })(this));
      if (text != null) {
        users = _.filter(users, _.partial(this.filterUsers, text));
      }
      return users;
    };

    return UserListService;

  })();

  angular.module("taigaCommon").service("tgUserListService", UserListService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/user.service.coffee
 */

(function() {
  var UserService, bindMethods, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  bindMethods = taiga.bindMethods;

  UserService = (function(superClass) {
    extend(UserService, superClass);

    UserService.$inject = ["tgResources"];

    function UserService(rs) {
      this.rs = rs;
      bindMethods(this);
    }

    UserService.prototype.getUserByUserName = function(username) {
      return this.rs.users.getUserByUsername(username);
    };

    UserService.prototype.getContacts = function(userId, excludeProjectId) {
      return this.rs.users.getContacts(userId, excludeProjectId);
    };

    UserService.prototype.getLiked = function(userId, pageNumber, objectType, textQuery) {
      return this.rs.users.getLiked(userId, pageNumber, objectType, textQuery);
    };

    UserService.prototype.getVoted = function(userId, pageNumber, objectType, textQuery) {
      return this.rs.users.getVoted(userId, pageNumber, objectType, textQuery);
    };

    UserService.prototype.getWatched = function(userId, pageNumber, objectType, textQuery) {
      return this.rs.users.getWatched(userId, pageNumber, objectType, textQuery);
    };

    UserService.prototype.getStats = function(userId) {
      return this.rs.users.getStats(userId);
    };

    UserService.prototype.attachUserContactsToProjects = function(userId, projects) {
      return this.getContacts(userId).then(function(contacts) {
        projects = projects.map(function(project) {
          var contactsFiltered;
          contactsFiltered = contacts.filter(function(contact) {
            var contactId;
            contactId = contact.get("id");
            return project.get('members').indexOf(contactId) !== -1;
          });
          project = project.set("contacts", contactsFiltered);
          return project;
        });
        return projects;
      });
    };

    return UserService;

  })(taiga.Service);

  angular.module("taigaCommon").service("tgUserService", UserService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: services/xhrError.service.coffee
 */

(function() {
  var xhrError,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  xhrError = (function(superClass) {
    extend(xhrError, superClass);

    xhrError.$inject = ["$q", "tgErrorHandlingService"];

    function xhrError(q, errorHandlingService) {
      this.q = q;
      this.errorHandlingService = errorHandlingService;
    }

    xhrError.prototype.notFound = function() {
      return this.errorHandlingService.notfound();
    };

    xhrError.prototype.permissionDenied = function() {
      return this.errorHandlingService.permissionDenied();
    };

    xhrError.prototype.response = function(xhr) {
      if (xhr) {
        if (xhr.status === 404) {
          this.notFound();
        } else if (xhr.status === 403) {
          this.permissionDenied();
        }
      }
      return this.q.reject(xhr);
    };

    return xhrError;

  })(taiga.Service);

  angular.module("taigaCommon").service("tgXhrErrorService", xhrError);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline-attachment/user-timeline-attachment.directive.coffee
 */

(function() {
  var UserTimelineAttachmentDirective;

  UserTimelineAttachmentDirective = function(template, $compile) {
    var isImage, link, validFileExtensions;
    validFileExtensions = [".jpg", ".jpeg", ".bmp", ".gif", ".png"];
    isImage = function(url) {
      url = url.toLowerCase();
      return _.some(validFileExtensions, function(extension) {
        return url.indexOf(extension, url - extension.length) !== -1;
      });
    };
    link = function(scope, el) {
      var is_image, templateHtml;
      is_image = isImage(scope.attachment.get('url'));
      if (is_image) {
        templateHtml = template.get("user-timeline/user-timeline-attachment/user-timeline-attachment-image.html");
      } else {
        templateHtml = template.get("user-timeline/user-timeline-attachment/user-timeline-attachment.html");
      }
      el.html(templateHtml);
      $compile(el.contents())(scope);
      return el.find("img").error(function() {
        return this.remove();
      });
    };
    return {
      link: link,
      scope: {
        attachment: "=tgUserTimelineAttachment"
      }
    };
  };

  UserTimelineAttachmentDirective.$inject = ["$tgTemplate", "$compile"];

  angular.module("taigaUserTimeline").directive("tgUserTimelineAttachment", UserTimelineAttachmentDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline-item/user-timeline-item-title.service.coffee
 */

(function() {
  var UserTimelineItemTitle, unslugify;

  unslugify = this.taiga.unslugify;

  UserTimelineItemTitle = (function() {
    UserTimelineItemTitle.$inject = ["$translate", "$sce"];

    UserTimelineItemTitle.prototype._fieldTranslationKey = {
      'status': 'COMMON.FIELDS.STATUS',
      'subject': 'COMMON.FIELDS.SUBJECT',
      'description_diff': 'COMMON.FIELDS.DESCRIPTION',
      'points': 'COMMON.FIELDS.POINTS',
      'assigned_to': 'COMMON.FIELDS.ASSIGNED_TO',
      'assigned_users': 'COMMON.FIELDS.ASSIGNED_USERS',
      'severity': 'ISSUES.FIELDS.SEVERITY',
      'priority': 'ISSUES.FIELDS.PRIORITY',
      'type': 'ISSUES.FIELDS.TYPE',
      'is_iocaine': 'TASK.FIELDS.IS_IOCAINE',
      'is_blocked': 'COMMON.FIELDS.IS_BLOCKED',
      'color': 'COMMON.FIELDS.COLOR',
      'due_date': 'COMMON.FIELDS.DUE_DATE',
      'due_date_reason': 'COMMON.FIELDS.DUE_DATE_REASON',
      'milestone': 'COMMON.FIELDS.SPRINT'
    };

    UserTimelineItemTitle.prototype._params = {
      username: function(timeline, event) {
        var title_attr, url, user;
        user = timeline.getIn(['data', 'user']);
        if (user.get('is_profile_visible')) {
          title_attr = this.translate.instant('COMMON.SEE_USER_PROFILE', {
            username: user.get('username')
          });
          url = "user-profile:username=timeline.getIn(['data', 'user', 'username'])";
          return this._getLink(url, user.get('name'), title_attr);
        } else {
          return this._getUsernameSpan(user.get('name'));
        }
      },
      field_name: function(timeline, event) {
        var field_name;
        field_name = timeline.getIn(['data', 'value_diff', 'key']);
        return this.translate.instant(this._fieldTranslationKey[field_name]);
      },
      project_name: function(timeline, event) {
        var url;
        url = "project:project=timeline.getIn(['data', 'project', 'slug'])";
        return this._getLink(url, timeline.getIn(["data", "project", "name"]));
      },
      new_value: function(timeline, event) {
        var new_value, prettyDate, value;
        if (_.isArray(timeline.getIn(["data", "value_diff", "value"]).toJS())) {
          value = timeline.getIn(["data", "value_diff", "value"]).get(1);
          if (value === null && timeline.getIn(["data", "value_diff", "key"]) === 'assigned_to') {
            value = this.translate.instant('ACTIVITY.VALUES.UNASSIGNED');
          }
          if (value === null && timeline.getIn(["data", "value_diff", "key"]) === 'assigned_users') {
            value = this.translate.instant('ACTIVITY.VALUES.UNASSIGNED');
          } else if (timeline.getIn(["data", "value_diff", "key"]) === 'due_date') {
            if (value) {
              prettyDate = this.translate.instant("COMMON.PICKERDATE.FORMAT");
              value = moment(value, "YYYY-MM-DD").format(prettyDate);
            } else {
              value = this.translate.instant('ACTIVITY.VALUES.NOT_SET');
            }
          }
          new_value = value;
        } else {
          new_value = timeline.getIn(["data", "value_diff", "value"]).first().get(1);
        }
        return $('<span>').attr('ng-non-bindable', true).text(new_value).prop('outerHTML');
      },
      sprint_name: function(timeline, event) {
        var url;
        url = "project-taskboard:project=timeline.getIn(['data', 'project', 'slug']),sprint=timeline.getIn(['data', 'milestone', 'slug'])";
        return this._getLink(url, timeline.getIn(['data', 'milestone', 'name']));
      },
      us_name: function(timeline, event) {
        var event_us, obj, text, url;
        obj = this._getTimelineObj(timeline, event).get('userstory');
        event_us = {
          obj: 'parent_userstory'
        };
        url = this._getDetailObjUrl(event_us);
        text = '#' + obj.get('ref') + ' ' + obj.get('subject');
        return this._getLink(url, text);
      },
      related_us_name: function(timeline, event) {
        var obj, text, url;
        obj = timeline.getIn(["data", "userstory"]);
        url = "project-userstories-detail:project=timeline.getIn(['data', 'userstory', 'project', 'slug']),ref=timeline.getIn(['data', 'userstory', 'ref'])";
        text = '#' + obj.get('ref') + ' ' + obj.get('subject');
        return this._getLink(url, text);
      },
      epic_name: function(timeline, event) {
        var obj, text, url;
        obj = timeline.getIn(["data", "epic"]);
        url = "project-epics-detail:project=timeline.getIn(['data', 'project', 'slug']),ref=timeline.getIn(['data', 'epic', 'ref'])";
        text = '#' + obj.get('ref') + ' ' + obj.get('subject');
        return this._getLink(url, text);
      },
      obj_name: function(timeline, event) {
        var obj, text, url;
        obj = this._getTimelineObj(timeline, event);
        url = this._getDetailObjUrl(event);
        if (event.obj === 'wikipage') {
          text = unslugify(obj.get('slug'));
        } else if (event.obj === 'milestone') {
          text = obj.get('name');
        } else {
          text = '#' + obj.get('ref') + ' ' + obj.get('subject');
        }
        return this._getLink(url, text);
      },
      role_name: function(timeline, event) {
        return _.escape(timeline.getIn(['data', 'value_diff', 'value']).keySeq().first());
      }
    };

    function UserTimelineItemTitle(translate, sce) {
      this.translate = translate;
      this.sce = sce;
    }

    UserTimelineItemTitle.prototype._translateTitleParams = function(param, timeline, event) {
      return this._params[param].call(this, timeline, event);
    };

    UserTimelineItemTitle.prototype._getTimelineObj = function(timeline, event) {
      return timeline.getIn(['data', event.obj]);
    };

    UserTimelineItemTitle.prototype._getDetailObjUrl = function(event) {
      var url;
      url = {
        "issue": ["project-issues-detail", ":project=timeline.getIn(['data', 'project', 'slug']),ref=timeline.getIn(['obj', 'ref'])"],
        "wikipage": ["project-wiki-page", ":project=timeline.getIn(['data', 'project', 'slug']),slug=timeline.getIn(['obj', 'slug'])"],
        "task": ["project-tasks-detail", ":project=timeline.getIn(['data', 'project', 'slug']),ref=timeline.getIn(['obj', 'ref'])"],
        "userstory": ["project-userstories-detail", ":project=timeline.getIn(['data', 'project', 'slug']),ref=timeline.getIn(['obj', 'ref'])"],
        "parent_userstory": ["project-userstories-detail", ":project=timeline.getIn(['data', 'project', 'slug']),ref=timeline.getIn(['obj', 'userstory', 'ref'])"],
        "milestone": ["project-taskboard", ":project=timeline.getIn(['data', 'project', 'slug']),sprint=timeline.getIn(['obj', 'slug'])"],
        "epic": ["project-epics-detail", ":project=timeline.getIn(['data', 'project', 'slug']),ref=timeline.getIn(['obj', 'ref'])"]
      };
      return url[event.obj][0] + url[event.obj][1];
    };

    UserTimelineItemTitle.prototype._getLink = function(url, text, title) {
      var span;
      title = title || text;
      span = $('<span>').attr('ng-non-bindable', true).text(text);
      return $('<a>').attr('tg-nav', url).append(span).prop('outerHTML');
    };

    UserTimelineItemTitle.prototype._getUsernameSpan = function(text) {
      var title;
      title = title || text;
      return $('<span>').addClass('username').text(text).prop('outerHTML');
    };

    UserTimelineItemTitle.prototype._getParams = function(timeline, event, timeline_type) {
      var params;
      params = {};
      timeline_type.translate_params.forEach((function(_this) {
        return function(param) {
          return params[param] = _this._translateTitleParams(param, timeline, event);
        };
      })(this));
      return params;
    };

    UserTimelineItemTitle.prototype.getTitle = function(timeline, event, type) {
      var params, paramsKeys, translation;
      params = this._getParams(timeline, event, type);
      paramsKeys = {};
      Object.keys(params).forEach(function(key) {
        return paramsKeys[key] = '{{' + key + '}}';
      });
      translation = this.translate.instant(type.key, paramsKeys);
      Object.keys(params).forEach(function(key) {
        var find;
        find = '{{' + key + '}}';
        return translation = translation.replace(new RegExp(find, 'g'), params[key]);
      });
      return translation;
    };

    return UserTimelineItemTitle;

  })();

  angular.module("taigaUserTimeline").service("tgUserTimelineItemTitle", UserTimelineItemTitle);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline-item/user-timeline-item-type.service.coffee
 */

(function() {
  var UserTimelineType, timelineType;

  timelineType = function(timeline, event) {
    var types;
    types = [
      {
        check: function(timeline, event) {
          return event.obj === 'membership';
        },
        key: 'TIMELINE.NEW_MEMBER',
        translate_params: ['project_name'],
        member: function(timeline) {
          return Immutable.Map({
            user: timeline.getIn(['data', 'user']),
            role: timeline.getIn(['data', 'role'])
          });
        }
      }, {
        check: function(timeline, event) {
          return event.obj === 'project' && event.type === 'create';
        },
        key: 'TIMELINE.NEW_PROJECT',
        translate_params: ['username', 'project_name'],
        description: function(timeline) {
          return timeline.getIn(['data', 'project', 'description']);
        }
      }, {
        check: function(timeline, event) {
          return event.type === 'change' && timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'attachments';
        },
        key: 'TIMELINE.UPLOAD_ATTACHMENT',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'userstory' && event.type === 'create';
        },
        key: 'TIMELINE.US_CREATED',
        translate_params: ['username', 'project_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'issue' && event.type === 'create';
        },
        key: 'TIMELINE.ISSUE_CREATED',
        translate_params: ['username', 'project_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'wikipage' && event.type === 'create';
        },
        key: 'TIMELINE.WIKI_CREATED',
        translate_params: ['username', 'project_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'task' && event.type === 'create' && !timeline.getIn(['data', 'task', 'userstory']);
        },
        key: 'TIMELINE.TASK_CREATED',
        translate_params: ['username', 'project_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'task' && event.type === 'create' && timeline.getIn(['data', 'task', 'userstory']);
        },
        key: 'TIMELINE.TASK_CREATED_WITH_US',
        translate_params: ['username', 'project_name', 'obj_name', 'us_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'milestone' && event.type === 'create';
        },
        key: 'TIMELINE.MILESTONE_CREATED',
        translate_params: ['username', 'project_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'epic' && event.type === 'create';
        },
        key: 'TIMELINE.EPIC_CREATED',
        translate_params: ['username', 'project_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'relateduserstory' && event.type === 'create';
        },
        key: 'TIMELINE.EPIC_RELATED_USERSTORY_CREATED',
        translate_params: ['username', 'project_name', 'related_us_name', 'epic_name']
      }, {
        check: function(timeline, event) {
          return timeline.getIn(['data', 'comment']) && event.obj === 'userstory';
        },
        key: 'TIMELINE.NEW_COMMENT_US',
        translate_params: ['username', 'obj_name'],
        description: function(timeline) {
          var text;
          text = timeline.getIn(['data', 'comment_html']);
          return $($.parseHTML(text)).text();
        }
      }, {
        check: function(timeline, event) {
          return timeline.getIn(['data', 'comment']) && event.obj === 'issue';
        },
        key: 'TIMELINE.NEW_COMMENT_ISSUE',
        translate_params: ['username', 'obj_name'],
        description: function(timeline) {
          var text;
          text = timeline.getIn(['data', 'comment_html']);
          return $($.parseHTML(text)).text();
        }
      }, {
        check: function(timeline, event) {
          return timeline.getIn(['data', 'comment']) && event.obj === 'task';
        },
        key: 'TIMELINE.NEW_COMMENT_TASK',
        translate_params: ['username', 'obj_name'],
        description: function(timeline) {
          var text;
          text = timeline.getIn(['data', 'comment_html']);
          return $($.parseHTML(text)).text();
        }
      }, {
        check: function(timeline, event) {
          return timeline.getIn(['data', 'comment']) && event.obj === 'epic';
        },
        key: 'TIMELINE.NEW_COMMENT_EPIC',
        translate_params: ['username', 'obj_name'],
        description: function(timeline) {
          var text;
          text = timeline.getIn(['data', 'comment_html']);
          return $($.parseHTML(text)).text();
        }
      }, {
        check: function(timeline, event) {
          return timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'moveInBacklog' && timeline.hasIn(['data', 'value_diff', 'value', 'backlog_order']) && event.type === 'change';
        },
        key: 'TIMELINE.US_MOVED',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(timeline, event) {
          if (timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'moveInBacklog' && event.type === 'change' && event.obj === 'userstory') {
            return timeline.getIn(['data', 'value_diff', 'value', 'milestone']).get(1) === null;
          }
          return false;
        },
        key: 'TIMELINE.US_REMOVED_FROM_MILESTONE',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(timeline, event) {
          return timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'moveInBacklog' && event.type === 'change' && event.obj === 'userstory';
        },
        key: 'TIMELINE.US_ADDED_MILESTONE',
        translate_params: ['username', 'obj_name', 'sprint_name']
      }, {
        check: function(timeline, event) {
          if (timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'blocked' && event.type === 'change') {
            return timeline.getIn(['data', 'value_diff', 'value', 'is_blocked']).get(1) === true;
          }
          return false;
        },
        key: 'TIMELINE.BLOCKED',
        translate_params: ['username', 'obj_name'],
        description: function(timeline) {
          var text;
          if (timeline.hasIn(['data', 'value_diff', 'value', 'blocked_note_html'])) {
            text = timeline.getIn(['data', 'value_diff', 'value', 'blocked_note_html']).get(1);
            return $($.parseHTML(text)).text();
          } else {
            return false;
          }
        }
      }, {
        check: function(timeline, event) {
          if (timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'blocked' && event.type === 'change') {
            return timeline.getIn(['data', 'value_diff', 'value', 'is_blocked']).get(1) === false;
          }
          return false;
        },
        key: 'TIMELINE.UNBLOCKED',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'milestone' && event.type === 'change';
        },
        key: 'TIMELINE.MILESTONE_UPDATED',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'wikipage' && event.type === 'change';
        },
        key: 'TIMELINE.WIKI_UPDATED',
        translate_params: ['username', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'userstory' && event.type === 'change' && timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'points';
        },
        key: 'TIMELINE.US_UPDATED_POINTS',
        translate_params: ['username', 'field_name', 'obj_name', 'new_value', 'role_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'userstory' && event.type === 'change' && timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'description_diff';
        },
        key: 'TIMELINE.US_UPDATED',
        translate_params: ['username', 'field_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'userstory' && event.type === 'change';
        },
        key: 'TIMELINE.US_UPDATED_WITH_NEW_VALUE',
        translate_params: ['username', 'field_name', 'obj_name', 'new_value']
      }, {
        check: function(timeline, event) {
          return event.obj === 'issue' && event.type === 'change' && timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'description_diff';
        },
        key: 'TIMELINE.ISSUE_UPDATED',
        translate_params: ['username', 'field_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'issue' && event.type === 'change';
        },
        key: 'TIMELINE.ISSUE_UPDATED_WITH_NEW_VALUE',
        translate_params: ['username', 'field_name', 'obj_name', 'new_value']
      }, {
        check: function(timeline, event) {
          return event.obj === 'task' && event.type === 'change' && !timeline.getIn(['data', 'task', 'userstory']) && timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'description_diff';
        },
        key: 'TIMELINE.TASK_UPDATED',
        translate_params: ['username', 'field_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'task' && event.type === 'change' && timeline.getIn(['data', 'task', 'userstory']) && timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'description_diff';
        },
        key: 'TIMELINE.TASK_UPDATED_WITH_US',
        translate_params: ['username', 'field_name', 'obj_name', 'us_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'task' && event.type === 'change' && !timeline.getIn(['data', 'task', 'userstory']);
        },
        key: 'TIMELINE.TASK_UPDATED_WITH_NEW_VALUE',
        translate_params: ['username', 'field_name', 'obj_name', 'new_value']
      }, {
        check: function(timeline, event) {
          return event.obj === 'task' && event.type === 'change' && timeline.getIn(['data', 'task', 'userstory']);
        },
        key: 'TIMELINE.TASK_UPDATED_WITH_US_NEW_VALUE',
        translate_params: ['username', 'field_name', 'obj_name', 'us_name', 'new_value']
      }, {
        check: function(timeline, event) {
          return event.obj === 'epic' && event.type === 'change' && timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'description_diff';
        },
        key: 'TIMELINE.EPIC_UPDATED',
        translate_params: ['username', 'field_name', 'obj_name']
      }, {
        check: function(timeline, event) {
          return event.obj === 'epic' && event.type === 'change' && timeline.hasIn(['data', 'value_diff']) && timeline.getIn(['data', 'value_diff', 'key']) === 'color';
        },
        key: 'TIMELINE.EPIC_UPDATED_WITH_NEW_COLOR',
        translate_params: ['username', 'field_name', 'obj_name', 'new_value']
      }, {
        check: function(timeline, event) {
          return event.obj === 'epic' && event.type === 'change';
        },
        key: 'TIMELINE.EPIC_UPDATED_WITH_NEW_VALUE',
        translate_params: ['username', 'field_name', 'obj_name', 'new_value']
      }, {
        check: function(timeline, event) {
          return event.obj === 'user' && event.type === 'create';
        },
        key: 'TIMELINE.NEW_USER',
        translate_params: ['username']
      }
    ];
    return _.find(types, function(obj) {
      return obj.check(timeline, event);
    });
  };

  UserTimelineType = (function() {
    function UserTimelineType() {}

    UserTimelineType.prototype.getType = function(timeline, event) {
      return timelineType(timeline, event);
    };

    return UserTimelineType;

  })();

  angular.module("taigaUserTimeline").service("tgUserTimelineItemType", UserTimelineType);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline-item/user-timeline-item.directive.coffee
 */

(function() {
  var UserTimelineItemDirective;

  UserTimelineItemDirective = function() {
    return {
      templateUrl: "user-timeline/user-timeline-item/user-timeline-item.html",
      scope: {
        timeline: "=tgUserTimelineItem"
      }
    };
  };

  angular.module("taigaUserTimeline").directive("tgUserTimelineItem", UserTimelineItemDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline-pagination-sequence/user-timeline-pagination-sequence.service.coffee
 */

(function() {
  var UserTimelinePaginationSequence;

  UserTimelinePaginationSequence = function() {
    var obj;
    obj = {};
    obj.generate = function(config) {
      var getContent, items, next, page;
      page = 1;
      items = Immutable.List();
      config.minItems = config.minItems || 20;
      next = function() {
        items = Immutable.List();
        return getContent();
      };
      getContent = function() {
        return config.fetch(page).then(function(response) {
          var data, pagination;
          page++;
          data = response.get("data");
          if (config.filter) {
            data = config.filter(data);
          }
          if (config.map) {
            data = data.map(config.map);
          }
          items = items.concat(data);
          if (items.size < config.minItems && response.get("next")) {
            return getContent();
          }
          pagination = Immutable.Map({
            items: items,
            total: response.get("total"),
            next: response.get("next")
          });
          return pagination;
        });
      };
      return {
        next: function() {
          return next();
        }
      };
    };
    return obj;
  };

  angular.module("taigaUserTimeline").factory("tgUserTimelinePaginationSequenceService", UserTimelinePaginationSequence);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline/user-timeline.controller.coffee
 */

(function() {
  var UserTimelineController, mixOf, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  mixOf = this.taiga.mixOf;

  UserTimelineController = (function(superClass) {
    extend(UserTimelineController, superClass);

    UserTimelineController.$inject = ["tgUserTimelineService"];

    function UserTimelineController(userTimelineService) {
      this.userTimelineService = userTimelineService;
      this.timelineList = Immutable.List();
      this.scrollDisabled = false;
      this.timeline = null;
      if (this.projectId) {
        this.timeline = this.userTimelineService.getProjectTimeline(this.projectId);
      } else if (this.currentUser) {
        this.timeline = this.userTimelineService.getProfileTimeline(this.user.get("id"));
      } else {
        this.timeline = this.userTimelineService.getUserTimeline(this.user.get("id"));
      }
      this.loadTimeline();
    }

    UserTimelineController.prototype.loadTimeline = function() {
      this.scrollDisabled = true;
      return this.timeline.next().then((function(_this) {
        return function(response) {
          _this.timelineList = _this.timelineList.concat(response.get("items"));
          if (response.get("next")) {
            _this.scrollDisabled = false;
          }
          return _this.timelineList;
        };
      })(this));
    };

    return UserTimelineController;

  })(mixOf(taiga.Controller, taiga.PageMixin, taiga.FiltersMixin));

  angular.module("taigaUserTimeline").controller("UserTimeline", UserTimelineController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline/user-timeline.directive.coffee
 */

(function() {
  var UserTimelineDirective;

  UserTimelineDirective = function() {
    return {
      templateUrl: "user-timeline/user-timeline/user-timeline.html",
      controller: "UserTimeline",
      controllerAs: "vm",
      scope: {
        projectId: "=projectid",
        user: "=",
        currentUser: "="
      },
      bindToController: true
    };
  };

  angular.module("taigaProfile").directive("tgUserTimeline", UserTimelineDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: user-timeline/user-timeline/user-timeline.service.coffee
 */

(function() {
  var UserTimelineService, taiga,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  taiga = this.taiga;

  UserTimelineService = (function(superClass) {
    extend(UserTimelineService, superClass);

    UserTimelineService.$inject = ["tgResources", "tgUserTimelinePaginationSequenceService", "tgUserTimelineItemType", "tgUserTimelineItemTitle"];

    function UserTimelineService(rs, userTimelinePaginationSequenceService, userTimelineItemType, userTimelineItemTitle) {
      this.rs = rs;
      this.userTimelinePaginationSequenceService = userTimelinePaginationSequenceService;
      this.userTimelineItemType = userTimelineItemType;
      this.userTimelineItemTitle = userTimelineItemTitle;
    }

    UserTimelineService.prototype._valid_fields = ['status', 'subject', 'description_diff', 'assigned_users', 'assigned_to', 'points', 'severity', 'priority', 'type', 'attachments', 'is_iocaine', 'content_diff', 'name', 'estimated_finish', 'estimated_start', 'blocked', 'moveInBacklog', 'milestone', 'color', 'due_date', 'due_date_reason'];

    UserTimelineService.prototype._invalid = [
      {
        check: function(timeline) {
          var fieldKey, value_diff;
          value_diff = timeline.get("data").get("value_diff");
          if (value_diff) {
            fieldKey = value_diff.get('key');
            if (this._valid_fields.indexOf(fieldKey) === -1) {
              return true;
            } else if (fieldKey === 'attachments' && value_diff.get('value').get('new').size === 0) {
              return true;
            }
          }
          return false;
        }
      }, {
        check: function(timeline) {
          var event, value_diff;
          event = timeline.get('event_type').split(".");
          value_diff = timeline.get("data").get("value_diff");
          return event[2] === 'change' && value_diff === void 0;
        }
      }, {
        check: function(timeline) {
          var event;
          event = timeline.get('event_type').split(".");
          return event[2] === 'delete';
        }
      }, {
        check: function(timeline) {
          var event;
          event = timeline.get('event_type').split(".");
          return event[1] === 'project' && event[2] === 'change';
        }
      }, {
        check: function(timeline) {
          return !!timeline.get("data").get("comment_deleted");
        }
      }, {
        check: function(timeline) {
          var event, value_diff;
          event = timeline.get('event_type').split(".");
          value_diff = timeline.get("data").get("value_diff");
          if (value_diff && event[1] === "task" && event[2] === "change" && value_diff.get("key") === "milestone") {
            return timeline.get("data").get("value_diff").get("value");
          }
          return false;
        }
      }
    ];

    UserTimelineService.prototype._isInValidTimeline = function(timeline) {
      return _.some(this._invalid, (function(_this) {
        return function(invalid) {
          return invalid.check.call(_this, timeline);
        };
      })(this));
    };

    UserTimelineService.prototype._parseEventType = function(event_type) {
      event_type = event_type.split(".");
      return {
        section: event_type[0],
        obj: event_type[1],
        type: event_type[2]
      };
    };

    UserTimelineService.prototype._getTimelineObject = function(timeline, event) {
      if (timeline.get('data').get(event.obj)) {
        return timeline.get('data').get(event.obj);
      }
    };

    UserTimelineService.prototype._attachExtraInfoToTimelineEntry = function(timeline, event, type) {
      var title;
      title = this.userTimelineItemTitle.getTitle(timeline, event, type);
      timeline = timeline.set('title_html', title);
      timeline = timeline.set('obj', this._getTimelineObject(timeline, event));
      if (type.description) {
        timeline = timeline.set('description', type.description(timeline));
      }
      if (type.member) {
        timeline = timeline.set('member', type.member(timeline));
      }
      if (timeline.getIn(['data', 'value_diff', 'key']) === 'attachments' && timeline.hasIn(['data', 'value_diff', 'value', 'new'])) {
        timeline = timeline.set('attachments', timeline.getIn(['data', 'value_diff', 'value', 'new']));
      }
      return timeline;
    };

    UserTimelineService.prototype._parseTimeline = function(response) {
      var newdata;
      newdata = Immutable.List();
      response.get('data').forEach((function(_this) {
        return function(item) {
          var data, event, newItem, values_diff;
          event = _this._parseEventType(item.get('event_type'));
          data = item.get('data');
          values_diff = data.get('values_diff');
          if (values_diff && values_diff.count()) {
            if (values_diff.has('is_blocked')) {
              values_diff = Immutable.Map({
                'blocked': values_diff
              });
            }
            if (values_diff.has('milestone')) {
              if (event.obj === 'userstory') {
                values_diff = Immutable.Map({
                  'moveInBacklog': values_diff
                });
              } else {
                values_diff = values_diff.deleteIn(['values_diff', 'milestone']);
              }
            } else if (event.obj === 'milestone') {
              values_diff = Immutable.Map({
                'milestone': values_diff
              });
            }
            return values_diff.forEach(function(value, key) {
              var newItem, obj;
              obj = Immutable.Map({
                key: key,
                value: value
              });
              newItem = item.setIn(['data', 'value_diff'], obj);
              newItem = newItem.deleteIn(['data', 'values_diff']);
              return newdata = newdata.push(newItem);
            });
          } else {
            newItem = item.deleteIn(['data', 'values_diff']);
            return newdata = newdata.push(newItem);
          }
        };
      })(this));
      return response.set('data', newdata);
    };

    UserTimelineService.prototype._addEntyAttributes = function(item) {
      var event, type;
      event = this._parseEventType(item.get('event_type'));
      type = this.userTimelineItemType.getType(item, event);
      return this._attachExtraInfoToTimelineEntry(item, event, type);
    };

    UserTimelineService.prototype.getProfileTimeline = function(userId) {
      var config;
      config = {};
      config.fetch = (function(_this) {
        return function(page) {
          return _this.rs.users.getProfileTimeline(userId, page).then(function(response) {
            return _this._parseTimeline(response);
          });
        };
      })(this);
      config.map = (function(_this) {
        return function(obj) {
          return _this._addEntyAttributes(obj);
        };
      })(this);
      config.filter = (function(_this) {
        return function(items) {
          return items.filterNot(function(item) {
            return _this._isInValidTimeline(item);
          });
        };
      })(this);
      return this.userTimelinePaginationSequenceService.generate(config);
    };

    UserTimelineService.prototype.getUserTimeline = function(userId) {
      var config;
      config = {};
      config.fetch = (function(_this) {
        return function(page) {
          return _this.rs.users.getUserTimeline(userId, page).then(function(response) {
            return _this._parseTimeline(response);
          });
        };
      })(this);
      config.map = (function(_this) {
        return function(obj) {
          return _this._addEntyAttributes(obj);
        };
      })(this);
      config.filter = (function(_this) {
        return function(items) {
          return items.filterNot(function(item) {
            return _this._isInValidTimeline(item);
          });
        };
      })(this);
      return this.userTimelinePaginationSequenceService.generate(config);
    };

    UserTimelineService.prototype.getProjectTimeline = function(projectId) {
      var config;
      config = {};
      config.fetch = (function(_this) {
        return function(page) {
          return _this.rs.projects.getTimeline(projectId, page).then(function(response) {
            return _this._parseTimeline(response);
          });
        };
      })(this);
      config.map = (function(_this) {
        return function(obj) {
          return _this._addEntyAttributes(obj);
        };
      })(this);
      config.filter = (function(_this) {
        return function(items) {
          return items.filterNot(function(item) {
            return _this._isInValidTimeline(item);
          });
        };
      })(this);
      return this.userTimelinePaginationSequenceService.generate(config);
    };

    return UserTimelineService;

  })(taiga.Service);

  angular.module("taigaUserTimeline").service("tgUserTimelineService", UserTimelineService);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: utils/isolate-click.directive.coffee
 */

(function() {
  var IsolateClickDirective;

  IsolateClickDirective = function() {
    var link;
    link = function(scope, el, attrs) {
      return el.on('click', (function(_this) {
        return function(e) {
          return e.stopPropagation();
        };
      })(this));
    };
    return {
      link: link
    };
  };

  angular.module("taigaUtils").directive("tgIsolateClick", IsolateClickDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: wiki/history/wiki-history-diff.directive.coffee
 */

(function() {
  var WikiHistoryDiffDirective, module;

  module = angular.module('taigaWikiHistory');

  WikiHistoryDiffDirective = function() {
    return {
      templateUrl: "wiki/history/wiki-history-diff.html",
      scope: {
        key: "<",
        diff: "<"
      }
    };
  };

  module.directive("tgWikiHistoryDiff", WikiHistoryDiffDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: wiki/history/wiki-history-entry.directive.coffee
 */

(function() {
  var WikiHistoryEntryDirective, module;

  module = angular.module('taigaWikiHistory');

  WikiHistoryEntryDirective = function() {
    var link;
    link = function(scope, el, attr) {
      return scope.singleHistoryEntry = scope.historyEntry.toJS();
    };
    return {
      link: link,
      templateUrl: "wiki/history/wiki-history-entry.html",
      scope: {
        historyEntry: "<"
      }
    };
  };

  module.directive("tgWikiHistoryEntry", WikiHistoryEntryDirective);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: wiki/history/wiki-history.controller.coffee
 */

(function() {
  var WikiHistoryController, module, taiga;

  taiga = this.taiga;

  module = angular.module("taigaWikiHistory");

  WikiHistoryController = (function() {
    WikiHistoryController.$inject = ["tgActivityService"];

    function WikiHistoryController(activityService) {
      this.activityService = activityService;
      taiga.defineImmutableProperty(this, 'historyEntries', (function(_this) {
        return function() {
          return _this.activityService.entries;
        };
      })(this));
      taiga.defineImmutableProperty(this, 'disablePagination', (function(_this) {
        return function() {
          return _this.activityService.disablePagination;
        };
      })(this));
      this.toggle = false;
    }

    WikiHistoryController.prototype.initializeHistory = function(wikiId) {
      if (wikiId) {
        this.activityService.init('wiki', wikiId);
      }
      return this.loadHistory();
    };

    WikiHistoryController.prototype.loadHistory = function() {
      return this.activityService.fetchEntries();
    };

    WikiHistoryController.prototype.nextPage = function() {
      return this.activityService.nextPage();
    };

    return WikiHistoryController;

  })();

  module.controller("WikiHistoryCtrl", WikiHistoryController);

}).call(this);


/*
 * Copyright (C) 2014-2018 Taiga Agile LLC
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * File: wiki/history/wiki-history.directive.coffee
 */

(function() {
  var WikiHistoryDirective, bindOnce, module;

  bindOnce = this.taiga.bindOnce;

  module = angular.module('taigaWikiHistory');

  WikiHistoryDirective = function() {
    var link;
    link = function(scope, el, attrs, ctrl) {
      return bindOnce(scope, 'vm.wikiId', function(value) {
        return ctrl.initializeHistory(value);
      });
    };
    return {
      scope: {},
      bindToController: {
        wikiId: "<"
      },
      controller: "WikiHistoryCtrl",
      controllerAs: "vm",
      templateUrl: "wiki/history/wiki-history.html",
      link: link
    };
  };

  module.directive("tgWikiHistory", WikiHistoryDirective);

}).call(this);

//# sourceMappingURL=maps/app.js.map
